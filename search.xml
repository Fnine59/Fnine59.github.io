<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《JavaScript标准参考教程》阅读笔记]]></title>
    <url>%2F2018%2F05%2F02%2F%E3%80%8AJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址[https://github.com/ruanyf/jstutorial) 基本语法语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤。如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 注意：中文是合法的标识符，可以用作变量名。 JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 条件语句条件语句包括if和switch。 if结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，往往由一个条件表达式产生，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 对同一个变量进行多次判断时，多个if…else语句可以连写在一起。 else代码块总是与离自己最近的那个if语句配对。 switch结构switch结构会根据switch关键字后紧跟的变量或表达式的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。 switch语句部分和case语句部分，都可以使用表达式。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 三元运算符 ?:JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 这个三元运算符可以被视为if…else…的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar do not has a value&apos;)// myVar do not has a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 循环语句循环语句用于重复执行某个操作，它有多种形式。 while 循环while语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 所有for循环，都可以改写成while循环。 for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do…while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。for循环也可以使用break语句跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 数组定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 数组的赋值除了在定义时赋值，也可以先定义后赋值。123456789var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];// 或者var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。而如果数组的元素还是数组，就形成了多维数组。123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。例子如下：1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 我们知道，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 length 属性数组的length属性，返回数组的成员数量。 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 因此，清空数组的一个有效方法，就是将length属性设为0。 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 但是，如果人为设置length为不合法的值，JavaScript 会报错。1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值，例子如下。1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。一定要注意检查的是键名。1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for…in遍历数组。数组的遍历可以考虑使用for循环或while循环。数组的forEach方法，也可以用来遍历数组。1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位个数影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 数组的空位是可以读取的，返回undefined。12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 但如果某个位置是undefined，遍历的时候就不会被跳过。123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 关于arguments作一个简短的概述：在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。 例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0]也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。因此，无需明确命名参数，就可以重写函数：1234567function sayHi() &#123; if (arguments[0] == &quot;bye&quot;) &#123; return; &#125; alert(arguments[0]);&#125; 还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。 用arguments对象判断传递给函数的参数个数，即可模拟函数重载：12345678910function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 5); &#125; else if(arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); //输出 &quot;15&quot;doAdd(40, 20); //输出 &quot;60&quot; 当只有一个参数时，doAdd()函数给参数加5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，doAdd(10)输出的是”15”，而 doAdd(40, 20) 输出的是”60”。虽然不如重载那么好，不过已足以避开 ECMAScript 的这种限制。 回到正题，使用数组的slice方法可以将“类似数组的对象”变成真正的数组。1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c 数据类型转换JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 强制转换强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。 Number()使用Number函数，可以将任意类型的值转化成数值。 下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 ####### 原始类型值 原始类型值的转换规则如下。1234567891011121314151617181920212223// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0Number(NaN) // NaN Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。12parseInt(&apos;\t\v\r12.34\n&apos;) // 12Number(&apos;\t\v\r12.34\n&apos;) // 12.34 对象简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 1234Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5Number([]) // 0，因为toString方法转化为&quot;&quot;，即空字符串 之所以会这样，是因为Number背后的转换规则比较复杂。 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 请看下面的例子。123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125; 上面代码中，Number函数将obj对象转为数值。背后发生了一连串的操作，首先调用obj.valueOf方法, 结果返回对象本身；于是，继续调用obj.toString方法，这时返回字符串[object Object]，对这个字符串使用Number函数，得到NaN。 默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，而toString方法返回对象的类型字符串（比如[object Object]）。所以，会有下面的结果。1Number(&#123;&#125;) // NaN 如果toString方法返回的不是原始类型的值，结果就会报错。1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;Number(obj)// TypeError: Cannot convert object to primitive value 上面代码的valueOf和toString方法，返回的都是对象，所以转成数值时会报错。 从上例还可以看到，valueOf和toString方法，都是可以自定义的。1234567891011121314151617181920212223Number(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// 2Number(&#123; toString: function () &#123; return 3; &#125;&#125;)// 3Number(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// 2 上面代码对三个对象使用Number函数。第一个对象返回valueOf方法的值，第二个对象返回toString方法的值，第三个对象表示valueOf方法先于toString方法执行。 String()String函数可以将任意类型的值转化成字符串，转换规则如下。 原始类型值 数值：转为相应的字符串。字符串：转换后还是原来的值。布尔值：true转为字符串”true”，false转为字符串”false”。undefined：转为字符串”undefined”。null：转为字符串”null”。 12345String(123) // &quot;123&quot;String(&apos;abc&apos;) // &quot;abc&quot;String(true) // &quot;true&quot;String(undefined) // &quot;undefined&quot;String(null) // &quot;null&quot; 对象String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 下面是一个例子。123456String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 下面是通过自定义toString方法，改变返回值的例子。1234567891011121314151617181920212223String(&#123; toString: function () &#123; return 3; &#125;&#125;)// &quot;3&quot;String(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// &quot;[object Object]&quot;String(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// &quot;3&quot; 上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。 Boolean()Boolean函数可以将任意类型的值转为布尔值。 它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 undefinednull-0或+0NaN‘’（空字符串） 12345Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&apos;&apos;) // false 注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true（详见《原始类型值的包装对象》一章）。123Boolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true 所有对象的布尔值都是true，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于obj1 &amp;&amp; obj2这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为true。 自动转换下面介绍自动转换，它是以强制转换为基础的。 遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。 第一种情况，不同类型的数据互相运算。1123 + &apos;abc&apos; // &quot;123abc&quot; 第二种情况，对非布尔值类型的数据求布尔值。123if (&apos;abc&apos;) &#123; console.log(&apos;hello&apos;)&#125; // &quot;hello&quot; 第三种情况，对非数值类型的值使用一元运算符（即+和-）。12+ &#123;foo: &apos;bar&apos;&#125; // NaN- [1, 2, 3] // NaN 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。 自动转换为布尔值JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。 下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是Boolean函数。12345// 写法一expression ? true : false// 写法二!! expression 自动转换为字符串JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。 12345678&apos;5&apos; + 1 // &apos;51&apos;&apos;5&apos; + true // &quot;5true&quot;&apos;5&apos; + false // &quot;5false&quot;&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot;&apos;5&apos; + [] // &quot;5&quot;&apos;5&apos; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;&apos;5&apos; + undefined // &quot;5undefined&quot;&apos;5&apos; + null // &quot;5null&quot; 这种自动转换很容易出错。12345var obj = &#123; width: &apos;100&apos;&#125;;obj.width + 20 // &quot;10020&quot; 上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。 自动转换为数值JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 下面是几个特殊例子。 1234567true - 1 // 0false - 1 // -1&apos;abc&apos; - 1 // NaN&apos;5&apos; * [] // 0false / &apos;5&apos; // 0，可以计算0除以几，只不过都等于0null + 1 // 1undefined + 1 // NaN 上面代码中，运算符两侧的运算子，都被转成了数值。 注意：null转为数值时为0，而undefined转为数值时为NaN。 一元运算符也会把运算子转成数值。1234+&apos;abc&apos; // NaN-&apos;abc&apos; // NaN+true // 1-false // 0 错误处理机制Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 12var err = new Error(&apos;出错了&apos;);err.message // &quot;出错了&quot; 上面代码中，我们调用Error构造函数，生成一个实例对象err。Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 使用name和message这两个属性，可以对发生什么错误有一个大概的了解。123if (error.name) &#123; console.log(error.name + &apos;: &apos; + error.message);&#125; stack属性用来查看错误发生时的堆栈。1234567891011121314151617function throwit() &#123; throw new Error(&apos;&apos;);&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。 原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log &apos;hello&apos;);// Uncaught SyntaxError: Unexpected string 上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。1234567// 等号左侧不是变量console.log() = 1// Uncaught ReferenceError: Invalid left-hand side in assignment// this 对象不能手动赋值this = 1// ReferenceError: Invalid left-hand side in assignment RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。 主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型，或者调用了不存在的方法时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 123456new 123// Uncaught TypeError: number is not a funcvar obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 12decodeURI(&apos;%2&apos;)// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。eval是求值函数，实际上用的并不多。 总结以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。 1234567var err1 = new Error(&apos;出错了！&apos;);var err2 = new RangeError(&apos;出错了，变量超出有效范围！&apos;);var err3 = new TypeError(&apos;出错了，变量类型无效！&apos;);err1.message // &quot;出错了！&quot;err2.message // &quot;出错了，变量超出有效范围！&quot;err3.message // &quot;出错了，变量类型无效！&quot; 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 1234567function UserError(message) &#123; this.message = message || &apos;默认信息&apos;; this.name = &apos;UserError&apos;;&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。 1new UserError(&apos;这是自定义的错误！&apos;); 对上例中的prototype进行简短的解释，prototype 属性使用户有能力向对象添加属性和方法，语法为object.prototype.name=value。例子如下：1234567891011121314function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);employee.prototype.salary=null;bill.salary=20000;document.write(bill.salary);// 20000 对于上例中的constructor，constructor 属性返回对创建此对象的数组函数的引用，语法object.constructor。例子如下：123456789101112131415161718var test=new Array();if (test.constructor==Array)&#123; document.write(&quot;This is an Array&quot;);&#125;if (test.constructor==Boolean)&#123; document.write(&quot;This is a Boolean&quot;);&#125;if (test.constructor==Date)&#123; document.write(&quot;This is a Date&quot;);&#125;if (test.constructor==String)&#123; document.write(&quot;This is a String&quot;);&#125; 使用constructor属性。1234567891011function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);document.write(bill.constructor);// function employee(name, job, born)// &#123;this.name = name; this.job = job; this.born = born;&#125; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。 1234if (x &lt; 0) &#123; throw new Error(&apos;x 必须为正数&apos;);&#125;// Uncaught ReferenceError: x is not defined 上面代码中，如果变量x小于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个Error实例。 throw也可以抛出自定义错误。1234567function UserError(message) &#123; this.message = message || &apos;默认信息&apos;; this.name = &apos;UserError&apos;;&#125;throw new UserError(&apos;出错了！&apos;);// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125; 上面代码中，throw抛出的是一个UserError实例。 实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。12345678910111213141516171819// 抛出一个字符串throw &apos;Error！&apos;;// Uncaught Error！// 抛出一个数值throw 42;// Uncaught 42// 抛出一个布尔值throw true;// Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return &apos;Error!&apos;; &#125;&#125;;// Uncaught &#123;toString: ƒ&#125; 对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try…catch 结构一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。 123456789try &#123; throw new Error(&apos;出错了!&apos;);&#125; catch (e) &#123; console.log(e.name + &quot;: &quot; + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... 上面代码中，try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。 catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去，可以避免程序崩溃。 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构，如下。123456789101112var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125;// Uncaught 100 为了捕捉不同类型的错误，catch代码块之中可以加入判断语句，如下。 12345678910try &#123; foo.bar();&#125; catch (e) &#123; if (e instanceof EvalError) &#123; console.log(e.name + &quot;: &quot; + e.message); &#125; else if (e instanceof RangeError) &#123; console.log(e.name + &quot;: &quot; + e.message); &#125; // ...&#125; finally 代码块try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。 123456789101112function cleansUp() &#123; try &#123; throw new Error(&apos;出错了……&apos;); console.log(&apos;此行不会执行&apos;); &#125; finally &#123; console.log(&apos;完成清理工作&apos;); &#125;&#125;cleansUp()// 完成清理工作// Error: 出错了…… 上面代码中，由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方，注意是执行完finally代码块以后。 12345678910111213function idle(x) &#123; try &#123; console.log(x); return &apos;result&apos;; &#125; finally &#123; console.log(&quot;FINALLY&quot;); &#125;&#125;idle(&apos;hello&apos;)// hello// FINALLY// &quot;result&quot; 上面代码说明，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。注意，只有在finally块执行完毕后，才会显示return语句的值。 下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。12345678910111213var count = 0;function countUp() &#123; try &#123; return count; &#125; finally &#123; count++; &#125;&#125;countUp()// 0count// 1 上面代码说明，return语句的count的值，是在finally代码块运行之前就获取了。 下面的例子充分反映了try...catch...finally这三者之间的执行顺序。123456789101112131415161718192021222324function f() &#123; try &#123; console.log(0); throw &apos;bug&apos;; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行&#125;var result = f();// 0// 1// 3result// false catch代码块之中，触发转入finally代码快的标志，不仅有return语句，还有throw语句。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime使用技巧]]></title>
    <url>%2F2018%2F04%2F20%2FSublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Sublime版本3的新特性 可以直接打开图片 Goto Anything 使用ctrl+p打开 可以在css文件内部使用@快速定位选择器 可以在js文件内部使用@快速定位函数 可以在html文件内部使用#快速查找 多行游标 产生多行游标的办法： 光标停留在一个词上按ctrl+d，再按ctrl+d就会选中下一个重复词，按ctrl+k再按ctrl+d可以跳过当前词再选择下一个词 光标停留在某一位置，按住shift按住鼠标右键拖动可以快速创建多行游标 选中某一个词，alt+f3可以全选这个词 命令模式 使用ctrl+shift+p打开命令模式 可以快速跳转页面 可以快速改变文档的识别格式，比如打开命令模式窗口，输入js，当前文档就会以JavaScript规则解析高亮 输入minimap，出现的选项可以隐藏/显示minimap emmet 文档开头输入一个!按ctrl+e即可生成html5的头，此时光标自动停留在title部分，使用ctrl+p goto anything来进行页面跳转，输入#body跳转到body处，然后按ctrl+enter快速在该行下方添加一行，就可以开始编辑html5代码了，这一过程无需鼠标操作 使用&gt;符号表示子元素，使用.指明class名称，使用$指明class名称中的数字序号 带缩进粘贴：ctrl+shift+v 当前行上方添加新行：ctrl+shift+enter 使用{}来指明标签内的内容，比如h2{this is title}会生成&lt;h2&gt;this is title&lt;/h2&gt; ctrl+e可以快速闭合标签 package control 可以通过pci在命令窗口中快速匹配package control : install package 安装主题： 可以去package control官网预览一些主题，在Labels——Theme下看 theme-soda theme-flatland theme-spacegray 可以在package control官网中的popular下查看比较流行的插件 snippet 在命令模式中输入snippet，选择function可以直接生成一个js函数，用tab键可以切换高亮，减少鼠标的使用 其实在编辑区中输入fun按回车使用sublime编辑器的自动补全完成这一过程 prototype快速使用原型链 document.getElementById等函数的输入，可以通过安装JavaScript snippet插件，然后输入ei按回车即可 还有很多snippet可以自己探索 advanceNewFile 使用ctrl+alt+N输入文件名或带路径的文件名快速创建文件，不存在的目录也会自动帮忙创建，这比用ctrl+n然后保存的方式要快的多 httpRequester 用于测试服务器端请求 get请求通过访问页面直接测试 post请求通过表单提交测试 使用了httpRequester插件之后，只需要编写一些注释，然后选中这段注释，按下ctrl+alt+R即可弹出一个新的tab页，内容即为运行是否成功等相关信息 nettus fetch 新建一个jQuery.js文件，然后在文件中使用命令模式中使用Fetch File命令，选择想要的文件按下enter，然后就会自动下载最新版本的jQuery side bar相关的插件 可以增强sublime的sidebar的功能，使用后可以直接在sublime中右键一个html文件在浏览器中打开 DocBlockr快速添加注释 可以自动补全注释块 如果是js文件，在一个函数的上方，输入/**，然后按tab键可以自动补齐一个函数的注释格式 使用lint进行语法及风格及校验 目前各个语言基本都有自己的lint系统，可以对语言的语法及风格进行检验 sublime linter是一个总体框架，如果想要针对某个语言需要在具体安装，比如针对js的需要再安装JSHint（JSLint的增强版） 在jshint的网站中可以查看所有可配置参数的说明，可以在工程文件中创建一个.jshintrc文件来配置自己想规定的规则]]></content>
      <categories>
        <category>开发工具使用</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andorid学习笔记]]></title>
    <url>%2F2018%2F04%2F17%2FAndorid%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2018%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本篇文章整理自《Linux系统概述》课堂笔记，会有一些与Linux无关的课外知识补充。考试重点在标题前用※标注，十分重要的点会标为彩色。Linux常用命令部分为避免符号混淆，不使用※标注重点，重点直接标为彩色，并且凡是该命令列出的选项均为常用或重点的选项。 基本概念整理操作系统的概念操作系统是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。 操作系统的基本功能包括存储管理、进程和处理及管理、文件管理、设备管理和用户接口服务。 操作系统的类型 批处理系统 分时系统：很普遍 实时系统：典型的实时系统如VxWorks 网络操作系统 分布式操作系统 Linux系统的特点 与Unix兼容 自由软件，源码公开 性能高，安全性强 便于定制和再开发 互操作性高 全面的多任务和真正的32位操作系统 Linux的常用版本 核心版本：主要是Linux的内核，由Linus等人不断开发和推出新的内核。内核版本号格式：x.y.zz-www，x为主版本号，y为次版本号，z为修订版本号。 发行版本：是各个公司推出的版本，与核心版是各自独立发展的，发行版是一些基于Linux核心的软件包。 Linux系统基础知识使用工具推荐虚拟机：VMware（本文使用）、Virtualbox（免费） 虚拟机使用注意事项： 同时开启的所有虚拟机占用内存不要超过真实内存的一半。 一般来讲，建立一个win7内存至少1G+，而建立一个Linux系统内存1G即可，有些版本的Linux系统可能500M+也可以。 但内存也不要过小，否则虚拟机的性能将十分低，导致运行速度过慢。 虚拟机的运行：虚拟机与真实设备共用外存和CPU，内存则划分一块真实内存来使用，硬盘实际上是一个硬盘文件。 系统镜像（*.iso）：红帽企业版、CentOS、debian、openSUSE等，本文均使用红帽企业版。 VMware常用功能 快照功能：虚拟机 —— 快照 —— 拍摄快照/快照管理器；用于记录当前配置环境，后续操作过程中如果出现错误可以随时还原；在快照管理器中右键点击 —— 转到快照，可以使系统还原到该快照； 克隆功能：虚拟机 —— 管理 —— 克隆；用于快速复制一个相同的虚拟机； VMware Tools的安装：虚拟机 —— 重新安装VMware Tools，则安装包会以虚拟光驱的形式出现在虚拟机中，是一个压缩包，使用命令将它解压到/tmp中，然后执行安装 VMware Tools的几个明显的功能：①屏幕自动调整；②可以在真机和虚拟机之间复制文件；③提高游戏性能，是对VMware的增强 虚拟机中系统的安装（VMware安装64位红帽企业版） 在VMware中选择创建新的虚拟机 —— 配置类型选择典型 —— 选择稍后安装操作系统 —— 选择Linux系统 —— 选择green Hat Enterprise版本（这里其实就是个名字，并没有什么实际影响） —— 指定存储路径 —— 指定磁盘容量使用默认配置即可，默认将虚拟磁盘拆分为多个文件即可 —— 选择自定义硬件做最后的调整 —— 完成 开机进行系统安装，开机前保证虚拟光驱中放入了系统镜像（.iso）文件 系统安装部分 选择Test this media &amp; install green Hat Enterprise Linux 7.4，然后根据系统提示安装即可 注意安装时选择带GUI的服务器，并勾选开发工具选项保证gcc可以使用 注意事项： 有些电脑主板不支持开启VT，这样的电脑不能使用64位虚拟机。 如果是安装服务器用的Linux，先不要选择中文，服务器是没有GUI的，因为真实终端刚安装好的时候看不到中文，会全部显示乱码，此时就没办法使用了。 服务器一般为了性能，是不会使用GUI的。 ※Linux系统中硬盘设备的命名规则Linux通过字母和数字的组合来标志硬盘分区。前两个字母表示分区所在的设备的类型，如hd表示IDE硬盘即并口硬盘，sd表示SCSI/SATA/USB硬盘即串口硬盘，第三个字母表示分区在哪个设备上，如hda表示第一块IDE硬盘，hdb表示第二块IDE硬盘，sdc表示第三块串口硬盘等；最后的数字表示分区的次序，如数字1~4表示主分区或扩展分区，而逻辑分区从5开始。如果没有对磁盘分区，则一律不加数字，表示整块磁盘。例：/dev/sda5其中，dev是Linux系统中硬盘设备文件所在的目录；sd表示为串口硬盘，相对的，hd表示为并口硬盘；a表示硬盘的顺序号；5表示分区的顺序号；综上所述，上述命名表示Linux系统中第一块串口硬盘的第5个分区。 ※Linux系统分区规则 默认必须有一个/即根分区，也就相当于Windows系统中的C盘； 默认必须有一个swap分区即交换空间，它用作虚拟内存，通常为内存的1-1.5倍大小甚至2倍。（补充：windows系统的虚拟内存为pagefile.sys，存储在C盘是个隐藏文件。虚拟内存防止所有内存空间突然全部用完的情况，虽然虚拟内存速度很慢，但可以预防紧急情况；还有一种情况是电脑突然待机，此时会把数据放到虚拟内存中） /boot分区是用于保证即使根分区出现问题也能启动计算机的，可以没有。 Linux中的主分区至少有1个，最多有4个（由于分区表大小限制）； 扩展分区可以没有，最多1个； 逻辑分区建立在扩展分区之下，可以有多个； 综上所述，主分区+扩展分区（逻辑分区1+逻辑分区2+…+逻辑分区n）=硬盘容量。 ※在Unix或Linux系统上实现GUI的机制——X WindowX Window模型如下图： Window系统上鼠标点击时是由被点击的应用程序直接获得鼠标点击事件，而Linux系统上则不然，Linux系统在点击后首先通知X Server服务器，X Server收到后，根据大概的位置推算出被点击的是哪个应用程序，再通过X协议告知该应用程序。因此，Windows系统的GUI比Linux稍快。 ※整个X Window由三个部分组成：X ServerX ClientX protocol:X Server与X Client之间的通信协议 其中X Server与X Client可以不在同一台机器上。在启动X Window时，首先启动X Server，然后启动X Client，最后建立通信。 ※Linux常用的文件系统Linux常用的文件系统有ext4、xfs、f2fs、zfs、btrfs补充： windows常用的文件系统有FAT32、NTFS、exFat ios常用的文件系统APFS Linux系统常见的压缩文件后缀 .tar.gz .bz2 .zip .gz .tar.bz2 ※Linux系统的分区表分区表有两种形式 MBR：最多支持4个主分区，或者3个主分区以及一个扩展分区，扩展分区下可以划分出若干个逻辑分区 GPT：支持几乎无限个分区数量，但Windows系统最多支持128个GPT分区 ※GNOME和KDE桌面 GNOME：用GTK、GTK+等应用程序开发包开发的；而GTK是用C语言开发的 KDE：用Qt库开发的，而Qt由c++开发。 一些名词 虚拟控制台 虚拟终端 控制台 命令行 终端 CLI(Commender Line Interface)这些在Linux系统上指代的都是同一样东西，也就是可以输入命令行的窗口或界面。放在Windows系统上来讲就是cmd。其中虚拟控制台和虚拟终端稍有特殊，它们指代的是图形用户界面中的命令行窗口。 Linux系统快捷操作 在Linux系统中使用ctrl+alt+Fn（n=1,2,3..n）来切换到第n个终端，也有些发行版采用快捷键alt+Fn ctrl+shift+t可以在终端窗口中新建标签 命令行快捷方式 输入一个很长的文件名时，可以先输入头几个字母，然后按tab键补全；系统补全操作会在出现其他可能的选择时停下来，此时要么再输入一位；要么再按tab键出现可能选择后，在对照着可能的选择中你要的那个文件名多输入一位，然后再按tab补全 ↑重复运行过的命令中的上一条命令，↓查找运行过的命令中的下一条命令 .bash_history记录之前输入的命令，默认为1000条。使用方法：按ctrl+R，命令提示符会变为(reverse-i-search)，此时输入的东西会去之前输入过的命令中匹配，找到后按回车键即可执行 ※Linux与Windows在命令行与GUI启动顺序上的差异 Linux是先启动命令行，在启动到黑底白字的终端界面后所有功能已经能够正常使用，GUI只是在Linux系统之上运行的一套应用程序，GUI上又提供了可以使用命令行的虚拟终端；（红帽企业版默认在第一个终端上运行GUI） Windows系统的GUI与系统内核是高度集成的，它首先启动GUI，命令行只是运行在GUI上的一个应用程序。 ※Linux系统中根目录下每个文件夹的作用 /bin ：即Binary（二进制）的缩写，用于存放一些命令文件 /sbin ：s代表super user，用于存放root用户专用的一些命令文件 /boot ：boot意为启动、引导，如果不为Linux系统单独建立一个分区则会生成一个boot文件夹，用于存放操作系统的内核以及启动时必需的文件 /dev ：device的缩写，用于存放一些硬件设备 /proc ：内存的映射，如果要修改内存中的数据就通过proc修改，因此备份系统的时候，proc文件夹是不需要备份的 /etc ：存放各种程序的配置文件，这个文件夹一般体积较小，但很重要 /lib(或/lib64) ：用于存放动态链接；相当于Windows系统中的dll文件，程序是以功能片段+共享库的形式运行的，Linux系统中这样的文件后缀名一般为.so或.a /lost+found ：系统的“失物招领处”，非法关机后这里会存有一些文件，一般不会用到，但数据恢复的时候可能会需要找这个文件夹中的文件 /mnt ：mount的缩写，即挂载。挂载操作都需要一个挂载点，Linux系统中的挂载点通常放在这个目录下 /root ：root用户的主目录/家目录，只能root用户自己查看和操作，普通用户没有权限 /home ：普通用户用来存放自己的数据，即普通用户的主目录/家目录。比如有一个名为stu的用户，则它的主目录为/home/stu /var ：放一些经常发生变化的文件，比如日志文件、缓存文件等 /tmp ：存放一些临时文件，重要的文件一定不要放在tmp文件夹里，因为这个文件夹要么定时自动清理，要么开机自动清理，重要文件放在这里容易丢失 /usr ：这个文件夹体积非常大，会放很多东西，比如应用程序的文件之类 /media ：作用同mnt文件夹，区别在于，mnt文件夹下一般存放手动挂载设备的挂载点，而media文件夹下一般存放自动挂载设备（如U盘、移动硬盘等）的挂载点 /opt ：option的缩写，意为“选择”，这个文件夹是一个可选的文件夹 为什么使用Linux命令行因为一般执行远程操作管理的时候都是进入文本环境，GUI会消耗很多不必要的流量；而且使用命令行对做技术支持的人来说十分便利 Linux系统的文件 Linux系统的文件名几乎可以有ASCII字符的任意组合构成，文件名最长可多达255个字符 Linux上可以有形式上的扩展名，扩展名有没有都可以；Linux是通过文件的头信息来识别文件类型的，扩展名在Linux系统上并不起作用，顶多可以由图形用户界面识别扩展名并显示对应的图标而已，再者是为了使文件在不同的文件系统中能够统一类型； Linux中的文件有三个时间信息： ctime：即create time，创建时间 mtime：即modify time，修改时间，对文件内容进行修改或者对文件附属数据进行修改时会更新这个值 atime：访问时间，使用touch命令可以更新这个值 很多配置文件只能root用户修改 Linux系统中的所有文件都有权限和主人 Linux系统的用户 用户注册信息存放在/etc/passwd文件中，编号1000之后的是用户创建的用户，1000之前的是系统默认创建的用户 Linux系统中要删除用户，实际上就是删除/etc/passwd中该用户的那一行信息，并删除/home/用户名这个用户主目录 一般来讲，Linux系统上的home文件夹会单独放在一个分区，就如同windows系统中的D、E、F盘那样，因为重装系统时会格式化根分区，Windows会格式化C盘，将home单独放在一个分区可以避免用户数据丢失 如果Linux的用户改名，主目录是不会改名的 Linux系统中的几种文件类型 普通文件 目录文件：即文件夹 设备文件 符号链接文件：分为软链接和硬链接 Linux系统中的路径 绝对路径，以根目录即/开头 相对路径，以目录名开头或以./开头，比如./etc/也就相当于etc/，代表当前目录下有个etc文件夹 Linux系统中的硬链接和软链接 硬链接：不可以跨分区 软链接：相当于windows系统中的快捷方式，可以跨分区，也称为符号链接 Linux系统常用命令※Shell提示符 root用户： # 其他用户： $ ※shell提示符前面字符串的含义[root@localhost home]# root代表当前登录的用户的用户名 localhost代表当前登录的主机名 home代表当前所在目录 # 是root用户的shell提示符 注意：命令行中输入密码时是没有回显的 Linux系统一般命令格式命令名 [选项] [参数]通常情况下选项是一个短横线加一个字母，如-a、-x、-b，这三个选项也可以略写为-axb；通常两个短横线之后跟一个完整的单词，如–all，则all是一个单词，是一个选项，而不是三个选项；通常来讲会是这样，但并不绝对。 命令名必须是小写的英文字母，并且往往是表示相应功能的英文单词或单词的缩写；命令名、选项和参数彼此间必须用空格或制表符隔开，不能连在一起，连续的空格会被shell解释为单个空格 who命令用于显示当前已注册到系统的所有用户名、所用终端名和注册到系统的时间。tty即为真实终端，是无图形用户界面的终端。pts指的是虚拟终端，是GUI中运行的终端窗口。who am i命令将列出使用该命令的当前用户的相关信息 用户退出登录 logout exit ctrl+P 发送消息 shutdown -k 不关机，只发送消息给所有用户 关机 halt shutdown -h （time可以写为now，代表立刻关机） 例：shutdown -h 11:00 &lt;message&gt; 在11点关机并发送消息message poweroff 注意：有的发行版只有root用户可以关机 重启 reboot shutdown -r ctrl+alt+del ctrl+alt+backspace —— 重启GUI init命令涉及到init命令，首先要了解几个运行级别 0 —— 表示关机 6 —— 表示重启则命令init 0即表示关机 clear命令用于清除屏幕上的信息，类似于dos中的cls命令。 passwd命令用于修改密码。root用户使用passwd 用户名可以不需要原密码就修改该用户的密码 pwd命令 用于显示当前工作路径，可以使用cd命令来切换工作路径 选项： -P 显示实际路径，即，如果路径中有链接文件，-P会将链接文件替换为真实文件 -L 显示逻辑路径 su命令 用于切换用户身份，用法su username，如果不加用户名则默认切换到root用户 root用户切换到普通用户不需要密码，但普通用户切换到root用户需要密码 不建议从root用户用su命令切换到其他用户，因为这样相当于root用户穿了普通用户的马甲，一旦退出无需密码直接退回到root用户，这样有可能会导致一定的安全问题；建议使用exit命令退出root用户同时退回普通用户 echo命令 用于将命令行中的参数回显到标准输出（即屏幕）上，如echo $PATH会显示环境变量PATH的值；而echo 字符串A会显示字符串A 选项： -n ：表示输出字符串String之后光标不换行 date命令 用于在屏幕上显示或设置系统的日期和时间 date显示的日期信息中，有一列CST意为China Standard Time，中国标准时间，即北京时间 date %y%m%d%H%M%S 可以显示年月日时分秒格式的日期 cal命令 用于显示日历，一般格式为 cal [选项] [[[day]month]year] 如：cal 2008会显示08年的日历，cal 03 2020会显示2020年3月的日历 file命令使用file 文件名可以查看文件的头信息 查找 find ：用于在硬盘中查找文件的位置，用法find 路径 -name *example，其中*example代表以example结尾的文件 locate ：用于查找文件的位置，但在文件量特别大的情况下速度比find快，因为locate有一个小型的数据库并建立了索引，所以查找很快，但最新生成的文件可能查找不到因为还没有加入索引中 grep ：用法grep 字符串 文件名，显示文件中包含该字符串的行，通常作为过滤器使用，如cat fstab | grep fs命令会将管道（即|）前面命令的输出作为管道后边命令的输入，前半部分命令用于输出文件全部内容，则fstab文件的所有内容作为后半部分命令的输入，最终得到fstab中包含fs的行 常用的文件操作命令 cat命令 用途：用于显示文件的所有内容；用于链接两个或多个文件 选项：-n，即–number，从1开始对所有输出行编号 举例： cat f1 f2&gt;f3会将f1和f2的内容合并起来，然后通过输出重定向符号&gt;的作用，将它们放入文件f3中。 more命令 用途：显示文件内容，每次显示一屏；按空格键显示下一屏，按enter键显示下一行内容；文件浏览完毕后自动退出；是一次性读取整个文件； less命令 用途：与more类似也用于显示文件内容，但是区别在于，less允许用户向前或向后浏览文件，而more命令只能向前浏览。less命令在开始显示之前，不必读入整个文件，是部分读取，适合用于大文件；用pageup键上翻页，用pagedown键向下翻页，退出可以按q或Q，或者:q，:Q，或者ZZ均可。 head命令 用途：用于在屏幕上显示指定文件的开头若干行，默认为前10行 用法：head [选项] [文件] 选项：-n，即–lines=N，显示指定文件的前面N行 tail命令 用途：用于在屏幕上显示指定文件的末尾部分 用法：tail [选项] [FILE] 选项： -f，当文件增长时输出附加的数据 -n，即–lines=N，输出最后的N行，而不是默认的10行 touch命令 用途：用于修改文件的时间标签（即更新文件的atime）或者创建一个空文件 用法：touch [选项] file，如果file不存在则新建一个文件；如果file已经存在则会更新文件的访问时间 file命令 用途：用于确定文件类型 用法：file [选项] 文件名 匹配、排序及显示指定内容的命令 grep命令 用途：用于在文本文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行 用法：grep [选项] 模式 [文件...] 选项：-i，即–ignore-case，匹配比较时不区分字母的大小写 sort命令 用途：用于对文本文件的各行进行排序 用法：sort [选项] [文件] uniq命令 用途：用于从排好序的文件中去除重复行，需要注意的一点是，uniq比较的是相邻的行 用法：` uniq [选项] [输入文件[输出文件]] ※文件压缩命令 Linux常见的压缩格式 filename.tar.gz（最普通） filename.tar.bz2 filename.tar.xz（最常用） .zip（通用，zip压缩包在各个系统上均可使用） filename.tar.gz 压缩：tar zcvf filename.tar.gz some_file_dirs 解压：tar zxvf filename.tar.gz (-c /路径) 解释：z选项指定了用于gz包；c选项和x选项分别指定了压缩和解压；v选项指定了需要显示详细信息，这个选项可以省略；f选项指明文件；解压命令中的-C选项可以指明解压到指定路径 filename.tar.bz2 压缩：tar jcvf filename.tar.bz2 some_file_dirs 解压：tar jxvf filename.tar.bz2 filename.tar.xz 压缩：tar Jcvf filename.tar.xz some_file_dirs 解压：tar Jxvf filename.tar.xz filename.zip 解压：unzip filename.zip 一点知识补充，其实现在微软的无论docx还是pptx格式的文件，只要这些后缀名带x的，实际上就是zip文件，是可以解压的 比较文件内容的命令 comm命令（一般不用，一般会用vimdiff） 用途：用于对两个已经排序的文件进行逐行比较 用法：comm [选项] 文件1 文件2 diff命令 用途：用来比较两个文本文件，并找出他们的不同 用法：diff [选项] 文件1 文件2 注：diff命令会生成一个patch文件，这个文件保存了两者之间的不同，相当于补丁的作用 复制、删除和移动文件的命令 ※cp命令 用途：用于将源文件或目录复制到目标文件或目录中 用法：cp [选项] 源文件或目录 目标文件或目录 选项： -v，显示拷贝的详细过程，如果不用-v则只有光标在闪烁 -R，-r，递归复制目录，即将源目录下的所有文件及其各级子目录都复制到目标位置，此时目标文件必须为一个目录名 特例： cp 目录 不存在的文件的文件名会将前边的目录复制为一个新文件夹，命名为后边的文件名 cp -r dir newdir，如果dir已经存在，会将dir放到newdir中；如果newdir不存在，会将dir复制为newdir rm命令 用途：用于删除文件或目录 用法：rm [选项] [文件] 选项： -f，即–force，忽略不存在的文件，并且不给出提示信息；但是如果是普通用户删除文件，如果没有删除某个文件的权限，那么即使加了-f也是删不掉的 -r，-R，即-recursive，递归地删除指定目录及其下属的各级子目录和相应的文件 -i，交互式地删除文件，即删除文件之前会给出提示并需要用户逐个确认，与-f相反 mv命令 用途：①对文件或目录重新命名②将文件从一个目录移动到另一个目录中 用法：mv [选项] 源文件 目标文件 解释：如果目标文件与源文件路径不同，则是移动操作；如果路径相同，就相当于是重命名操作 文件内容统计命令 wc命令 用途：用于统计指定文件的字节数、字数、行数，并将统计结果显示出来 用法：wc [选项] [文件] 选项： -c，即–bytes，统计字节数 -l，即–lines，统计行数 -m，即–chars，统计字符数 -w，即–words，统计字数 常用的目录操作命令 mkdir命令 用途：用来创建目录 用法：mkdir [选项] dirname 选项：-p，即–parents，可以一次建立多个目录，即如果为新建目录所指定的路径dirname中有些父目录尚不存在，此选项可以自动创建它们 如果要创建一个名字中带空格的文件夹，则使用mkdir &quot;a b&quot;或者mkdir a\ b rmdir命令 用途：可以从一个目录中删除一个或多个空的子目录 用法：rmdir [选项] dirname 改变工作目录和显示目录内容 cd命令 用途：用于改变工作目录 用法：cd [dirname] 几种用法： cd /绝对路径 ：cd命令可以跟一个绝对路径 cd ./相对路径 ：cd命令也可以跟一个相对路径 cd ：cd后什么都不加或者加一个空格，代表将工作目录改为用户主目录 cd ~ ：同上，代表跳回用户主目录 cd .. ：跳回上级目录，..代表上级目录 cd . ：跳回当前目录，其实相当于原地踏步。.代表当前目录 cd - ：后退一步，连续使用则会在两个工作目录之间来回跳转 关于路径的注意点：根目录的.和..是一样的；绝对路径一定是以根目录也就是/开头的 ※ls命令 用途：列出指定目录的内容 用法：ls [选项] [file] 选项： -a，即–all，显示指定目录下所有子目录和文件，包括以.开头的隐藏文件，包括.和.. -d，如果参数是目录，则只显示它的名字（不显示其内容）；往往与-l选项一起使用，以得到该目录本身的详细信息 -h，一般结合-l选项使用，使文件大小字段带有一个最合适的单位方便用户查看 -l，以长格式显示文件的详细信息，输出的信息分成多列，它们依次是：文件类型与权限 链接数 文件主 文件组 文件大小 建立或最近修改的时间 文件名，其中，链接数指的是硬链接数，文件组显示的是主组的名称，即文件所属的用户属于哪个组 例如：-rw-r–r– 2 mengqc group 809 12月 27 2008 myfile2 综上所述，ls -lha是一个很常用的命令，用于显示某个目录中所有文件的带单位的详细信息；并且，ls -l这个命令可以简写为ll ※关于ls命令中的10个表示文件类型与权限的字符头一个字符代表了文件类型，所用字符及含义如下： - 普通文件 d 即dir，目录文件 b 即block，块设备文件，一般是指能存储数据的，比如硬盘 c 即char，字符设备文件，一般是能够显示字符的，比如打印机和屏幕 l 即link，符号链接文件，也就是软链接 s 套接字文件（socket），一般网络编程会用到 p 命名管道文件（pipe），管道即”|” 随后的九个字符分为三组，每组3个字符，分别代表了三组权限：第一组代表文件所有者的读、写、执行权限；第二组表示同组用户的读、写、执行权限；第三组表示其他用户的读、写、执行权限，在权限部分会有详细讲解，其中 r 即read，读 w 即write，写 x 即execute，执行，对于目录文件则表示该目录可以访问 - 代表没有对应的权限 s 不常见 t 不常见 权限字段的组合中，rwxrwxrwx的限制是最少的，但是Linux系统中一般不会设置成这样 ln命令 用途：用来创建链接 用法：ln [选项] 源文件 [目标文件] 选项：-s，即–symbolic，建立符号链接而不是硬链接，如果要创建硬链接就不加-s 改变文件或目录存取权限的命令 chmod命令 用途：即change mode，用于改变或设置文件或目录的存取权限，但是只有文件主或超级用户root才有权用chmod命令改变文件或目录的存取权限 用法：改变文件权限有两种方法：文字设定法、数字设定法（常用） 文字设定法： 用法：chmod [who] [+|-|=] [mode] filename 例如：chmod o + r file.txt是为其他用户增加file.txt文件的读权限 操作对象who可以取的值有： u，表示“用户（user）”，即文件或目录的所有者； g，表示“同组（group）用户”，即与文件属主有相同组ID的所有用户； o，表示“其他（others）用户”； a，表示“所有（all）用户”，它是系统默认值 操作符号可以是： +，即添加某个权限； -，即取消某个权限； =，即赋予给定权限并取消其他所有权限（如果有的话）； mode所表示的权限可以是下述字母的任意组合： r，可读； w，可写； x，可执行（或可搜索目录）； X，只有该目标文件是目录文件或对某些用户有可执行权限时，才有“可执行/搜索”属性 s，在文件执行时，把进程的属主或组ID置为该文件的文件属主。方式u+s设置文件的用户ID位，g+s设置组ID位 t，受限删除标志或粘着位，即程序的文本保存到交换设备上 u，与文件属主拥有一样的权限； g，与和文件属主同组的用户拥有一样的权限； o，与其他用户拥有一样的权限； 课外知识补充计算机概括来讲可以分为几个部分硬件、软件、固件。软件分为几类：系统软件、支撑软件、应用软件。固件是安装在硬件（比如主板内）上的软件，它引导操作系统的运行。它可以完成比如开机时显示厂商的界面和设置启动顺序等的界面等。 计算机的几种状态关机；休眠：windows将内存中的文件生成镜像文件存放在一个.sys文件中；Linux系统将内存中的文件生成镜像放入交换空间中，如果交换空间大小小于内存的大小，则不支持这种模式；休眠后执行关机操作，再开机时会直接读取镜像。睡眠：可唤醒的状态。 BIOSBIOS即Basic Input Output System，基本输入输出系统。BIOS负责在系统通电时进行自检并且找到引导程序grub，grub再去硬盘上找到系统内核kernel。tips：为什么引导程序普遍使用grub而不使用Lilo：因为Lilo要求内核必须放在硬盘的1024柱前面。 区别内存与外存最直接的方法断电后数据丢失的就是内存，而断电后数据仍旧可以保存的则是外存。用这种方法可以明显得知，现在普遍流传的“手机内存”的叫法其实是错误的。 安装多系统时的安装顺序低版本→高版本，Windows→Linux。而lilo（或grub）负责多系统的引导，应当最后安装到MBR（分区表）中。 关于文件系统ISO9660 —— 光盘文件系统，其中除了存储的数据之外还有其他信息，夹带了这些信息可以用于防盗版，因为这样软件只能通过光盘安装，单纯的复制文件光盘中的内容是无法安装的。而.iso文件就相当于虚拟光盘，需要虚拟光驱来运行。FAT32 —— 此种文件系统不支持超过4G的文件，常应用在手机存储卡，win98，U盘等。NTFS —— 即NT FIle System（NT文件系统），是windows系统常用的文件系统。 windows系统相关 windows系统的内核：windows NT windows使用的文件系统：NTFS也就是NT File System Linux系统版本 Fedora是红帽9.0后可以免费使用的发行版，而rhel是9.0后为企业准备的发行版。 Android内核使用的是Linux系统 系统调用是操作系统内核与用户程序、应用程序之间的接口。在Unix/Linux系统上，系统调用以C函数的形式出现，比如用于打开一个文件的open函数。结构如下图： 服务器的内存泄漏指服务器上运行的软件不释放内存，因为服务器上运行的软件都是不经常关闭的，最后程序占用的内存会越来越大，导致内存泄漏。 其他 1752年9月没有3号-13号]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目架构学习]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[好的前端工程师和架构师一定是对数据非常敏感的，通过数据可以为用户提供更好的体验。 好的目录组织是一个好的架构的开始。每个目录要做什么事情一定要让它职责分明。除了目录组织的架构之外还有页面组织的架构。views中存放的都是视图代码，views中除了放一些页面之外，还可以将页面都共有的部分放到views/includes文件夹中，然后在其他页面中引入这些视图文件。视图页面一般不会有太复杂的逻辑关系，基本只有包含与被包含的关系，因此include中只需要平行摆放这些组件即可。当然，如果你的项目十分庞大，比如一个登录模块就有几十种，那么可以再使用文件夹来区分他们。 更高级一些的架构设计则包含了组件化和设计模式。这方面主要针对js代码，因为html和css的逻辑性并不是很强。Js中的继承和Extend是Js抽象的基础，因为js不像其他面向对象语言一样与生俱来这些功能。 Extend比如浅拷贝（适用于基本数据类型），深拷贝（使用于引用数据类型）。浅拷贝与深拷贝其实就是一个抽象出来的extend函数，使子元素具有父元素的属性。对于基本数据类型来说，就是循环复制父元素中的元素。 js中的继承，一特有的方式就是原型链继承。 划分命名空间，前端模块拆分的最基本的形式可以认为是闭包的一种应用，但是这种方式对于命名空间的管理过于随意。闭包有一个问题就是在闭包内声明的变量会常驻在内存中，因此要避免在闭包内声明过于大的变量。其实在实际项目中不会大规模的使用js的继承和扩展，一是因为项目逻辑一般不会那么复杂，二是因为一些类库为我们提供了便利，比如jQuery就提供了一个封装好的extend方法。 常用的是组件化，比如一个弹出窗口可以做成一个组件。我们可以使用开源框架来完成最终的组件的组织和管理，例如requirejs/seajs，这两个框架遵循了两种规范，一个是cmd规范，一个是amd规范，cmd指明模块是按需加载的，即依赖就近；amd则是依赖关系前置，即使用一个依赖于a,b,c三个模块的组件时，如果使用这个组件会先加载这三个模块，不管这三个模块在组件初始化的过程中用没用到。 模块化框架基本只用到两个方法，一个是define，也就是定义一个模块；一个是require，也就是使用一个模块。 前端工程师拿到交互图时应该已经能大致想到整个网站的架子是什么样的，一定要统观全局一定要考虑有哪些部分是公用的，考虑一下如何抽象出来，也就是组件化开发。 当设计图出炉后，应该考虑到api的对接，虽然不能做到百分百精确，但要有一个大概的规划要明确哪部分是静态的，哪部分是动态的，并与后台负责人员进行讨论。 通常来讲首页的性能会影响到用户的留存率，因此首页一定要认真考虑性能方面的问题。前端项目目录结构创建一个静态目录，其中包括一个css文件夹，一个js文件夹。css文件夹中可以有module文件夹，其中的css文件用于组件，如dialog.js；可以有include文件夹，其中的css用于页面公用部分，如header.css，footer.css等；可以有一个release目录，用于打包之后的文件存放在这里；css文件夹下可以有一个package.json文件来书写打包规则。script文件夹中可以存放页面的js文件，比如common.js；可以有一个widget目录，其中存放一些组件的js；可以有一个release目录，用于打包之后发布在这里；script文件夹下可以有一个package.json文件来书写打包规则。图片文件分两种情况，一种是网站上的静态图片，可以在css文件夹下面创建一个img文件夹，用于存放这些静态图片，但是不要存放太多否则会影响性能；另一种是动态读取的图片，通常是放到服务器上的。 开发实现流程规范 切图 从页面结构上来考虑，把页面中的公用部分抽象出来 从css文件上来考虑，抽象出一些公用的css，比如reset.css等 可以使用地址来访问css文件 如果前端工程要抽象出模板，那么可以有一套模板对开发者友好，有一套模板对用户友好，对用户友好的模板就可以通过自动化工具打包生成 模板用一个更简洁的形式把页面组装出来展示给用户]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基础学习笔记]]></title>
    <url>%2F2018%2F04%2F14%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础less只是一种方便程序员编写的工具，最终引用的还是css文件。可以使用软件koala进行编译，也可以使用一些IDE设置进行自动编译。 Less中的注释CSS提供 /*这个注释在Less被编译为css文件的时候会被编译*/形式的注释，而LESS又多提供了一种//这种注释不会被编译注释。 Less中的变量Less中使用@开头来声明变量，如@test_width:300px;调用时：123.box&#123; width:@test_width&#125; Less中的混合混合也就是可以将声明的一个class直接放到另一个class内部。1234567.box&#123; width:@test_width; .border;&#125;.border&#123; border:solid 5px pink;&#125; 会被编译为1234.box&#123; width:@test_width; border:solid 5px pink;&#125; 混合是可以带参数的。123456.border_02(@border_width)&#123; border: solid yellow @border_width;&#125;.test_hunhe&#123; .border_02(30px);&#125; 会被编译为123.test_hunhe&#123; border:solid #ffff00 30px;&#125; 混合的参数是可以有默认值的。123456.border_03(@border_width: 10px)&#123; border: solid gr een @border_width;&#125;.test_hunhe_03&#123; .border_03();//这里使用10px的默认值，如果要变动传一个新值即可，这个括号不能丢&#125; 混合很常用的一个地方就是在边框圆角，我们知道css设置border_radius是需要兼容的。因此可以像下面这样使用：12345678910.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 40px; .border_radius(10px);//默认是5px但这里不使用默认值改为10px&#125; 这样，每次只要调用一下border_radius并传入参数即可。 Less中的匹配模式使用CSS写三角：12345678.sanjiao&#123; width: 0; height: 0; overflow: hidden; border-width: 10px; border-color: transparent transparent red transparent;/*是个向上的三角*/ border-style: dashed dashed solid dashed; /*其实只写一个solid即可，但ie6上solid会显示出一个黑色的正方形，因此指定一个边为solid，另外均为dashed即可*/&#125; 使用匹配模式写三角：1234567891011.triangle(top,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: transparent transparent red transparent; border-style: dashed dashed solid dashed;&#125;.triangle(bottom,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: red transparent transparent transparent; border-style: solid dashed dashed dashed;&#125; 此时使用123.sanjiao&#123; .triangle(top);/*这样即可指定画出向上的三角，即第一个triangle*/&#125; 匹配模式中还提供了一个方法，可以指定所有参与匹配模式的样式共同的部分：123456.triangle(@_,@width:5px,@color:#ccc)&#123;/*后边的不可以省略*/ width: 0; height: 0; overflow: hidden;&#125;//不管匹配到谁，这段代码都会被编译出来 匹配模式用于定位：12345678910111213.pos(r)&#123; position: relative;&#125;.pos(a)&#123; position: absolute;&#125;.pos(f)&#123; position: fixed;&#125;.test&#123; width: 200px; .pos(a);&#125; 其实这样匹配模式看来有些类似于Java中的多态。 Less中的运算比如123456@test_01: 300px;.box_01&#123; width: (@test_01 + 20) * 5;//因为@test_01带有了单位px，因此后边的20和5可以不需要带单位。&#125;//Less规定一个式子中只要有一个数字带了单位，其他的数字便会自动转化。 Less中的颜色也是可以加减的，但一般不会用到。 Less中的嵌套比如有下面这样的一段html代码1234567&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 如果是平时写css，可能会用以下方式来规定样式：1234.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125; 但如果使用了Less中的嵌套，就会变成下面这样：12345678910111213.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125;&#125; 此时a的样式可以写在两个位置，第一种写法是a被li包裹在里面，和html结构完全一致：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; a&#123; float:left; &#125; &#125;&#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list li a &#123; float:left;&#125; 第二种写法是a与li同级：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125; a&#123; float:left; &#125; &#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list a &#123; float:left;&#125; 因为.list li a的匹配次数会多于.list a，因此我们提倡将a写为与li同级。 关于嵌套还有一个例子，就是css中常见的a:hover，原本的写法是：12.list a&#123;&#125;.list a:hover&#123;&#125; 现在可以写为：12345678910.list &#123; ... a &#123; ... &amp;:hover&#123; color:red; &#125; &#125;&#125; &amp;符号代表的是上一层的选择器，在这个例子中指代的就是a如果html结构上有两个class是互相嵌套的，比如外层调用class为title，内层调用的class为title_nav，则可以在嵌套中使用&amp;_nav来代表title_nav。 Less中的@arguments变量@arguments变量用的其实不是特别特别多，它包含了所有传递进来的参数，如果不想单独处理每个参数的时候就可以这样写。比如：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg();&#125; 此时arguments会自动匹配所有参数，也就会编译成：123.test_arguments&#123; border: 30px #ff0000 solid;&#125; 如果稍加修改：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg(40px);&#125; 则此时arguments也会自动执行对应的更改，即会编译成：123.test_arguments&#123; border: 40px #ff0000 solid;&#125; 这就是arguments，如果一个属性的值全部都要改动的时候可以这样使用。 Less的避免编译有时候我们需要输出一些不正确的CSS语法或者使用一个Less不认识的专有语法，要输出这样的值我们可以在字符串前面加上一个~。比如CSS3中的滤镜，calc函数等都可能遇到这种情况，示例如下：123.test_03&#123; width: calc(300px - 30px);&#125; 此时会直接编译成：123.test_03&#123; width: calc(270px);&#125; 这种情况就是，我们本意是想要浏览器来计算这个值的，可是现在被Less直接计算了，此时就可以使用避免编译，让Less不要进行计算，留给浏览器计算。代码如下：123.test_03&#123; width: ~&apos;calc(300px - 30px)&apos;;//单引号双引号都行&#125; 此时会编译为：123.test_03&#123; width: calc(300px - 30px);&#125; 一般用于CSS3中的calc或滤镜，避免软件出现一些不必要的错误，或者执行一些不必要的运算。 !important关键字css中的important是让样式的优先级最高。Less中的混合模式实际上也可以加important关键字。比如之前写过的border_radius，我们可以为它加上important关键字：12345678.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.test_important&#123; .border_radius()!important;&#125; 这样可以编译为：12345.test_important&#123; -webkit-border-radius: 5px !important; -moz-border-radius: 5px !important; border-radius: 5px !important;&#125; 这个可以在调试的时候使用，一般是不要用important关键字比较好。 Less中的导入使用@import &quot;less&quot;会导入less.less文件，可以用加拓展名使用@import (less) &quot;a.css&quot;会导入a.css文件的样式，注意导入css的时候这句import写在哪，编译的时候a.css中的样式就会出现在哪，因此如果要让它在最前面就要把import写在最前面。如果写成@import &quot;a.css&quot;，则less不会将里面的样式内容拿出来，编译为css文件的时候会编译为一个导入的css即css文件中的@import &quot;a.css&quot;。因此需要使用(less)对它进行转换。 其他小知识点补充 如果子元素浮动，父元素必须清楚浮动才能有高度，否则父元素高度为零。一定要注意！ 使用CSS父元素清除浮动： 12345678.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; 这样再在父元素上调用clearfix类即可。 如果是在Less中，则代码如下： 12345678.clearfix&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix; 这种写法编译css文件的时候会吧clearfix编译出来，如果不想这样做可以写成以下方式： 12345678.clearfix()&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix();，其实父元素加不加括号都可以，这样做只是为了能够方便区分这里到底是个混合还是单纯引入了一个css。 兼容IE6的清除浏览器自带样式的方式： 1234*&#123;margin:0;padding:0;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration: none;&#125;img&#123;border:none;&#125;//因为ie6下图片默认是有边框的 使用less还可以将浮动写为： 12345678.fl(@fl:left)&#123; float: @fl; display: inline;&#125;.fr(@fr:right)&#123; float: @fr; display: inline;&#125; 调用时使用.fl()或.fr()调用即可]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F14%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础操作部分初始化git init 将修改提交到暂存区git add tips：使用git add .可以将当前工作区中的所有存在修改的文件一次性全部提交到暂存区 将暂存区提交到版本库git commit -m “commit message” 跳过暂存区，直接把工作区的修改提交到版本库git commit -a -m “commit message” 查看工作区状态git status 查看工作区修改内容，也就是查看工作区与暂存区的区别git diff 恢复到指定id的版本git reset -hard 查看提交历史git log 查看格式化后的提交历史git log –pretty=oneline 可以查看所有分支的所有操作记录（包括提交、回退、已删除的提交操作记录等）git reflog 查看工作区和版本库里面最新版本的区别git diff HEAD –reaadme.txt 切换分支或恢复工作树文件git checkout 切换到一个指定分支： git checkout 分支名称 创建并切换到新的分支中： git checkout -b 分支名称 撤销修改： git checkout – 一种情况是文件修改后还没有放到暂存区，此时撤销修改也就是回到了版本库中的状态。即，上一次git commit后，修改了文件，但没有执行git add，回到上一次git commit时的状态。 第二种情况是文件已经添加到了暂存区，又做了修改，此时撤销修改就回到了添加到暂存区时的状态。即，修改了文件，并且执行了git add，然后又修改了文件，此时会撤销到git add时的状态。 撤销暂存区的修改，但不修改工作区git reset HEAD 从版本库中删除文件git rm 远程仓库部分创建SSH Keyssh -keygen -t rsa -C “email@mail.com“ 创建与远程仓库的关联git remote add origin git@github.com:Fnine59/project_name.git tips: origin是远程仓库的名字 把本地库的所有内容都推送到远程库git push -u origin master tips: 第一次推送master分支时加上-u参数，则不仅会将本地的master分支推送到远程仓库中的master分支，还会将它们相互关联起来，这样以后推送或拉取时就可以简化命令了。 从远程仓库克隆项目git clone git@github.com:Fnine59/project_name.git (SSH协议形式) git clone https://github.com/Fnine59/project_name.git (HTTP协议形式) 从远程仓库拉取数据git fetch 查看远程仓库信息git remote git remote -v (查看远程库的详细信息) git remote show (更详细一些) 远程仓库重命名git remote rename 分支操作部分分支操作规范1234567master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 创建并切换到example分支git checkout -b 查看分支git branch 创建example分支git branch 切换到example分支 git checkout 合并指定分支到当前分支git merge 删除example分支git branch -d 查看分支的合并情况git log –graph –pretty=oneline -abbrev -commit 查看分支合并图git log –graph 采用普通模式合并指定分支到当前分支git merge –no-ff -m “使用普通模式合并分支” 本地分支操作部分保存工作区现场，操作完其他后可以恢复工作区继续工作git stash 恢复保存的工作区现场，但是恢复后不删除stash内容git stash apply 删除保存的工作区现场git stash drop 恢复保存的工作区现场，同时删除stash内容git stash pop 强行删除分支git branch -D 远程分支操作部分将master分支推送到远程库对应的远程分支git push origin master 从远程仓库抓取分支git pull 建立本地example分支和远程example分支的关联git branch –set -upstream origin/ 标签操作部分新建标签git tag 根据提交的id创建带说明的标签git tag -a -m “tag message” commit id 查看所有标签git tag 查看的标签信息git show 推送一个本地标签到远程仓库中git push origin 推送本地所有未推送过的标签到远程git push origin –tags 删除标签git tag -d 删除远程标签git push originn :refs/tags/ 文件恢复从暂存区恢复文件到工作区可以使用 git checkout . 或 git checkout --&lt;file&gt;命令 从版本库恢复文件到工作区和暂存区使用 git checkout HEAD . 或 git checkout HEAD &lt;file&gt;命令，会从HEAD指向的master分支中的全部或部分文件来替换暂存区以及工作区中的文件 从版本库恢复提交到暂存区git reset –soft 从版本库恢复提交到暂存区和工作区，等同于checkout HEAD .git reset –hard]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%85%B3%E4%BA%8EJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Class类的使用Java中其实有两种东西不是对象，一个是普通的数据类型（但有包装类来弥补了），另一个是Java中静态的成员。Java中的类其实也是对象，它是java.lang.Class类的实例对象。 既然任何一个类都是Class类的实例对象，那么Class类的实例对象应该如何表示呢？ 通过查看Class类的源代码可以知道，它具有一个私有的构造方法，在类的外部无法直接调用。因此我们无法使用new关键字来直接表示Class类的实例对象。 现假设有一个类名为Foo的类，并且通过new关键字实例化了一个Foo类的对象foo1，现有三种表示方式来表示这个Class类的实例对象Foo： * `Class c1 = Foo.class;` 这种表示方式实际在告诉我们任何一个类都有一个隐含的静态成员变量class。 * `Class c2 = foo1.getClass();` 已经知道该类的对象，通过getClass方法获取 * `Class c3 = null; c3 = Class.forName(&quot;com.fnine59.reflect.Foo);` * 根据官网的解释，**c1，c2表示了Foo类的类类型（class type）**，证明万事万物皆对象，类也是对象，是Class类的实例对象，这个对象我们称为该类的类类型。 * **不管用c1，c2或c3哪种表达方式都表示了Foo类的类类型，它们是相等的，因为一个类只能是Class类的一个实例对象。** 我们完全可以通过类的类类型来创建该类的对象实例，即通过c1或c2或c3来创建Foo类的实例。可以使用Foo foo = (Foo)c1.newInstance();来创建Foo类的实例。这种办法需要该类有无参的构造方法。 Java动态加载类编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（DOM篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88DOM%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建节点与属性处理 $(&quot;html结构&quot;)可以创建出来，例如$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)，如果要指定属性，则$(&quot;&lt;div id=&#39;test&#39; class=&#39;aaron&#39;&gt;我是文本节点&lt;/div&gt;&quot;)即可。 DOM内部插入append()与appendTo() .append(content)向每个匹配id元素内部追加内容 .appendTo(content)把所有匹配的元素追加到另一个指定的元素集合中 这个方法可以使得创建的新节点显示在文档中，将新创建的元素当作页面某一个元素的子元素放到其内部即可。 append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。 appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。 区别：append()前面是被插入的对象，后面是要在对象内插入的元素内容；appendTo()前面是要插入的元素内容，而后面是被插入的对象 DOM内部插入prepend()与prependTo() .prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素。 .prependTo()方法把所有匹配的元素前置到另一个指定的元素集合中。 DOM外部插入after()与before() 内部插入着重于节点之间的父子、祖辈关系；而外部插入着眼于节点之间的兄弟关系。 .after(content)方法在匹配元素集合中的每个元素后插入参数指定的内容，作为其兄弟节点。 .before(content)方法按参数设定，在匹配元素的前面插入内容。 DOM外部插入insertAfter()与insertBefore() .insertBefore()方法在目标元素前面插入集合中每个匹配的元素 .insertAfter()方法在目标元素后面插入集合中每个匹配的元素 注意：after和before方法都是将要插入的内容作为参数，而insertBefore和insertAfter方法则相反，要插入的内容在方法前面。 删除节点 empty() empty方法用于清除指定元素中的所有子节点 remove() remove方法与empty方法一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 remove方法可以传参，比如$(&quot;p&quot;).remove(&quot;:contains(&#39;3&#39;)&quot;)，意思是找到所有p元素中，包含了3的元素，这个也是一个过滤器的处理。可以通过类似于$(&quot;p&quot;).filter(&quot;:contains(&#39;3&#39;)&quot;).remove()的方式进行处理。 detach() 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理。 可以使用一个变量接收detach方法的返回值，当执行完detach方法后会移除对象，但仅仅是显示效果没有了，在内存中还是存在的，可以使用append(刚才接收返回值的变量)将元素重新放回文档流中。这时可以发现该元素绑定的事件仍然生效。 DOM拷贝clone() clone方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 注意：如果节点有事件或者数据之类的其他处理，我们需要通过clone(true)传递一个布尔值true用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。 clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色。 DOM替换replaceWith()和replaceAll() .replaceWith(newContent)用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。 .replaceAll(target)用集合的匹配元素替换每个目标元素。 注意：这两个方法都会删除与节点相关联的所有数据和事件处理程序。 DOM包裹 wrap()方法 .wrap(wrappingElement)在集合中匹配的每个元素周围包裹一个HTML结构 .wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。使用后的效果与直接传递参数是一样的，只不过可以把代码写在函数体内部，写法不同而已。 unwrap()方法 这个方法与wrap的方法是相反的，将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在的话）在原来的位置。 wrapALl()方法 .wrapAll(wrappingElement)：给集合中匹配的元素增加一个外面包裹的HTML结构。 这个方法同样有.wrapALl(function)的写法，通过回调的方式可以单独处理每一个元素，等同于wrap的处理。 wrapInner()方法 .wrapInner(wrappingElement)：给集合中匹配的元素的内部增加包裹的HTML结构。 例子： 12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 给所有元素增加一个p包裹 1$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;) 最后的结构 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 此方法也有.wrapInner( function )的写法，允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行并返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。效果等同于第一种处理。 jQuery的遍历 children()方法 用于快速查找元素合集里面的第一级子元素。由于jQuery是一个合集对象，所以通过children是匹配合集中每一个元素的第一级子元素。同时也因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，因此允许传一个选择器的表达式。比如$(&#39;.div&#39;).children(&#39;:last&#39;)。 find()方法 find是遍历当前元素集合中每个元素的后代，不仅是儿子，祖孙辈也可以。 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 *。 find只在后代中遍历，不包括自己。 parent()方法 用于快速查找合集里面每一个元素的父元素。 jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素。同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 parents()方法 用于快速查找合集里面每一个元素的所有祖辈元素。 也有无参或带参两种使用方法。 closest()方法 该方法从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。closest()方法接受一个匹配元素的选择器字符串。 与parents方法类似，但还是有些区别： 起始位置不同：.closest开始于当前元素 .parents开始于父元素 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 next()方法 用于快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合。 next()无参数：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素。 next()方法选择性地接受同一类型选择器表达式： 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 prev()方法 用于快速查找合集里面每一个元素紧邻的前面同辈元素的元素集合。 prev方法也有无参和有参两种用法。 siblings()方法 用于快速查找指定元素集合中每一个元素的同辈元素 此方法也有也有无参和有参两种用法。 add()方法 用来创建一个新的jQuery对象，元素添加到匹配的元素集合中。 each()方法 .each()方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始计数）。 例子： 1234&lt;ul&gt; &lt;li&gt;慕课网&lt;/li&gt; &lt;li&gt;Aaron&lt;/li&gt;&lt;/ul&gt; 以上是结构，现在开始迭代li，循环2次···$(“li”).each(function(index, element) { //index 索引 0,1 //element是对应的li节点 li,li //this 指向的是li //如果需要提前退出，可以以通过返回 false以便在回调函数内中止循})`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（基础篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[jQuery版本进入官方网站获取最新的版本http://jquery.com/download/，这里需要注意 jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于 2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。由于减少了一些代码，使得该版本比 jQuery 1.x 更小、更快。 $(document).ready 等页面的文档(document)中的节点都加载完毕后，再执行后续代码。 jQuery对象和DOM对象的转换 jQuery-&gt;DOM：jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。可以利用数组下标的方式读取到jQuery中的DOM对象。 DOM-&gt;jQuery：如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象。通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了。 选择器 id选择器 语法：$( &quot;#id&quot; ) 注意：id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的。 类选择器 语法：$( &quot;.class&quot; ) 元素选择器（根据给定的标记名称选择所有的元素） 语法：$( &quot;element&quot; ) 全选择器 语法$( &quot;*&quot; ) 层级选择器 &gt; （大于号）紧跟父子关系 如$(“div &gt; p”)表示选择div下的直接层是p的节点。 + （加号） 紧跟兄弟关系 如$(“div + p”)表示选择div同层的左右相邻的p节点。 ~ （波浪线）任意距离兄弟关系 如$(“div ~ p”)表示选择div同层的p节点。 （空格） 任意层父子关系 如$(“div p”)表示选择div下的p节点（不管中间隔多少层）。 , （逗号） 表示选择器组合，如$(“div p, span p”)表示div下p节点和span下p节点。 基本筛选选择器 注意jQuery合集都是从0开始索引 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 可见性筛选选择器 $(&quot;:visible&quot;) 选择所有显示的元素 $(&quot;:hidden&quot;) 选择所有隐藏的元素 注意：:hidden选择器，不仅仅包含样式是display=”none”的元素，还包括隐藏表单、visibility等等。 隐藏一个元素的方法有以下几种 CSS display的值是none type=”hidden”的表单元素 宽度和高度都显式设置为0 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 属性筛选选择器 属性选择器让你可以基于属性来定位一个元素，可以只指定该元素的某个属性，这样所有使用该属性而不管它的值，这个元素都将被定位，也可以更加明确并定位在这些属性上使用特定值的元素。 描述如下： 在这么多属性选择器中[attr=&quot;value&quot;]和[attr*=&quot;value&quot;]是最实用的，[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等。[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件。 表单元素选择器 具体方法描述： 注意：除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。因此大部分表单类别筛选器可以使用属性筛选器替换。比如 $(&#39;:password&#39;) == $(&#39;[type=password]&#39;) 表单对象属性筛选选择器 具体方法描述： 注意：选择器适用于单选框和复选框，对于下拉框元素应该使用:selected选择器。在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素。 特殊选择器this **this和$(this)的区别： this是JavaScript中的关键字，指的是当前的上下文对象，简单地说就是方法/属性的所有者。 $(this)：通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法直接处理样式了。 总结来说，this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 jQuery的属性与样式 .attr()与.removeAttr() .attr() attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } .removeAttr()删除方法：为匹配的元素集合中的每个元素中移除一个属性（attribute） 注意区分Attribute和Property的概念，property是DOM中的属性，是JavaScript里的对象，例如tagName，nodeName，nodeType，defaultChecked，和 defaultSelected等；而attribute是HTML标签上的特性，它的值只能够是字符串；例如html中常用的id、class、title、align等。 获取Attribute就需要用.attr()，获取Property就需要用.prop() .html()与.text() .html()方法获取集合中第一个匹配元素的html内容，或者设置每一个匹配元素的html内容，具体有3中用法如下： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 注意：因为.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） .text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .text()结果返回一个字符串，包含所有匹配元素的合并文本 .val() .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function )，一个用来返回设置值的函数 .html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 .addClass()与.removeClass() .addClass()方法通过动态改变类名（class），可以让其修改元素呈现出不同的效果。用法如下： .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ): 这个函数返回一个或更多用空格隔开的要增加的样式名 注意：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上。 .removeClass()方法从匹配的元素中删除全部或者指定的class，用法如下： .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) )： 一个函数，返回一个或多个将要被移除的样式名 注意：如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。 .toggleClass()样式切换 通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass。用法如下： .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名。 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意：toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加。并且，toggleClass会保留原有的Class名后新增，通过空格隔开。 .css() 用于获取元素样式属性的计算值或者设置元素的CSS属性。用法如下： 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 通过.css方法设置的样式属性优先级要高于.addClass方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记及技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面马上要面试了，重新温习一下基础，把慕课网上的前端工程师课程走了一遍，整理了一些平时不太注意到的、或是个人印象不够深刻的JavaScript相关知识，希望可以巩固一下自己的印象。也能保证自己随时可以查看这些笔记。 关于大小写JS是大小写敏感的 document.write()直接向HTML输出流写内容，也将就是直接在网页中输出内容。如果要使用write方法输出一个HTML标签，则要使用&quot;&quot;将标签扩起来。 confirm对话框alert()对话框经常被用于调试程序，它包含一个确定按钮。而confirm对话框包括一个确定按钮和一个取消按钮，通常用于允许用户做选择的动作，语法为confirm(str);。confirm的返回值，当用户点击“确定”按钮时，返回true；当用户点击“取消”按钮时，返回false。可以定义一个变量来接收confirm的返回值。 prompt消息对话框除了上述两种对话框，还有一种prompt消息对话框。它通常用于询问一些需要与用户交互的信息。弹出的消息对话框包括一个确定按钮，一个取消按钮和一个文本输入框。语法为prompt(str1, str2);，其中str1是要显示在消息对话框中的文本，对用户来说是不可修改的；str2是文本框中的内容，用户是可以修改的。prompt的返回值，如果用户点击确定按钮，那么文本框中的内容将作为函数返回值；如果用户点击取消按钮，则返回null。 window.open()可以查找一个已经存在或者新建的浏览器窗口。语法window.open([URL], [窗口名称], [参数字符串]) window.close()用于关闭窗口。直接调用则关闭本窗口，使用&lt;窗口对象&gt;.close()则可以关闭指定的窗口。窗口对象可以是在打开窗口时建立一个变量进行存储。 Object.innerHTML用于获取或是替换HTML元素的内容。Object是获取的元素对象，比如通过document.getElementById(&quot;ID&quot;)获取的元素。 改变HTML样式使用Object.style.property = new style;来改变HTML元素的样式。注意，property是CSS样式属性，new style是属性的新值。 显示和隐藏语法：Object.style.display = value 控制类名（className属性）className属性设置或返回元素的class属性。语法：Object.className = classname 创建数组var arrayname = new Array()可以用来创建一个数组。创建的新数组是空数组，没有值，如输出，则显示undefined。并且，虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度，仍然可以将元素存储在规定长度以外。 函数传参js属于弱类型语言，所以在定义方法传入参数的时候并不需要指定其类型。 事件 鼠标点击事件onmouseclick 鼠标经过事件onmouseover 鼠标移开事件onmouseout 光标聚焦事件onfocus 失去焦点事件onblur 内容选中事件onselect（当文本框或者文本域中的文字被选中时触发） 文本框内容改变事件onchange 加载事件onload（该事件在页面加载完成后立即发生，如果不使用js代码则写在body标签中） 卸载事件onunload（用户退出页面时触发，比如页面关闭、页面刷新等） 时间 Date日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000秒）。定义时间对象的语法为：var Udate = new Date() 日期对象提供了以下方法： 返回/设置年份方法get/setFullYear() getDay()返回星期（返回是0-6的数字，其中0表示星期天） get/setTime()返回/设置时间方法（单位为毫秒数，计算从1970年1月1日零时到日期对象所指的日期的毫秒数，即时间戳） 字符串对象 .length可以获取字符串对象的长度 toLowerCase()方法可以将所有大写字母都转为小写字母 toUpperCase()方法则可以将所有小写字母转换为大写字母 charAt()方法返回指定位置的字符 indexOf方法返回指定的字符串首次出现的位置 split()方法分割字符串为字符串数组并返回（两个参数，第一个参数separator必需，用来指定分隔符；第二个参数limit可选，用来指定分割次数） substring()方法用于提取字符串中介于两个指定下标之间的字符（指定开始位置的参数必需，指定结束位置的参数可选） substr()方法从字符串中提取从startPos位置开始指定书目的字符串，语法：stringObj.substr(startPos,length)，其中length可选，默认值到字符串结尾 Math对象 ceil()函数用于对一个数向上取整，返回的是一个大于或等于x并且与x最接近的整数，语法Math.ceil(x) 向下取整函数floor()，语法Math.floor(x)，返回的是一个小于或等于x并且与x最接近的整数 四舍五入函数round()，语法Math.round() 随机数random()，可以返回一个大于等于0但小于1的随机数，语法Math.random() 数组对象 concat()方法用于连接两个或多个数组，语法：arrayObject.concat(array1,array2...arrayN)此方法返回一个新数组，不改变原来的数组 join()方法用于把数组中的所有元素都放入一个字符串，元素是通过指定的分隔符进行分隔的，语法arrayObject.join(分隔符)，该方法返回一个字符串 reverse()方法用于颠倒数组中元素的顺序，该方法会改变原来的数组而不会创建新数组 slice()方法可以从已有的数组中返回选定的元素，语法arrayObject.slice(start,end)，其中start参数必需，end参数可选，默认到数组结束，该方法返回一个新的数组，包括从start到end（不包括end）的arrayObject中的元素，不会修改原有数组 sort()方法使数组中的元素按照一定的顺序排列，语法arrayObject.sort(方法函数名)，如果不规定方法函数，则按unicode码顺序排列，如果指定方法函数，则按方法函数所指定的排序方法进行排序，这个方法函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数a和b，其返回值如下： 若返回值&lt;=-1，则表示a在排序后的序列中出现b之前 若返回值&gt;-1&amp;&amp;&lt;1，则表示a和b具有相同的排序顺序 若返回值&gt;=1，则表示a在排序后的序列中出现在b之后 计时器 计时器有两种： 一次性计时器，仅在指定的延迟时间之后触发一次 间隔性触发计时器，每隔一定的时间间隔就触发一次 setInterval()计时器执行时，从载入页面后每隔指定的时间执行代码，语法setInterval(代码, 交互时间);，其中，交互事件的单位是毫秒。 clearInterval()方法用于取消由setInterval()设置的交互时间，语法clearInterval(id_of_setInterval)，传入的id_of_setInterval是由setInterval()返回的ID值，可以使用一个变量来接收这个值。 setTimeout()计时器，在载入后延迟指定时间后，去执行一次表达式并且只执行一次，语法setTimeout(代码, 延迟时间);，其中延迟时间以毫秒为单位。 clearTimeout()计时器，和setTimeout()计时器一起使用，用于停止计时器，语法clearTimeout(id_of_setTimeout)，其中传入的id_of_setTimeout是由setTimeout()返回的ID值，可以使用一个变量来接收这个值。 History对象 history对象记录了用户曾经浏览过的页面（URL），并可以实现与浏览器前进和后退相似的功能。 注意：从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签乃至每个框架，都有自己的history对象与特定的window对象关联。 语法window.history.[属性|方法]，其中window可以省略。 属性：length，返回浏览器历史列表中的URL总数量。 方法： back()，用于加载history列表中的前一个URL。back()相当于go(-1)。 forward()，用于加载history列表中的后一个URL。forward()相当于go(1)。 go()，用于加载history列表中某个具体的页面，语法window.history.go(number);，其中number是指要访问的URL在history的URL列表中的相对位置，比如返回当前页面之后浏览过的第三个历史页面，number为3；返回当前页面之前浏览过的第二个历史页面，number为-2。 Location对象 location对象用于获取或设置窗体的URL，并且可以用于解析URL。 语法location.[属性|方法] location对象属性示意图： location对象方法： assign()，用于加载新的文档 reload()，重新加载当前文档 replace()，用新的文档替换当前文档 Navigator对象 navigator对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 语法navigator.属性 属性如下 userAgent 用于返回用户代理头的字符串表示，就是包括浏览器版本信息等的字符串 语法navigator.userAgent screen对象 screen对象用于获取用户的屏幕信息。 语法window.screen.属性 属性如下： window.screen对象还包含有关用户屏幕的信息 screen.height返回屏幕分辨率的高 screen.width返回屏幕分辨率的宽 注意，单位以像素计，window这个前缀可以省略。 availwidth和availHeight属性是可用的宽度和高度，会减去界面特性，如任务栏。 文件对象模型DOM getElementsByName()方法返回带有指定名称的节点对象的集合。 语法：document.getElement**s**ByName(name) 与getElementById()不同的地方在于这个方法使通过元素的name属性查询元素而不是通过id属性。 因为文档中的name属性有可能不唯一，所以这个方法返回的是元素的数组而不是一个元素。 getElementsByTagName()方法返回带有指定标签名的节点对象的集合，返回元素的顺序是它们在文档中的顺序。 语法document.getElement**s**ByTagName(Tagname) Tagname是标签的名称，如p，a，img等标签名。 getAttribute()方法通过元素节点的属性名称获取属性的值。 语法elementNode.getAttribute(name) elementNode是通过上述几个方法获取到的元素节点。 setAttribute()方法增加一个指定名称和值的性属性，或者把一个现有的属性设定为指定的值。 语法elementNode.setAttribute(name,value) 类似getAttribute()方法，此方法也是只能通过元素节点对象调用的函数。 节点属性： 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称，是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue ：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 nodeType ：节点的类型，是只读的。以下常用的几种结点类型 元素 -&gt; 1 属性 -&gt; 2 文本 -&gt; 3 注释 -&gt; 8 文档 -&gt; 9 childNodes用于访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，具有length属性。 语法elementNode.childNodes 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 firstChild属性返回‘childNodes’数组的第一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.firstChild firstChild属性与elementNode.childNodes[0]效果相同。 lastChild属性返回‘childNodes’数组的最后一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.lastChild lastChild属性与elementNode.childNodes[elementNode.childNodes.length-1]效果相同。 parentNode用于获取指定节点的父节点 语法elementNode.parentNode 父节点只能有一个 访问兄弟节点 nextSibling属性可以返回某个节点之后紧跟的节点（处于同一树层级中） 语法nodeObject.nextSibling 如果无此节点，则该属性返回null previousSibling属性可以返回某个节点之前紧跟的节点（处于同一树层级中） 语法nodeObject.previousSibling 如果无此节点，则该属性返回null 插入节点 appendChild()用于在指定节点的最后一个子节点列表之后添加一个新的子节点 语法appendChild(newnode) 例子： 1234var otest = document.getElementById(&quot;test&quot;);var newnode = document.createElement(&quot;p&quot;);newnode.innerHTML = &quot;This is a new p&quot;;otest.appendChild(newnode); 注意：应当由父节点来调用这个方法 insertBefore()方法用于在已有的子节点之前插入一个新的子节点 语法insertBefore(newnode,node); 例子： 1234var otest = document.getElementById(&quot;test&quot;); var newnode = document.createElement(&quot;li&quot;);newnode.innerHTML = &quot;PHP&quot;;otest.insertBefore(newnode,otest.firstChild); 注意：应当是父节点来调用这个方法，并定义在某个子节点之前插入新节点 删除节点 removeChild()方法用于从子节点列表中删除某个节点，如果删除成功，此方法返回被删除的节点，如果删除失败则返回NULL。 语法nodeObject.removeChild(node); 注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值，代码如下: 123var otest = document.getElementById(&quot;div1&quot;);var x = otest.removeChild(otest.childNodes[1]);x = null; 替换元素节点 replaceChild方法实现子节点（对象）的替换，返回被替换对象的引用。 语法node.replaceChild(newnode,oldnode) 注意，两个参数都是必须的，当oldnode被替换时，所有与之相关的属性内容都将被移除，并且newnode必须先被建立。 需要父节点调用这个方法，因此可以使用oldnode.parentNode.replaceChild(newnode,oldnode);来进行替换。 创建元素节点 createElement()方法可以创建元素节点，此方法可以返回一个element对象。 语法document.createElement(tagName); createTextNode()方法创建新的文本节点，返回新创建的Text节点。 语法document.createTextNode(data); 参数：data是字符串值，可以规定此节点的文本。 注意：innerHTML和createTextNode都可以把一段内容添加到一个节点中，区别是如果这段内容中有html标签（如例子中的）时表现就不同了，在createTextNode中会当作文本处理，不会被浏览器解析，但用innerHTML就会被当作HTML代码处理（如你的例子中Hello会被加粗显示）。 例子： 1234var element = document.createElement(&quot;p&quot;);var textnode = document.createTextNode(&quot;I love Javascript!&quot;);element.appendChild(textnode);document.body.appendChild(element); 浏览器窗口可视区域大小 获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： 直接求 document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者Document对象的body属性对应HTML文档的标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 12var w= document.documentElement.clientWidth(或 document.body.clientWidth);var h= document.documentElement.clientHeight(或 document.body.clientHeight); 网页尺寸 scrollHeight和scrollWidth，分别用于获取网页内容的高度和宽度 针对IE、Opera:scrollHeight 是网页内容实际高度，可以小于 clientHeight。 针对NS、FF:scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 浏览器兼容写法 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写。并且，scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 offsetHeight和offsetWidth，分别用于获取网页内容的高度和宽度（包括滚动条和等边线，会随窗口的显示大小改变） 值：offsetHeight = clientHeight + 滚动条 + 边框。 浏览器兼容性1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; height、clientHeight、scrollHeight、offsetHeight区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于Node.js Node.js适合高并发、低负载、弱逻辑的项目，适合做如dataAPI或聊天系统等实时性要求比较高的项目。 关于HTML 渲染顺序 HTML文档是从上向下渲染的，因此同一区块有些不重要的内容可以适当往后放，让重要内容先被加载出来（本条是对于结构来讲，也就是对于HTML语言来讲，不涉及表现CSS或行为JS）。 结构与表现分离 前端开发时要注意结构与表现分离，在编写前端页面的过程中，要先从结构考虑，争取做到结构最简，避免有过多不必要的div。当结构编写完后，再考虑表现，也就是CSS样式。通过这种结构与表现分离的思想，争取做到修改业务逻辑时，只需要改动样式，而不需要改动结构。 如何让一段文本向右移动？ 当然可以采取margin或padding的形式将文字元素推到右边，但这样做会造成外部容器的宽度发生变化，就需要再次修改外部容器的宽度。此时，最理想的操作方法应该是使用text-indent属性，来设置文本缩进，它不会影响外部容器的宽度，也可以设置百分比，简洁易用。 背景图片 元素的背景，比如导航栏圆角背景，可以将普通状态下的背景（如灰色）与hover状态下的背景（如橙色）做在同一张图上，上下排列并掌握好宽和高。这样可以给默认状态下的导航栏菜单项（即display属性值为block的a标签）设置这张背景图，通过长宽来确保背景为灰色。当该菜单项处于hover状态或选中状态时，添加class并设置该菜单项的background-position属性，来使背景图向上移动，显示出之前拼接好的橙色背景来。 导航栏的制作 导航栏的结构均为&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;这样的无序列表，如果是竖向导航栏则无需float，如果是横向导航栏则可以设置li标签的float属性的值为left或right。 js代码中的window.onload 是为了让dom加载完毕之后再执行以下代码。jquery的$(function)(){}相当于js中的window.onload，并且比window.onload性能要好。 关于语义 &lt;q&gt;&lt;/q&gt;标签会在html文档中显示为双引号，但使用标签的主要目的并不是为了显示双引号，这样还不如直接输入双引号。它的目的是它的语义：引用别人的话。还有一个引用标签&lt;blockquote&gt;&lt;/blockquote&gt;，浏览器对它的解释是缩进样式，表示引入长文本。 一些HTML标签 &lt;hr /&gt;标签用于添加一条水平横线。 &lt;em&gt;&lt;/em&gt;标签用于斜体。 &lt;address&gt;&lt;/address&gt;用于显示地址，浏览器默认样式是斜体，当然也可用通过css来修改。 插入代码使用&lt;code&gt;标签如：&lt;code&gt;代码语言&lt;/code&gt; &lt;pre&gt;&lt;/pre&gt;标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。可以使用这个标签来包裹大段代码。 可以对&lt;table&gt;标签进行一些优化，&lt;caption&gt;表格标题&lt;/caption&gt;可以指定表格的标题，&lt;table summary=&quot;表格简介文本&quot;&gt;，这里的简介不会在浏览器显示出来，是为了增加表格的可读性（语义化）。 &lt;a&gt;除了常见的功能之外，标签还有一个功能是可以用来链接Email地址，使用mailto可以使访问者便捷的向网站管理者发送电子邮件，这样点击a链接时会打开电子邮件应用，并自动填写收件人等设置好的信息。具体用法如图 img标签可以通过title属性指定鼠标滑过图片时显示的文本。图片格式可以是gif，png，jpg，jpeg等。 在&lt;select&gt;标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 表单的重置按钮，可以通过设置input标签的type值为reset来实现。 label标签：label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。语法：&lt;label for=&quot;控件id名称&quot;&gt;。例子： 123456789&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;br /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;female&quot; /&gt; &lt;label for=&quot;email&quot;&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt;&lt;/form&gt; 可以为span标签添加属性white-space:pre;，这个样式表示空白会被浏览器保留。 css几种设置方法的优先级 12345671. 内联样式表的权值最高 10002. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 CSS 优先级法则： 123456789A 选择器都有一个权值，权值越大越优先B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式D 继承的CSS 样式不如后来指定的CSS 样式E 在同一组属性设置中标有“!important”规则的优先级最大 ID选择器只能在文档中使用一次。可以使用类选择器词列表方法为一个元素同时设置多个样式，ID选择器是不可以的。 子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。二者的区别在于：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通配选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素。 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（,）。 有些特殊的情况需要为某些样式设置具有最高权值，这时候我们可以使用!important来解决。如：p{color:red!important;}。注意：!important要写在分号的前面。 text-decoration可以用于设下划线、删除线等文字样式。 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;}。注意：2em的意思就是文字的2倍大小。em 就是一个全角占位符，则2em 就是2个全角位置。但是，建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。 line-height也是段落排版中一个常用的属性，指定行间距（行高）。 如果想在网页排版中设置文字间隔或者字母间隔就可以使用letter-spacing 来实现。如果想设置英文单词之间的间距可以使用 word-spacing 来实现。 html的标签元素大体被分为三种不同类型：块状元素、内联元素(又叫行内元素)和内联块状元素。它们的区别：块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。 块级元素特点：（display:block; 所有块级元素都具备盒子模型的特征） 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素特点：（display:inline;） 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素特点：（inline-block;） 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型 流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。第二点：在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed) absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。 水平居中：如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素(块状元素的宽度width为固定值)和不定宽块状元素(块状元素的宽度width不固定)。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的，元素的“上下 margin” 是可以随意设置的。不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）： 加入 table 标签。这是利用table标签的长度自适应性——即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置。 设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的。 垂直居中 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。但这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 父元素高度确定的多行文本、图片等的竖直居中的方法有两种：方法一：css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。方法二：在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 隐性改变display类型：只要html代码中出现position : absolute或float:left或float:right其中之一，则元素的display显示类型就会自动变为inline-block，就可以设置宽和高了，并且默认宽度不占满父元素。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习笔记-入门篇]]></title>
    <url>%2F2018%2F03%2F25%2FVue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于“渐进式”的理解想要理解渐进式的概念，首先要理解什么是框架。框架的存在是为了帮助我们应对复杂度，而框架本身也会带来一定的复杂度，所以就可以抽象出一个问题，即所要解决的问题的内在复杂度，与所使用的工具的复杂度进行对比。不难理解，工具复杂度是为了处理内在复杂度所做的投资，所以如果使用一个过于简陋的工具应对一个复杂的问题，就会遇到工具太弱而使得生产力受影响的问题；同样的，如果你想要解决的问题并不复杂，但你却用了很复杂的框架，那么就会遇到工具复杂度所带来的副作用，这样不仅会使工具失去了本身所带来的优势，还会增加各种问题，例如培训成本、上手成本、以及实际开发效率等。 综上所诉，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。而我们目前需要的可能是一个能够根据项目需要自由“伸缩”的框架，这种自由“伸缩”的概念，就是渐进式的概念，渐进式的框架不需要做太多职责之外的事情，你完全可以根据你的需要来选择让框架完成什么功能。 使用vue无需关心DOM操作，所有的DOM操作都交给vue来完成，你编写的代码只需要关注逻辑层面即可。 数据双向绑定示例如下，input表单中的值如果改变，data中的message也会跟着改变，而如果data中的message改变了，则input中的值也会改变。html代码：1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/input&gt;&lt;/div&gt; js代码：12345678&lt;script&gt;new Vue(&#123; el: &apos;#app&apos; data:&#123; message: &quot;Hello World!&quot; &#125;&#125;);&lt;/script&gt; 数据双向绑定有个好处，如果input表单的值发生变化，则h1标签中的值会同步更新。而这个过程要用jQuery等框架实现并不容易。tips:可以使用下列语句打印data中的message内容，也会随input框中内容的变化实时更新。其中|是个过滤器，用于控制文本以json格式输出。123&lt;pre&gt; &#123;&#123; $data | json &#125;&#125;&lt;/pre&gt; v-show与v-if的区别v-show实际上是控制DOM元素的display属性，而v-if如果不为真，则直接不渲染该元素。在查看源代码时可以看出这个区别。 vue中的事件vue中的事件使用v-on绑定，比如表单绑定提交事件可以写为v-on:submit=&quot;functionName/表达式（使用的变量要在data中声明）&quot;或@submit=&quot;functionName对应的js代码如下：123456789new Vue(&#123; el: &quot;#...&quot; methods:&#123; functionName: function()&#123; ... //这里可以使用this.变量名来获取data中的数据 &#125; &#125;&#125;); *注意：默认情况下点击提交可能会跳转到一个页面，可以在上述代码中向函数传入一个e作为参数，使用e.preventDefault();阻止表单的默认提交行为。也可以简写在html中v-on:submit.prevent=&quot;functionName&quot; Vue的组件组件可以扩展 HTML 元素，封装可重用的代码。Vue中的组件化使得你可以创造自己的html标签，从而方便重用。要注册一个全局组件，可以使用 Vue.component(tagName, options)。例如，想要在html中使用一个&lt;test&gt;&lt;/test&gt;标签，则需要以下js代码：12345&lt;script&gt; Vue.component(&apos;test&apos;,&#123; template: &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos; &#125;);&lt;/script&gt; 此时浏览器会将template中的内容替换到&lt;test&gt;&lt;/test&gt;的位置。template中的内容可以在html代码中指定一个&lt;template&gt;&lt;/template&gt;标签，并赋予id，在template处指定值为#id。props指定了组件的属性，自定义组件中如果要使用某个属性并赋值，需要在props声明。注意：vue中的组件是不允许有大写字母存在的，如果你的组件使用了驼峰式命名，如myCounter，则使用这个组件的时候标签会自动变成&lt;my-counter&gt;&lt;/my-counter&gt;。 示例：使用同一段代码来实现一个点赞及不喜欢的计数功能：注意：此示例中标签是包裹在一个id为app的div中的，因此必须要实例化Vue并指明el的值为#app，否则没有效果。即官方文档中说的注意确保在初始化根实例。并且，组件应该在初始化根实例之前被注册。 vue的两个彩蛋 在cdn中搜索vue并复制vue的非压缩版本，在浏览器中的console窗口中，如果你的代码有错误，则会有十分友好的提示。开发过程中最好不要使用压缩版本，不然就失去了所有常见错误的警告。 vue-devtoos，一款chrome插件，需要在有服务器的情况下使用，本地服务器也可以，它会显示出vue本来的样子，结构清晰，对vue的开发也会有一定的帮助。 computed可以用于一些需要处理代码逻辑或业务逻辑的输出，或者是一些需要经过多方判断最终输出到屏幕的数据。如果与input进行了数据绑定那么也是可以实时更新的。示例如下： 循环输出使用v-for来循环输出data中的json数组中的数据。 举例：12345&lt;ul&gt; &lt;li v-class=&quot;task.completed ? &apos;completed&apos; : &apos;&apos;&quot; v-for=&quot;task in tasks&quot; &gt;&#123;&#123; task.body &#125;&#125;&lt;/li&gt; 或者写为以下格式也可以根据json数据中的complete字段来指定元素的样式 &lt;li :class=&quot;&#123;&apos;completed&apos;:task.completed&#125;&gt;&lt;/li&gt;&quot;&lt;/ul&gt; tips：v-class可以简写为:class。如果直接写:class=&quot;completed&quot;是不起作用的，需要在data中对complete进行声明或者写为:class=&quot;[&#39;completed&#39;, &#39;something&#39;]&quot;。js代码：1234567data:&#123; tasks:[ &#123;body: &apos;go to the movie&apos;, completed: false&#125;, &#123;body: &apos;learn vue.js by video&apos;, completed: true&#125;, &#123;body: &apos;go to the shop&apos;, completed: false&#125; ]&#125; 12345&lt;style&gt; .completed&#123; text-decoration: line--through; &#125;&lt;/style&gt; 一些建议自定义标签尽量添加一些前缀或后缀，或者使用多个单词，因为html一般使用单个单词作为标签，这样可以最大程度的避免重复的可能，也避免了需要修改代码的可能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础学习笔记]]></title>
    <url>%2F2018%2F03%2F22%2FMarkDown%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文源于Markdown官方文档，自行整理后发布，首发于CSDN，Markdown常用语法学习笔记 标题（1）atx形式： # 表示一级标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 ## 表示二级标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 …… ######表示六级标题，即HTML语言中的&lt;h6&gt;&lt;/h6&gt;标签 （2）Setext形式： = 底线 表示最高阶标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 - 底线 表示二阶标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 段落一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，例如只有空白和tab）。 注意，一个以上空行的意思是，当前行输入完毕换行后，再次按下回车键换行，这样即为一个以上空行。显示上看起来是两行文字之间留出一行了空白行。 段落即为HTML语言中的&lt;p&gt;&lt;/p&gt; 区块&gt; 表示区块，即首行缩进一个单位长度（通常为四个空格的长度），即HTML语言中的&lt;blockquote&gt;&lt;/blockquote&gt; 列表* 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; + 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; - 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; 1. 有序列表，数字加英文句点，对应HTML语言中的&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 注意： 你在列表标记上使用的数字并不会影响HTML的输出结果。如果你使用懒惰的写法，建议第一个项目最好从1.开始，因为Markdown未来有可能会支持有序列表的start属性。 如果在插入列表时，在列表的两项之中插入了空行，则该项内容会用&lt;p&gt;标签包裹起来，你也可以在一项中插入多个段落，只要正确的保证了空行，并且最好开头能够空出四个空格或一个tab，或者是添加一个&gt;使它变成区块，这样和列表显示起来比较整齐。 链接Markdown支持两种形式的链接语法：行内和参考两种形式。 （1）行内形式： 格式：This is an [example link](www.example.com) 解释：在HTML语言中即为，将example link包裹在&lt;a&gt;标签中，并且href地址为www.example.com。 格式：This is an [example link](www.example.com &quot;With a title&quot;) 解释：基本同上，区别是指定了该a标签的title属性值为With a title。 （2）参考形式： 参考形式的链接可以让你为链接定一个名称，之后在其他地方统一定义链接的内容。 格式：This is an [example link][1], and [the second example link][2]. [1]: www.example.com [2]: www.example2.com &quot;title&quot; 解释基本同上，需要注意的地方是，[1]不一定非要使用数字，可以使用字母、数字和空格或其组合，但是不分大小写。 图片图片的语法和链接很像，也分为行内形式和参考形式两种。 （1）行内形式（title是选择性的）： 1![alt text](/path/to/image.jpg &quot;Title&quot;) （2）参考形式：123![alt text][id][id]: /path/to/image.jpg &quot;Title&quot; 上面两种形式都会输出HTML为：&lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot;&gt; 代码Markdown文档中如果输入HTML代码，是会直接生效的。如果想要显示出一一段代码来而不是让它被解析运行，就使用` `（反引号，英文模式下按键盘左上角的波浪号键，注意不能跨行）将代码部分包裹起来，这样就可以显示出原原本本的代码了。 分割线可以在一行中使用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或减号中间插入空格。如： * * * - - - ****** ------ 强调使用星号*和底线_作为标记强调字符的符号，被一个*或_包围的内容会以标签的形式显示，即斜体。被两个*或_包围的内容将会以标签的形式显示，即加粗。 注意，如果*或_的两边有空白，则会显示成普通的星号或底线。如果想要在文字前后直接插入普通的星号或底线，则需要用到转义字符\。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2FHello-World%2F</url>
    <content type="text"><![CDATA[Update in 2018.03.25更新了搜索功能，博客基本功能全部配置完毕。绑定了域名fnine59.top，以后可以通过fnine59.top或www.fnine59.top访问本站。 Update in 2018.03.22程序员面对任何一门新技术，第一句话似乎永远都是Hello World。 从大约3月18号左右开始着手准备这个项目，Hexo基于Git和Nodejs，所以先是花了一两天左右，利用课余时间学习了Git。到最后真正用于搭建这个网站的时间差不多也就一个下午。 这个网站目前还有些功能没有完善起来，会进一步改善的。 欢迎留言，欢迎联系我❤]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《JavaScript标准参考教程》阅读笔记]]></title>
    <url>%2F2018%2F05%2F02%2F%E3%80%8AJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本语法语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。分号前面可以没有任何内容，JavaScript引擎将其视为空语句。表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。变量的声明和赋值，是分开的两个步骤。如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。注意：中文是合法的标识符，可以用作变量名。 JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/和/之间。此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以也被视为合法的单行注释。需要注意的是，–&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime使用技巧]]></title>
    <url>%2F2018%2F04%2F20%2FSublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Sublime版本3的新特性 可以直接打开图片 Goto Anything 使用ctrl+p打开 可以在css文件内部使用@快速定位选择器 可以在js文件内部使用@快速定位函数 可以在html文件内部使用#快速查找 多行游标 产生多行游标的办法： 光标停留在一个词上按ctrl+d，再按ctrl+d就会选中下一个重复词，按ctrl+k再按ctrl+d可以跳过当前词再选择下一个词 光标停留在某一位置，按住shift按住鼠标右键拖动可以快速创建多行游标 选中某一个词，alt+f3可以全选这个词 命令模式 使用ctrl+shift+p打开命令模式 可以快速跳转页面 可以快速改变文档的识别格式，比如打开命令模式窗口，输入js，当前文档就会以JavaScript规则解析高亮 输入minimap，出现的选项可以隐藏/显示minimap emmet 文档开头输入一个!按ctrl+e即可生成html5的头，此时光标自动停留在title部分，使用ctrl+p goto anything来进行页面跳转，输入#body跳转到body处，然后按ctrl+enter快速在该行下方添加一行，就可以开始编辑html5代码了，这一过程无需鼠标操作 使用&gt;符号表示子元素，使用.指明class名称，使用$指明class名称中的数字序号 带缩进粘贴：ctrl+shift+v 当前行上方添加新行：ctrl+shift+enter 使用{}来指明标签内的内容，比如h2{this is title}会生成&lt;h2&gt;this is title&lt;/h2&gt; ctrl+e可以快速闭合标签 package control 可以通过pci在命令窗口中快速匹配package control : install package 安装主题： 可以去package control官网预览一些主题，在Labels——Theme下看 theme-soda theme-flatland theme-spacegray 可以在package control官网中的popular下查看比较流行的插件 snippet 在命令模式中输入snippet，选择function可以直接生成一个js函数，用tab键可以切换高亮，减少鼠标的使用 其实在编辑区中输入fun按回车使用sublime编辑器的自动补全完成这一过程 prototype快速使用原型链 document.getElementById等函数的输入，可以通过安装JavaScript snippet插件，然后输入ei按回车即可 还有很多snippet可以自己探索 advanceNewFile 使用ctrl+alt+N输入文件名或带路径的文件名快速创建文件，不存在的目录也会自动帮忙创建，这比用ctrl+n然后保存的方式要快的多 httpRequester 用于测试服务器端请求 get请求通过访问页面直接测试 post请求通过表单提交测试 使用了httpRequester插件之后，只需要编写一些注释，然后选中这段注释，按下ctrl+alt+R即可弹出一个新的tab页，内容即为运行是否成功等相关信息 nettus fetch 新建一个jQuery.js文件，然后在文件中使用命令模式中使用Fetch File命令，选择想要的文件按下enter，然后就会自动下载最新版本的jQuery side bar相关的插件 可以增强sublime的sidebar的功能，使用后可以直接在sublime中右键一个html文件在浏览器中打开 DocBlockr快速添加注释 可以自动补全注释块 如果是js文件，在一个函数的上方，输入/**，然后按tab键可以自动补齐一个函数的注释格式 使用lint进行语法及风格及校验 目前各个语言基本都有自己的lint系统，可以对语言的语法及风格进行检验 sublime linter是一个总体框架，如果想要针对某个语言需要在具体安装，比如针对js的需要再安装JSHint（JSLint的增强版） 在jshint的网站中可以查看所有可配置参数的说明，可以在工程文件中创建一个.jshintrc文件来配置自己想规定的规则]]></content>
      <categories>
        <category>开发工具使用</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andorid学习笔记]]></title>
    <url>%2F2018%2F04%2F17%2FAndorid%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2018%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本篇文章整理自《Linux系统概述》课堂笔记，会有一些与Linux无关的课外知识补充。考试重点在标题前用※标注，十分重要的点会标为彩色。Linux常用命令部分为避免符号混淆，不使用※标注重点，重点直接标为彩色，并且凡是该命令列出的选项均为常用或重点的选项。 基本概念整理操作系统的概念操作系统是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。 操作系统的基本功能包括存储管理、进程和处理及管理、文件管理、设备管理和用户接口服务。 操作系统的类型 批处理系统 分时系统：很普遍 实时系统：典型的实时系统如VxWorks 网络操作系统 分布式操作系统 Linux系统的特点 与Unix兼容 自由软件，源码公开 性能高，安全性强 便于定制和再开发 互操作性高 全面的多任务和真正的32位操作系统 Linux的常用版本 核心版本：主要是Linux的内核，由Linus等人不断开发和推出新的内核。内核版本号格式：x.y.zz-www，x为主版本号，y为次版本号，z为修订版本号。 发行版本：是各个公司推出的版本，与核心版是各自独立发展的，发行版是一些基于Linux核心的软件包。 Linux系统基础知识使用工具推荐虚拟机：VMware（本文使用）、Virtualbox（免费） 虚拟机使用注意事项： 同时开启的所有虚拟机占用内存不要超过真实内存的一半。 一般来讲，建立一个win7内存至少1G+，而建立一个Linux系统内存1G即可，有些版本的Linux系统可能500M+也可以。 但内存也不要过小，否则虚拟机的性能将十分低，导致运行速度过慢。 虚拟机的运行：虚拟机与真实设备共用外存和CPU，内存则划分一块真实内存来使用，硬盘实际上是一个硬盘文件。 系统镜像（*.iso）：红帽企业版、CentOS、debian、openSUSE等，本文均使用红帽企业版。 VMware常用功能 快照功能：虚拟机 —— 快照 —— 拍摄快照/快照管理器；用于记录当前配置环境，后续操作过程中如果出现错误可以随时还原；在快照管理器中右键点击 —— 转到快照，可以使系统还原到该快照； 克隆功能：虚拟机 —— 管理 —— 克隆；用于快速复制一个相同的虚拟机； VMware Tools的安装：虚拟机 —— 重新安装VMware Tools，则安装包会以虚拟光驱的形式出现在虚拟机中，是一个压缩包，使用命令将它解压到/tmp中，然后执行安装 VMware Tools的几个明显的功能：①屏幕自动调整；②可以在真机和虚拟机之间复制文件；③提高游戏性能，是对VMware的增强 虚拟机中系统的安装（VMware安装64位红帽企业版） 在VMware中选择创建新的虚拟机 —— 配置类型选择典型 —— 选择稍后安装操作系统 —— 选择Linux系统 —— 选择green Hat Enterprise版本（这里其实就是个名字，并没有什么实际影响） —— 指定存储路径 —— 指定磁盘容量使用默认配置即可，默认将虚拟磁盘拆分为多个文件即可 —— 选择自定义硬件做最后的调整 —— 完成 开机进行系统安装，开机前保证虚拟光驱中放入了系统镜像（.iso）文件 系统安装部分 选择Test this media &amp; install green Hat Enterprise Linux 7.4，然后根据系统提示安装即可 注意安装时选择带GUI的服务器，并勾选开发工具选项保证gcc可以使用 注意事项： 有些电脑主板不支持开启VT，这样的电脑不能使用64位虚拟机。 如果是安装服务器用的Linux，先不要选择中文，服务器是没有GUI的，因为真实终端刚安装好的时候看不到中文，会全部显示乱码，此时就没办法使用了。 服务器一般为了性能，是不会使用GUI的。 ※Linux系统中硬盘设备的命名规则Linux通过字母和数字的组合来标志硬盘分区。前两个字母表示分区所在的设备的类型，如hd表示IDE硬盘即并口硬盘，sd表示SCSI/SATA/USB硬盘即串口硬盘，第三个字母表示分区在哪个设备上，如hda表示第一块IDE硬盘，hdb表示第二块IDE硬盘，sdc表示第三块串口硬盘等；最后的数字表示分区的次序，如数字1~4表示主分区或扩展分区，而逻辑分区从5开始。如果没有对磁盘分区，则一律不加数字，表示整块磁盘。例：/dev/sda5其中，dev是Linux系统中硬盘设备文件所在的目录；sd表示为串口硬盘，相对的，hd表示为并口硬盘；a表示硬盘的顺序号；5表示分区的顺序号；综上所述，上述命名表示Linux系统中第一块串口硬盘的第5个分区。 ※Linux系统分区规则 默认必须有一个/即根分区，也就相当于Windows系统中的C盘； 默认必须有一个swap分区即交换空间，它用作虚拟内存，通常为内存的1-1.5倍大小甚至2倍。（补充：windows系统的虚拟内存为pagefile.sys，存储在C盘是个隐藏文件。虚拟内存防止所有内存空间突然全部用完的情况，虽然虚拟内存速度很慢，但可以预防紧急情况；还有一种情况是电脑突然待机，此时会把数据放到虚拟内存中） /boot分区是用于保证即使根分区出现问题也能启动计算机的，可以没有。 Linux中的主分区至少有1个，最多有4个（由于分区表大小限制）； 扩展分区可以没有，最多1个； 逻辑分区建立在扩展分区之下，可以有多个； 综上所述，主分区+扩展分区（逻辑分区1+逻辑分区2+…+逻辑分区n）=硬盘容量。 ※在Unix或Linux系统上实现GUI的机制——X WindowX Window模型如下图： Window系统上鼠标点击时是由被点击的应用程序直接获得鼠标点击事件，而Linux系统上则不然，Linux系统在点击后首先通知X Server服务器，X Server收到后，根据大概的位置推算出被点击的是哪个应用程序，再通过X协议告知该应用程序。因此，Windows系统的GUI比Linux稍快。 ※整个X Window由三个部分组成：X ServerX ClientX protocol:X Server与X Client之间的通信协议 其中X Server与X Client可以不在同一台机器上。在启动X Window时，首先启动X Server，然后启动X Client，最后建立通信。 ※Linux常用的文件系统Linux常用的文件系统有ext4、xfs、f2fs、zfs、btrfs补充： windows常用的文件系统有FAT32、NTFS、exFat ios常用的文件系统APFS Linux系统常见的压缩文件后缀 .tar.gz .bz2 .zip .gz .tar.bz2 ※Linux系统的分区表分区表有两种形式 MBR：最多支持4个主分区，或者3个主分区以及一个扩展分区，扩展分区下可以划分出若干个逻辑分区 GPT：支持几乎无限个分区数量，但Windows系统最多支持128个GPT分区 ※GNOME和KDE桌面 GNOME：用GTK、GTK+等应用程序开发包开发的；而GTK是用C语言开发的 KDE：用Qt库开发的，而Qt由c++开发。 一些名词 虚拟控制台 虚拟终端 控制台 命令行 终端 CLI(Commender Line Interface)这些在Linux系统上指代的都是同一样东西，也就是可以输入命令行的窗口或界面。放在Windows系统上来讲就是cmd。其中虚拟控制台和虚拟终端稍有特殊，它们指代的是图形用户界面中的命令行窗口。 Linux系统快捷操作 在Linux系统中使用ctrl+alt+Fn（n=1,2,3..n）来切换到第n个终端，也有些发行版采用快捷键alt+Fn ctrl+shift+t可以在终端窗口中新建标签 命令行快捷方式 输入一个很长的文件名时，可以先输入头几个字母，然后按tab键补全；系统补全操作会在出现其他可能的选择时停下来，此时要么再输入一位；要么再按tab键出现可能选择后，在对照着可能的选择中你要的那个文件名多输入一位，然后再按tab补全 ↑重复运行过的命令中的上一条命令，↓查找运行过的命令中的下一条命令 .bash_history记录之前输入的命令，默认为1000条。使用方法：按ctrl+R，命令提示符会变为(reverse-i-search)，此时输入的东西会去之前输入过的命令中匹配，找到后按回车键即可执行 ※Linux与Windows在命令行与GUI启动顺序上的差异 Linux是先启动命令行，在启动到黑底白字的终端界面后所有功能已经能够正常使用，GUI只是在Linux系统之上运行的一套应用程序，GUI上又提供了可以使用命令行的虚拟终端；（红帽企业版默认在第一个终端上运行GUI） Windows系统的GUI与系统内核是高度集成的，它首先启动GUI，命令行只是运行在GUI上的一个应用程序。 ※Linux系统中根目录下每个文件夹的作用 /bin ：即Binary（二进制）的缩写，用于存放一些命令文件 /sbin ：s代表super user，用于存放root用户专用的一些命令文件 /boot ：boot意为启动、引导，如果不为Linux系统单独建立一个分区则会生成一个boot文件夹，用于存放操作系统的内核以及启动时必需的文件 /dev ：device的缩写，用于存放一些硬件设备 /proc ：内存的映射，如果要修改内存中的数据就通过proc修改，因此备份系统的时候，proc文件夹是不需要备份的 /etc ：存放各种程序的配置文件，这个文件夹一般体积较小，但很重要 /lib(或/lib64) ：用于存放动态链接；相当于Windows系统中的dll文件，程序是以功能片段+共享库的形式运行的，Linux系统中这样的文件后缀名一般为.so或.a /lost+found ：系统的“失物招领处”，非法关机后这里会存有一些文件，一般不会用到，但数据恢复的时候可能会需要找这个文件夹中的文件 /mnt ：mount的缩写，即挂载。挂载操作都需要一个挂载点，Linux系统中的挂载点通常放在这个目录下 /root ：root用户的主目录/家目录，只能root用户自己查看和操作，普通用户没有权限 /home ：普通用户用来存放自己的数据，即普通用户的主目录/家目录。比如有一个名为stu的用户，则它的主目录为/home/stu /var ：放一些经常发生变化的文件，比如日志文件、缓存文件等 /tmp ：存放一些临时文件，重要的文件一定不要放在tmp文件夹里，因为这个文件夹要么定时自动清理，要么开机自动清理，重要文件放在这里容易丢失 /usr ：这个文件夹体积非常大，会放很多东西，比如应用程序的文件之类 /media ：作用同mnt文件夹，区别在于，mnt文件夹下一般存放手动挂载设备的挂载点，而media文件夹下一般存放自动挂载设备（如U盘、移动硬盘等）的挂载点 /opt ：option的缩写，意为“选择”，这个文件夹是一个可选的文件夹 为什么使用Linux命令行因为一般执行远程操作管理的时候都是进入文本环境，GUI会消耗很多不必要的流量；而且使用命令行对做技术支持的人来说十分便利 Linux系统的文件 Linux系统的文件名几乎可以有ASCII字符的任意组合构成，文件名最长可多达255个字符 Linux上可以有形式上的扩展名，扩展名有没有都可以；Linux是通过文件的头信息来识别文件类型的，扩展名在Linux系统上并不起作用，顶多可以由图形用户界面识别扩展名并显示对应的图标而已，再者是为了使文件在不同的文件系统中能够统一类型； Linux中的文件有三个时间信息： ctime：即create time，创建时间 mtime：即modify time，修改时间，对文件内容进行修改或者对文件附属数据进行修改时会更新这个值 atime：访问时间，使用touch命令可以更新这个值 很多配置文件只能root用户修改 Linux系统中的所有文件都有权限和主人 Linux系统的用户 用户注册信息存放在/etc/passwd文件中，编号1000之后的是用户创建的用户，1000之前的是系统默认创建的用户 Linux系统中要删除用户，实际上就是删除/etc/passwd中该用户的那一行信息，并删除/home/用户名这个用户主目录 一般来讲，Linux系统上的home文件夹会单独放在一个分区，就如同windows系统中的D、E、F盘那样，因为重装系统时会格式化根分区，Windows会格式化C盘，将home单独放在一个分区可以避免用户数据丢失 如果Linux的用户改名，主目录是不会改名的 Linux系统中的几种文件类型 普通文件 目录文件：即文件夹 设备文件 符号链接文件：分为软链接和硬链接 Linux系统中的路径 绝对路径，以根目录即/开头 相对路径，以目录名开头或以./开头，比如./etc/也就相当于etc/，代表当前目录下有个etc文件夹 Linux系统中的硬链接和软链接 硬链接：不可以跨分区 软链接：相当于windows系统中的快捷方式，可以跨分区，也称为符号链接 Linux系统常用命令※Shell提示符 root用户： # 其他用户： $ ※shell提示符前面字符串的含义[root@localhost home]# root代表当前登录的用户的用户名 localhost代表当前登录的主机名 home代表当前所在目录 # 是root用户的shell提示符 注意：命令行中输入密码时是没有回显的 Linux系统一般命令格式命令名 [选项] [参数]通常情况下选项是一个短横线加一个字母，如-a、-x、-b，这三个选项也可以略写为-axb；通常两个短横线之后跟一个完整的单词，如–all，则all是一个单词，是一个选项，而不是三个选项；通常来讲会是这样，但并不绝对。 命令名必须是小写的英文字母，并且往往是表示相应功能的英文单词或单词的缩写；命令名、选项和参数彼此间必须用空格或制表符隔开，不能连在一起，连续的空格会被shell解释为单个空格 who命令用于显示当前已注册到系统的所有用户名、所用终端名和注册到系统的时间。tty即为真实终端，是无图形用户界面的终端。pts指的是虚拟终端，是GUI中运行的终端窗口。who am i命令将列出使用该命令的当前用户的相关信息 用户退出登录 logout exit ctrl+P 发送消息 shutdown -k 不关机，只发送消息给所有用户 关机 halt shutdown -h （time可以写为now，代表立刻关机） 例：shutdown -h 11:00 &lt;message&gt; 在11点关机并发送消息message poweroff 注意：有的发行版只有root用户可以关机 重启 reboot shutdown -r ctrl+alt+del ctrl+alt+backspace —— 重启GUI init命令涉及到init命令，首先要了解几个运行级别 0 —— 表示关机 6 —— 表示重启则命令init 0即表示关机 clear命令用于清除屏幕上的信息，类似于dos中的cls命令。 passwd命令用于修改密码。root用户使用passwd 用户名可以不需要原密码就修改该用户的密码 pwd命令 用于显示当前工作路径，可以使用cd命令来切换工作路径 选项： -P 显示实际路径，即，如果路径中有链接文件，-P会将链接文件替换为真实文件 -L 显示逻辑路径 su命令 用于切换用户身份，用法su username，如果不加用户名则默认切换到root用户 root用户切换到普通用户不需要密码，但普通用户切换到root用户需要密码 不建议从root用户用su命令切换到其他用户，因为这样相当于root用户穿了普通用户的马甲，一旦退出无需密码直接退回到root用户，这样有可能会导致一定的安全问题；建议使用exit命令退出root用户同时退回普通用户 echo命令 用于将命令行中的参数回显到标准输出（即屏幕）上，如echo $PATH会显示环境变量PATH的值；而echo 字符串A会显示字符串A 选项： -n ：表示输出字符串String之后光标不换行 date命令 用于在屏幕上显示或设置系统的日期和时间 date显示的日期信息中，有一列CST意为China Standard Time，中国标准时间，即北京时间 date %y%m%d%H%M%S 可以显示年月日时分秒格式的日期 cal命令 用于显示日历，一般格式为 cal [选项] [[[day]month]year] 如：cal 2008会显示08年的日历，cal 03 2020会显示2020年3月的日历 file命令使用file 文件名可以查看文件的头信息 查找 find ：用于在硬盘中查找文件的位置，用法find 路径 -name *example，其中*example代表以example结尾的文件 locate ：用于查找文件的位置，但在文件量特别大的情况下速度比find快，因为locate有一个小型的数据库并建立了索引，所以查找很快，但最新生成的文件可能查找不到因为还没有加入索引中 grep ：用法grep 字符串 文件名，显示文件中包含该字符串的行，通常作为过滤器使用，如cat fstab | grep fs命令会将管道（即|）前面命令的输出作为管道后边命令的输入，前半部分命令用于输出文件全部内容，则fstab文件的所有内容作为后半部分命令的输入，最终得到fstab中包含fs的行 常用的文件操作命令 cat命令 用途：用于显示文件的所有内容；用于链接两个或多个文件 选项：-n，即–number，从1开始对所有输出行编号 举例： cat f1 f2&gt;f3会将f1和f2的内容合并起来，然后通过输出重定向符号&gt;的作用，将它们放入文件f3中。 more命令 用途：显示文件内容，每次显示一屏；按空格键显示下一屏，按enter键显示下一行内容；文件浏览完毕后自动退出；是一次性读取整个文件； less命令 用途：与more类似也用于显示文件内容，但是区别在于，less允许用户向前或向后浏览文件，而more命令只能向前浏览。less命令在开始显示之前，不必读入整个文件，是部分读取，适合用于大文件；用pageup键上翻页，用pagedown键向下翻页，退出可以按q或Q，或者:q，:Q，或者ZZ均可。 head命令 用途：用于在屏幕上显示指定文件的开头若干行，默认为前10行 用法：head [选项] [文件] 选项：-n，即–lines=N，显示指定文件的前面N行 tail命令 用途：用于在屏幕上显示指定文件的末尾部分 用法：tail [选项] [FILE] 选项： -f，当文件增长时输出附加的数据 -n，即–lines=N，输出最后的N行，而不是默认的10行 touch命令 用途：用于修改文件的时间标签（即更新文件的atime）或者创建一个空文件 用法：touch [选项] file，如果file不存在则新建一个文件；如果file已经存在则会更新文件的访问时间 file命令 用途：用于确定文件类型 用法：file [选项] 文件名 匹配、排序及显示指定内容的命令 grep命令 用途：用于在文本文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行 用法：grep [选项] 模式 [文件...] 选项：-i，即–ignore-case，匹配比较时不区分字母的大小写 sort命令 用途：用于对文本文件的各行进行排序 用法：sort [选项] [文件] uniq命令 用途：用于从排好序的文件中去除重复行，需要注意的一点是，uniq比较的是相邻的行 用法：` uniq [选项] [输入文件[输出文件]] ※文件压缩命令 Linux常见的压缩格式 filename.tar.gz（最普通） filename.tar.bz2 filename.tar.xz（最常用） .zip（通用，zip压缩包在各个系统上均可使用） filename.tar.gz 压缩：tar zcvf filename.tar.gz some_file_dirs 解压：tar zxvf filename.tar.gz (-c /路径) 解释：z选项指定了用于gz包；c选项和x选项分别指定了压缩和解压；v选项指定了需要显示详细信息，这个选项可以省略；f选项指明文件；解压命令中的-C选项可以指明解压到指定路径 filename.tar.bz2 压缩：tar jcvf filename.tar.bz2 some_file_dirs 解压：tar jxvf filename.tar.bz2 filename.tar.xz 压缩：tar Jcvf filename.tar.xz some_file_dirs 解压：tar Jxvf filename.tar.xz filename.zip 解压：unzip filename.zip 一点知识补充，其实现在微软的无论docx还是pptx格式的文件，只要这些后缀名带x的，实际上就是zip文件，是可以解压的 比较文件内容的命令 comm命令（一般不用，一般会用vimdiff） 用途：用于对两个已经排序的文件进行逐行比较 用法：comm [选项] 文件1 文件2 diff命令 用途：用来比较两个文本文件，并找出他们的不同 用法：diff [选项] 文件1 文件2 注：diff命令会生成一个patch文件，这个文件保存了两者之间的不同，相当于补丁的作用 复制、删除和移动文件的命令 ※cp命令 用途：用于将源文件或目录复制到目标文件或目录中 用法：cp [选项] 源文件或目录 目标文件或目录 选项： -v，显示拷贝的详细过程，如果不用-v则只有光标在闪烁 -R，-r，递归复制目录，即将源目录下的所有文件及其各级子目录都复制到目标位置，此时目标文件必须为一个目录名 特例： cp 目录 不存在的文件的文件名会将前边的目录复制为一个新文件夹，命名为后边的文件名 cp -r dir newdir，如果dir已经存在，会将dir放到newdir中；如果newdir不存在，会将dir复制为newdir rm命令 用途：用于删除文件或目录 用法：rm [选项] [文件] 选项： -f，即–force，忽略不存在的文件，并且不给出提示信息；但是如果是普通用户删除文件，如果没有删除某个文件的权限，那么即使加了-f也是删不掉的 -r，-R，即-recursive，递归地删除指定目录及其下属的各级子目录和相应的文件 -i，交互式地删除文件，即删除文件之前会给出提示并需要用户逐个确认，与-f相反 mv命令 用途：①对文件或目录重新命名②将文件从一个目录移动到另一个目录中 用法：mv [选项] 源文件 目标文件 解释：如果目标文件与源文件路径不同，则是移动操作；如果路径相同，就相当于是重命名操作 文件内容统计命令 wc命令 用途：用于统计指定文件的字节数、字数、行数，并将统计结果显示出来 用法：wc [选项] [文件] 选项： -c，即–bytes，统计字节数 -l，即–lines，统计行数 -m，即–chars，统计字符数 -w，即–words，统计字数 常用的目录操作命令 mkdir命令 用途：用来创建目录 用法：mkdir [选项] dirname 选项：-p，即–parents，可以一次建立多个目录，即如果为新建目录所指定的路径dirname中有些父目录尚不存在，此选项可以自动创建它们 如果要创建一个名字中带空格的文件夹，则使用mkdir &quot;a b&quot;或者mkdir a\ b rmdir命令 用途：可以从一个目录中删除一个或多个空的子目录 用法：rmdir [选项] dirname 改变工作目录和显示目录内容 cd命令 用途：用于改变工作目录 用法：cd [dirname] 几种用法： cd /绝对路径 ：cd命令可以跟一个绝对路径 cd ./相对路径 ：cd命令也可以跟一个相对路径 cd ：cd后什么都不加或者加一个空格，代表将工作目录改为用户主目录 cd ~ ：同上，代表跳回用户主目录 cd .. ：跳回上级目录，..代表上级目录 cd . ：跳回当前目录，其实相当于原地踏步。.代表当前目录 cd - ：后退一步，连续使用则会在两个工作目录之间来回跳转 关于路径的注意点：根目录的.和..是一样的；绝对路径一定是以根目录也就是/开头的 ※ls命令 用途：列出指定目录的内容 用法：ls [选项] [file] 选项： -a，即–all，显示指定目录下所有子目录和文件，包括以.开头的隐藏文件，包括.和.. -d，如果参数是目录，则只显示它的名字（不显示其内容）；往往与-l选项一起使用，以得到该目录本身的详细信息 -h，一般结合-l选项使用，使文件大小字段带有一个最合适的单位方便用户查看 -l，以长格式显示文件的详细信息，输出的信息分成多列，它们依次是：文件类型与权限 链接数 文件主 文件组 文件大小 建立或最近修改的时间 文件名，其中，链接数指的是硬链接数，文件组显示的是主组的名称，即文件所属的用户属于哪个组 例如：-rw-r–r– 2 mengqc group 809 12月 27 2008 myfile2 综上所述，ls -lha是一个很常用的命令，用于显示某个目录中所有文件的带单位的详细信息；并且，ls -l这个命令可以简写为ll ※关于ls命令中的10个表示文件类型与权限的字符头一个字符代表了文件类型，所用字符及含义如下： - 普通文件 d 即dir，目录文件 b 即block，块设备文件，一般是指能存储数据的，比如硬盘 c 即char，字符设备文件，一般是能够显示字符的，比如打印机和屏幕 l 即link，符号链接文件，也就是软链接 s 套接字文件（socket），一般网络编程会用到 p 命名管道文件（pipe），管道即”|” 随后的九个字符分为三组，每组3个字符，分别代表了三组权限：第一组代表文件所有者的读、写、执行权限；第二组表示同组用户的读、写、执行权限；第三组表示其他用户的读、写、执行权限，在权限部分会有详细讲解，其中 r 即read，读 w 即write，写 x 即execute，执行，对于目录文件则表示该目录可以访问 - 代表没有对应的权限 s 不常见 t 不常见 权限字段的组合中，rwxrwxrwx的限制是最少的，但是Linux系统中一般不会设置成这样 ln命令 用途：用来创建链接 用法：ln [选项] 源文件 [目标文件] 选项：-s，即–symbolic，建立符号链接而不是硬链接，如果要创建硬链接就不加-s 改变文件或目录存取权限的命令 chmod命令 用途：即change mode，用于改变或设置文件或目录的存取权限，但是只有文件主或超级用户root才有权用chmod命令改变文件或目录的存取权限 用法：改变文件权限有两种方法：文字设定法、数字设定法（常用） 文字设定法： 用法：chmod [who] [+|-|=] [mode] filename 例如：chmod o + r file.txt是为其他用户增加file.txt文件的读权限 操作对象who可以取的值有： u，表示“用户（user）”，即文件或目录的所有者； g，表示“同组（group）用户”，即与文件属主有相同组ID的所有用户； o，表示“其他（others）用户”； a，表示“所有（all）用户”，它是系统默认值 操作符号可以是： +，即添加某个权限； -，即取消某个权限； =，即赋予给定权限并取消其他所有权限（如果有的话）； mode所表示的权限可以是下述字母的任意组合： r，可读； w，可写； x，可执行（或可搜索目录）； X，只有该目标文件是目录文件或对某些用户有可执行权限时，才有“可执行/搜索”属性 s，在文件执行时，把进程的属主或组ID置为该文件的文件属主。方式u+s设置文件的用户ID位，g+s设置组ID位 t，受限删除标志或粘着位，即程序的文本保存到交换设备上 u，与文件属主拥有一样的权限； g，与和文件属主同组的用户拥有一样的权限； o，与其他用户拥有一样的权限； 课外知识补充计算机概括来讲可以分为几个部分硬件、软件、固件。软件分为几类：系统软件、支撑软件、应用软件。固件是安装在硬件（比如主板内）上的软件，它引导操作系统的运行。它可以完成比如开机时显示厂商的界面和设置启动顺序等的界面等。 计算机的几种状态关机；休眠：windows将内存中的文件生成镜像文件存放在一个.sys文件中；Linux系统将内存中的文件生成镜像放入交换空间中，如果交换空间大小小于内存的大小，则不支持这种模式；休眠后执行关机操作，再开机时会直接读取镜像。睡眠：可唤醒的状态。 BIOSBIOS即Basic Input Output System，基本输入输出系统。BIOS负责在系统通电时进行自检并且找到引导程序grub，grub再去硬盘上找到系统内核kernel。tips：为什么引导程序普遍使用grub而不使用Lilo：因为Lilo要求内核必须放在硬盘的1024柱前面。 区别内存与外存最直接的方法断电后数据丢失的就是内存，而断电后数据仍旧可以保存的则是外存。用这种方法可以明显得知，现在普遍流传的“手机内存”的叫法其实是错误的。 安装多系统时的安装顺序低版本→高版本，Windows→Linux。而lilo（或grub）负责多系统的引导，应当最后安装到MBR（分区表）中。 关于文件系统ISO9660 —— 光盘文件系统，其中除了存储的数据之外还有其他信息，夹带了这些信息可以用于防盗版，因为这样软件只能通过光盘安装，单纯的复制文件光盘中的内容是无法安装的。而.iso文件就相当于虚拟光盘，需要虚拟光驱来运行。FAT32 —— 此种文件系统不支持超过4G的文件，常应用在手机存储卡，win98，U盘等。NTFS —— 即NT FIle System（NT文件系统），是windows系统常用的文件系统。 windows系统相关 windows系统的内核：windows NT windows使用的文件系统：NTFS也就是NT File System Linux系统版本 Fedora是红帽9.0后可以免费使用的发行版，而rhel是9.0后为企业准备的发行版。 Android内核使用的是Linux系统 系统调用是操作系统内核与用户程序、应用程序之间的接口。在Unix/Linux系统上，系统调用以C函数的形式出现，比如用于打开一个文件的open函数。结构如下图： 服务器的内存泄漏指服务器上运行的软件不释放内存，因为服务器上运行的软件都是不经常关闭的，最后程序占用的内存会越来越大，导致内存泄漏。 其他 1752年9月没有3号-13号]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目架构学习]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[好的前端工程师和架构师一定是对数据非常敏感的，通过数据可以为用户提供更好的体验。 好的目录组织是一个好的架构的开始。每个目录要做什么事情一定要让它职责分明。除了目录组织的架构之外还有页面组织的架构。views中存放的都是视图代码，views中除了放一些页面之外，还可以将页面都共有的部分放到views/includes文件夹中，然后在其他页面中引入这些视图文件。视图页面一般不会有太复杂的逻辑关系，基本只有包含与被包含的关系，因此include中只需要平行摆放这些组件即可。当然，如果你的项目十分庞大，比如一个登录模块就有几十种，那么可以再使用文件夹来区分他们。 更高级一些的架构设计则包含了组件化和设计模式。这方面主要针对js代码，因为html和css的逻辑性并不是很强。Js中的继承和Extend是Js抽象的基础，因为js不像其他面向对象语言一样与生俱来这些功能。 Extend比如浅拷贝（适用于基本数据类型），深拷贝（使用于引用数据类型）。浅拷贝与深拷贝其实就是一个抽象出来的extend函数，使子元素具有父元素的属性。对于基本数据类型来说，就是循环复制父元素中的元素。 js中的继承，一特有的方式就是原型链继承。 划分命名空间，前端模块拆分的最基本的形式可以认为是闭包的一种应用，但是这种方式对于命名空间的管理过于随意。闭包有一个问题就是在闭包内声明的变量会常驻在内存中，因此要避免在闭包内声明过于大的变量。其实在实际项目中不会大规模的使用js的继承和扩展，一是因为项目逻辑一般不会那么复杂，二是因为一些类库为我们提供了便利，比如jQuery就提供了一个封装好的extend方法。 常用的是组件化，比如一个弹出窗口可以做成一个组件。我们可以使用开源框架来完成最终的组件的组织和管理，例如requirejs/seajs，这两个框架遵循了两种规范，一个是cmd规范，一个是amd规范，cmd指明模块是按需加载的，即依赖就近；amd则是依赖关系前置，即使用一个依赖于a,b,c三个模块的组件时，如果使用这个组件会先加载这三个模块，不管这三个模块在组件初始化的过程中用没用到。 模块化框架基本只用到两个方法，一个是define，也就是定义一个模块；一个是require，也就是使用一个模块。 前端工程师拿到交互图时应该已经能大致想到整个网站的架子是什么样的，一定要统观全局一定要考虑有哪些部分是公用的，考虑一下如何抽象出来，也就是组件化开发。 当设计图出炉后，应该考虑到api的对接，虽然不能做到百分百精确，但要有一个大概的规划要明确哪部分是静态的，哪部分是动态的，并与后台负责人员进行讨论。 通常来讲首页的性能会影响到用户的留存率，因此首页一定要认真考虑性能方面的问题。前端项目目录结构创建一个静态目录，其中包括一个css文件夹，一个js文件夹。css文件夹中可以有module文件夹，其中的css文件用于组件，如dialog.js；可以有include文件夹，其中的css用于页面公用部分，如header.css，footer.css等；可以有一个release目录，用于打包之后的文件存放在这里；css文件夹下可以有一个package.json文件来书写打包规则。script文件夹中可以存放页面的js文件，比如common.js；可以有一个widget目录，其中存放一些组件的js；可以有一个release目录，用于打包之后发布在这里；script文件夹下可以有一个package.json文件来书写打包规则。图片文件分两种情况，一种是网站上的静态图片，可以在css文件夹下面创建一个img文件夹，用于存放这些静态图片，但是不要存放太多否则会影响性能；另一种是动态读取的图片，通常是放到服务器上的。 开发实现流程规范 切图 从页面结构上来考虑，把页面中的公用部分抽象出来 从css文件上来考虑，抽象出一些公用的css，比如reset.css等 可以使用地址来访问css文件 如果前端工程要抽象出模板，那么可以有一套模板对开发者友好，有一套模板对用户友好，对用户友好的模板就可以通过自动化工具打包生成 模板用一个更简洁的形式把页面组装出来展示给用户]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基础学习笔记]]></title>
    <url>%2F2018%2F04%2F14%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础less只是一种方便程序员编写的工具，最终引用的还是css文件。可以使用软件koala进行编译，也可以使用一些IDE设置进行自动编译。 Less中的注释CSS提供 /*这个注释在Less被编译为css文件的时候会被编译*/形式的注释，而LESS又多提供了一种//这种注释不会被编译注释。 Less中的变量Less中使用@开头来声明变量，如@test_width:300px;调用时：123.box&#123; width:@test_width&#125; Less中的混合混合也就是可以将声明的一个class直接放到另一个class内部。1234567.box&#123; width:@test_width; .border;&#125;.border&#123; border:solid 5px pink;&#125; 会被编译为1234.box&#123; width:@test_width; border:solid 5px pink;&#125; 混合是可以带参数的。123456.border_02(@border_width)&#123; border: solid yellow @border_width;&#125;.test_hunhe&#123; .border_02(30px);&#125; 会被编译为123.test_hunhe&#123; border:solid #ffff00 30px;&#125; 混合的参数是可以有默认值的。123456.border_03(@border_width: 10px)&#123; border: solid gr een @border_width;&#125;.test_hunhe_03&#123; .border_03();//这里使用10px的默认值，如果要变动传一个新值即可，这个括号不能丢&#125; 混合很常用的一个地方就是在边框圆角，我们知道css设置border_radius是需要兼容的。因此可以像下面这样使用：12345678910.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 40px; .border_radius(10px);//默认是5px但这里不使用默认值改为10px&#125; 这样，每次只要调用一下border_radius并传入参数即可。 Less中的匹配模式使用CSS写三角：12345678.sanjiao&#123; width: 0; height: 0; overflow: hidden; border-width: 10px; border-color: transparent transparent red transparent;/*是个向上的三角*/ border-style: dashed dashed solid dashed; /*其实只写一个solid即可，但ie6上solid会显示出一个黑色的正方形，因此指定一个边为solid，另外均为dashed即可*/&#125; 使用匹配模式写三角：1234567891011.triangle(top,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: transparent transparent red transparent; border-style: dashed dashed solid dashed;&#125;.triangle(bottom,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: red transparent transparent transparent; border-style: solid dashed dashed dashed;&#125; 此时使用123.sanjiao&#123; .triangle(top);/*这样即可指定画出向上的三角，即第一个triangle*/&#125; 匹配模式中还提供了一个方法，可以指定所有参与匹配模式的样式共同的部分：123456.triangle(@_,@width:5px,@color:#ccc)&#123;/*后边的不可以省略*/ width: 0; height: 0; overflow: hidden;&#125;//不管匹配到谁，这段代码都会被编译出来 匹配模式用于定位：12345678910111213.pos(r)&#123; position: relative;&#125;.pos(a)&#123; position: absolute;&#125;.pos(f)&#123; position: fixed;&#125;.test&#123; width: 200px; .pos(a);&#125; 其实这样匹配模式看来有些类似于Java中的多态。 Less中的运算比如123456@test_01: 300px;.box_01&#123; width: (@test_01 + 20) * 5;//因为@test_01带有了单位px，因此后边的20和5可以不需要带单位。&#125;//Less规定一个式子中只要有一个数字带了单位，其他的数字便会自动转化。 Less中的颜色也是可以加减的，但一般不会用到。 Less中的嵌套比如有下面这样的一段html代码1234567&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 如果是平时写css，可能会用以下方式来规定样式：1234.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125; 但如果使用了Less中的嵌套，就会变成下面这样：12345678910111213.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125;&#125; 此时a的样式可以写在两个位置，第一种写法是a被li包裹在里面，和html结构完全一致：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; a&#123; float:left; &#125; &#125;&#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list li a &#123; float:left;&#125; 第二种写法是a与li同级：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125; a&#123; float:left; &#125; &#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list a &#123; float:left;&#125; 因为.list li a的匹配次数会多于.list a，因此我们提倡将a写为与li同级。 关于嵌套还有一个例子，就是css中常见的a:hover，原本的写法是：12.list a&#123;&#125;.list a:hover&#123;&#125; 现在可以写为：12345678910.list &#123; ... a &#123; ... &amp;:hover&#123; color:red; &#125; &#125;&#125; &amp;符号代表的是上一层的选择器，在这个例子中指代的就是a如果html结构上有两个class是互相嵌套的，比如外层调用class为title，内层调用的class为title_nav，则可以在嵌套中使用&amp;_nav来代表title_nav。 Less中的@arguments变量@arguments变量用的其实不是特别特别多，它包含了所有传递进来的参数，如果不想单独处理每个参数的时候就可以这样写。比如：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg();&#125; 此时arguments会自动匹配所有参数，也就会编译成：123.test_arguments&#123; border: 30px #ff0000 solid;&#125; 如果稍加修改：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg(40px);&#125; 则此时arguments也会自动执行对应的更改，即会编译成：123.test_arguments&#123; border: 40px #ff0000 solid;&#125; 这就是arguments，如果一个属性的值全部都要改动的时候可以这样使用。 Less的避免编译有时候我们需要输出一些不正确的CSS语法或者使用一个Less不认识的专有语法，要输出这样的值我们可以在字符串前面加上一个~。比如CSS3中的滤镜，calc函数等都可能遇到这种情况，示例如下：123.test_03&#123; width: calc(300px - 30px);&#125; 此时会直接编译成：123.test_03&#123; width: calc(270px);&#125; 这种情况就是，我们本意是想要浏览器来计算这个值的，可是现在被Less直接计算了，此时就可以使用避免编译，让Less不要进行计算，留给浏览器计算。代码如下：123.test_03&#123; width: ~&apos;calc(300px - 30px)&apos;;//单引号双引号都行&#125; 此时会编译为：123.test_03&#123; width: calc(300px - 30px);&#125; 一般用于CSS3中的calc或滤镜，避免软件出现一些不必要的错误，或者执行一些不必要的运算。 !important关键字css中的important是让样式的优先级最高。Less中的混合模式实际上也可以加important关键字。比如之前写过的border_radius，我们可以为它加上important关键字：12345678.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.test_important&#123; .border_radius()!important;&#125; 这样可以编译为：12345.test_important&#123; -webkit-border-radius: 5px !important; -moz-border-radius: 5px !important; border-radius: 5px !important;&#125; 这个可以在调试的时候使用，一般是不要用important关键字比较好。 Less中的导入使用@import &quot;less&quot;会导入less.less文件，可以用加拓展名使用@import (less) &quot;a.css&quot;会导入a.css文件的样式，注意导入css的时候这句import写在哪，编译的时候a.css中的样式就会出现在哪，因此如果要让它在最前面就要把import写在最前面。如果写成@import &quot;a.css&quot;，则less不会将里面的样式内容拿出来，编译为css文件的时候会编译为一个导入的css即css文件中的@import &quot;a.css&quot;。因此需要使用(less)对它进行转换。 其他小知识点补充 如果子元素浮动，父元素必须清楚浮动才能有高度，否则父元素高度为零。一定要注意！ 使用CSS父元素清除浮动： 12345678.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; 这样再在父元素上调用clearfix类即可。 如果是在Less中，则代码如下： 12345678.clearfix&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix; 这种写法编译css文件的时候会吧clearfix编译出来，如果不想这样做可以写成以下方式： 12345678.clearfix()&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix();，其实父元素加不加括号都可以，这样做只是为了能够方便区分这里到底是个混合还是单纯引入了一个css。 兼容IE6的清除浏览器自带样式的方式： 1234*&#123;margin:0;padding:0;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration: none;&#125;img&#123;border:none;&#125;//因为ie6下图片默认是有边框的 使用less还可以将浮动写为： 12345678.fl(@fl:left)&#123; float: @fl; display: inline;&#125;.fr(@fr:right)&#123; float: @fr; display: inline;&#125; 调用时使用.fl()或.fr()调用即可]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F14%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础操作部分初始化git init 将修改提交到暂存区git add tips：使用git add .可以将当前工作区中的所有存在修改的文件一次性全部提交到暂存区 将暂存区提交到版本库git commit -m “commit message” 跳过暂存区，直接把工作区的修改提交到版本库git commit -a -m “commit message” 查看工作区状态git status 查看工作区修改内容，也就是查看工作区与暂存区的区别git diff 恢复到指定id的版本git reset -hard 查看提交历史git log 查看格式化后的提交历史git log –pretty=oneline 可以查看所有分支的所有操作记录（包括提交、回退、已删除的提交操作记录等）git reflog 查看工作区和版本库里面最新版本的区别git diff HEAD –reaadme.txt 切换分支或恢复工作树文件git checkout 切换到一个指定分支： git checkout 分支名称 创建并切换到新的分支中： git checkout -b 分支名称 撤销修改： git checkout – 一种情况是文件修改后还没有放到暂存区，此时撤销修改也就是回到了版本库中的状态。即，上一次git commit后，修改了文件，但没有执行git add，回到上一次git commit时的状态。 第二种情况是文件已经添加到了暂存区，又做了修改，此时撤销修改就回到了添加到暂存区时的状态。即，修改了文件，并且执行了git add，然后又修改了文件，此时会撤销到git add时的状态。 撤销暂存区的修改，但不修改工作区git reset HEAD 从版本库中删除文件git rm 远程仓库部分创建SSH Keyssh -keygen -t rsa -C “email@mail.com“ 创建与远程仓库的关联git remote add origin git@github.com:Fnine59/project_name.git tips: origin是远程仓库的名字 把本地库的所有内容都推送到远程库git push -u origin master tips: 第一次推送master分支时加上-u参数，则不仅会将本地的master分支推送到远程仓库中的master分支，还会将它们相互关联起来，这样以后推送或拉取时就可以简化命令了。 从远程仓库克隆项目git clone git@github.com:Fnine59/project_name.git (SSH协议形式) git clone https://github.com/Fnine59/project_name.git (HTTP协议形式) 从远程仓库拉取数据git fetch 查看远程仓库信息git remote git remote -v (查看远程库的详细信息) git remote show (更详细一些) 远程仓库重命名git remote rename 分支操作部分分支操作规范1234567master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 创建并切换到example分支git checkout -b 查看分支git branch 创建example分支git branch 切换到example分支 git checkout 合并指定分支到当前分支git merge 删除example分支git branch -d 查看分支的合并情况git log –graph –pretty=oneline -abbrev -commit 查看分支合并图git log –graph 采用普通模式合并指定分支到当前分支git merge –no-ff -m “使用普通模式合并分支” 本地分支操作部分保存工作区现场，操作完其他后可以恢复工作区继续工作git stash 恢复保存的工作区现场，但是恢复后不删除stash内容git stash apply 删除保存的工作区现场git stash drop 恢复保存的工作区现场，同时删除stash内容git stash pop 强行删除分支git branch -D 远程分支操作部分将master分支推送到远程库对应的远程分支git push origin master 从远程仓库抓取分支git pull 建立本地example分支和远程example分支的关联git branch –set -upstream origin/ 标签操作部分新建标签git tag 根据提交的id创建带说明的标签git tag -a -m “tag message” commit id 查看所有标签git tag 查看的标签信息git show 推送一个本地标签到远程仓库中git push origin 推送本地所有未推送过的标签到远程git push origin –tags 删除标签git tag -d 删除远程标签git push originn :refs/tags/ 文件恢复从暂存区恢复文件到工作区可以使用 git checkout . 或 git checkout --&lt;file&gt;命令 从版本库恢复文件到工作区和暂存区使用 git checkout HEAD . 或 git checkout HEAD &lt;file&gt;命令，会从HEAD指向的master分支中的全部或部分文件来替换暂存区以及工作区中的文件 从版本库恢复提交到暂存区git reset –soft 从版本库恢复提交到暂存区和工作区，等同于checkout HEAD .git reset –hard]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%85%B3%E4%BA%8EJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Class类的使用Java中其实有两种东西不是对象，一个是普通的数据类型（但有包装类来弥补了），另一个是Java中静态的成员。Java中的类其实也是对象，它是java.lang.Class类的实例对象。 既然任何一个类都是Class类的实例对象，那么Class类的实例对象应该如何表示呢？ 通过查看Class类的源代码可以知道，它具有一个私有的构造方法，在类的外部无法直接调用。因此我们无法使用new关键字来直接表示Class类的实例对象。 现假设有一个类名为Foo的类，并且通过new关键字实例化了一个Foo类的对象foo1，现有三种表示方式来表示这个Class类的实例对象Foo： * `Class c1 = Foo.class;` 这种表示方式实际在告诉我们任何一个类都有一个隐含的静态成员变量class。 * `Class c2 = foo1.getClass();` 已经知道该类的对象，通过getClass方法获取 * `Class c3 = null; c3 = Class.forName(&quot;com.fnine59.reflect.Foo);` * 根据官网的解释，**c1，c2表示了Foo类的类类型（class type）**，证明万事万物皆对象，类也是对象，是Class类的实例对象，这个对象我们称为该类的类类型。 * **不管用c1，c2或c3哪种表达方式都表示了Foo类的类类型，它们是相等的，因为一个类只能是Class类的一个实例对象。** 我们完全可以通过类的类类型来创建该类的对象实例，即通过c1或c2或c3来创建Foo类的实例。可以使用Foo foo = (Foo)c1.newInstance();来创建Foo类的实例。这种办法需要该类有无参的构造方法。 Java动态加载类编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（DOM篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88DOM%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建节点与属性处理 $(&quot;html结构&quot;)可以创建出来，例如$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)，如果要指定属性，则$(&quot;&lt;div id=&#39;test&#39; class=&#39;aaron&#39;&gt;我是文本节点&lt;/div&gt;&quot;)即可。 DOM内部插入append()与appendTo() .append(content)向每个匹配id元素内部追加内容 .appendTo(content)把所有匹配的元素追加到另一个指定的元素集合中 这个方法可以使得创建的新节点显示在文档中，将新创建的元素当作页面某一个元素的子元素放到其内部即可。 append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。 appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。 区别：append()前面是被插入的对象，后面是要在对象内插入的元素内容；appendTo()前面是要插入的元素内容，而后面是被插入的对象 DOM内部插入prepend()与prependTo() .prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素。 .prependTo()方法把所有匹配的元素前置到另一个指定的元素集合中。 DOM外部插入after()与before() 内部插入着重于节点之间的父子、祖辈关系；而外部插入着眼于节点之间的兄弟关系。 .after(content)方法在匹配元素集合中的每个元素后插入参数指定的内容，作为其兄弟节点。 .before(content)方法按参数设定，在匹配元素的前面插入内容。 DOM外部插入insertAfter()与insertBefore() .insertBefore()方法在目标元素前面插入集合中每个匹配的元素 .insertAfter()方法在目标元素后面插入集合中每个匹配的元素 注意：after和before方法都是将要插入的内容作为参数，而insertBefore和insertAfter方法则相反，要插入的内容在方法前面。 删除节点 empty() empty方法用于清除指定元素中的所有子节点 remove() remove方法与empty方法一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 remove方法可以传参，比如$(&quot;p&quot;).remove(&quot;:contains(&#39;3&#39;)&quot;)，意思是找到所有p元素中，包含了3的元素，这个也是一个过滤器的处理。可以通过类似于$(&quot;p&quot;).filter(&quot;:contains(&#39;3&#39;)&quot;).remove()的方式进行处理。 detach() 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理。 可以使用一个变量接收detach方法的返回值，当执行完detach方法后会移除对象，但仅仅是显示效果没有了，在内存中还是存在的，可以使用append(刚才接收返回值的变量)将元素重新放回文档流中。这时可以发现该元素绑定的事件仍然生效。 DOM拷贝clone() clone方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 注意：如果节点有事件或者数据之类的其他处理，我们需要通过clone(true)传递一个布尔值true用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。 clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色。 DOM替换replaceWith()和replaceAll() .replaceWith(newContent)用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。 .replaceAll(target)用集合的匹配元素替换每个目标元素。 注意：这两个方法都会删除与节点相关联的所有数据和事件处理程序。 DOM包裹 wrap()方法 .wrap(wrappingElement)在集合中匹配的每个元素周围包裹一个HTML结构 .wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。使用后的效果与直接传递参数是一样的，只不过可以把代码写在函数体内部，写法不同而已。 unwrap()方法 这个方法与wrap的方法是相反的，将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在的话）在原来的位置。 wrapALl()方法 .wrapAll(wrappingElement)：给集合中匹配的元素增加一个外面包裹的HTML结构。 这个方法同样有.wrapALl(function)的写法，通过回调的方式可以单独处理每一个元素，等同于wrap的处理。 wrapInner()方法 .wrapInner(wrappingElement)：给集合中匹配的元素的内部增加包裹的HTML结构。 例子： 12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 给所有元素增加一个p包裹 1$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;) 最后的结构 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 此方法也有.wrapInner( function )的写法，允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行并返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。效果等同于第一种处理。 jQuery的遍历 children()方法 用于快速查找元素合集里面的第一级子元素。由于jQuery是一个合集对象，所以通过children是匹配合集中每一个元素的第一级子元素。同时也因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，因此允许传一个选择器的表达式。比如$(&#39;.div&#39;).children(&#39;:last&#39;)。 find()方法 find是遍历当前元素集合中每个元素的后代，不仅是儿子，祖孙辈也可以。 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 *。 find只在后代中遍历，不包括自己。 parent()方法 用于快速查找合集里面每一个元素的父元素。 jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素。同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 parents()方法 用于快速查找合集里面每一个元素的所有祖辈元素。 也有无参或带参两种使用方法。 closest()方法 该方法从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。closest()方法接受一个匹配元素的选择器字符串。 与parents方法类似，但还是有些区别： 起始位置不同：.closest开始于当前元素 .parents开始于父元素 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 next()方法 用于快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合。 next()无参数：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素。 next()方法选择性地接受同一类型选择器表达式： 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 prev()方法 用于快速查找合集里面每一个元素紧邻的前面同辈元素的元素集合。 prev方法也有无参和有参两种用法。 siblings()方法 用于快速查找指定元素集合中每一个元素的同辈元素 此方法也有也有无参和有参两种用法。 add()方法 用来创建一个新的jQuery对象，元素添加到匹配的元素集合中。 each()方法 .each()方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始计数）。 例子： 1234&lt;ul&gt; &lt;li&gt;慕课网&lt;/li&gt; &lt;li&gt;Aaron&lt;/li&gt;&lt;/ul&gt; 以上是结构，现在开始迭代li，循环2次···$(“li”).each(function(index, element) { //index 索引 0,1 //element是对应的li节点 li,li //this 指向的是li //如果需要提前退出，可以以通过返回 false以便在回调函数内中止循})`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（基础篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[jQuery版本进入官方网站获取最新的版本http://jquery.com/download/，这里需要注意 jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于 2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。由于减少了一些代码，使得该版本比 jQuery 1.x 更小、更快。 $(document).ready 等页面的文档(document)中的节点都加载完毕后，再执行后续代码。 jQuery对象和DOM对象的转换 jQuery-&gt;DOM：jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。可以利用数组下标的方式读取到jQuery中的DOM对象。 DOM-&gt;jQuery：如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象。通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了。 选择器 id选择器 语法：$( &quot;#id&quot; ) 注意：id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的。 类选择器 语法：$( &quot;.class&quot; ) 元素选择器（根据给定的标记名称选择所有的元素） 语法：$( &quot;element&quot; ) 全选择器 语法$( &quot;*&quot; ) 层级选择器 &gt; （大于号）紧跟父子关系 如$(“div &gt; p”)表示选择div下的直接层是p的节点。 + （加号） 紧跟兄弟关系 如$(“div + p”)表示选择div同层的左右相邻的p节点。 ~ （波浪线）任意距离兄弟关系 如$(“div ~ p”)表示选择div同层的p节点。 （空格） 任意层父子关系 如$(“div p”)表示选择div下的p节点（不管中间隔多少层）。 , （逗号） 表示选择器组合，如$(“div p, span p”)表示div下p节点和span下p节点。 基本筛选选择器 注意jQuery合集都是从0开始索引 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 可见性筛选选择器 $(&quot;:visible&quot;) 选择所有显示的元素 $(&quot;:hidden&quot;) 选择所有隐藏的元素 注意：:hidden选择器，不仅仅包含样式是display=”none”的元素，还包括隐藏表单、visibility等等。 隐藏一个元素的方法有以下几种 CSS display的值是none type=”hidden”的表单元素 宽度和高度都显式设置为0 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 属性筛选选择器 属性选择器让你可以基于属性来定位一个元素，可以只指定该元素的某个属性，这样所有使用该属性而不管它的值，这个元素都将被定位，也可以更加明确并定位在这些属性上使用特定值的元素。 描述如下： 在这么多属性选择器中[attr=&quot;value&quot;]和[attr*=&quot;value&quot;]是最实用的，[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等。[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件。 表单元素选择器 具体方法描述： 注意：除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。因此大部分表单类别筛选器可以使用属性筛选器替换。比如 $(&#39;:password&#39;) == $(&#39;[type=password]&#39;) 表单对象属性筛选选择器 具体方法描述： 注意：选择器适用于单选框和复选框，对于下拉框元素应该使用:selected选择器。在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素。 特殊选择器this **this和$(this)的区别： this是JavaScript中的关键字，指的是当前的上下文对象，简单地说就是方法/属性的所有者。 $(this)：通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法直接处理样式了。 总结来说，this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 jQuery的属性与样式 .attr()与.removeAttr() .attr() attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } .removeAttr()删除方法：为匹配的元素集合中的每个元素中移除一个属性（attribute） 注意区分Attribute和Property的概念，property是DOM中的属性，是JavaScript里的对象，例如tagName，nodeName，nodeType，defaultChecked，和 defaultSelected等；而attribute是HTML标签上的特性，它的值只能够是字符串；例如html中常用的id、class、title、align等。 获取Attribute就需要用.attr()，获取Property就需要用.prop() .html()与.text() .html()方法获取集合中第一个匹配元素的html内容，或者设置每一个匹配元素的html内容，具体有3中用法如下： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 注意：因为.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） .text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .text()结果返回一个字符串，包含所有匹配元素的合并文本 .val() .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function )，一个用来返回设置值的函数 .html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 .addClass()与.removeClass() .addClass()方法通过动态改变类名（class），可以让其修改元素呈现出不同的效果。用法如下： .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ): 这个函数返回一个或更多用空格隔开的要增加的样式名 注意：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上。 .removeClass()方法从匹配的元素中删除全部或者指定的class，用法如下： .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) )： 一个函数，返回一个或多个将要被移除的样式名 注意：如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。 .toggleClass()样式切换 通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass。用法如下： .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名。 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意：toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加。并且，toggleClass会保留原有的Class名后新增，通过空格隔开。 .css() 用于获取元素样式属性的计算值或者设置元素的CSS属性。用法如下： 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 通过.css方法设置的样式属性优先级要高于.addClass方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记及技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面马上要面试了，重新温习一下基础，把慕课网上的前端工程师课程走了一遍，整理了一些平时不太注意到的、或是个人印象不够深刻的JavaScript相关知识，希望可以巩固一下自己的印象。也能保证自己随时可以查看这些笔记。 关于大小写JS是大小写敏感的 document.write()直接向HTML输出流写内容，也将就是直接在网页中输出内容。如果要使用write方法输出一个HTML标签，则要使用&quot;&quot;将标签扩起来。 confirm对话框alert()对话框经常被用于调试程序，它包含一个确定按钮。而confirm对话框包括一个确定按钮和一个取消按钮，通常用于允许用户做选择的动作，语法为confirm(str);。confirm的返回值，当用户点击“确定”按钮时，返回true；当用户点击“取消”按钮时，返回false。可以定义一个变量来接收confirm的返回值。 prompt消息对话框除了上述两种对话框，还有一种prompt消息对话框。它通常用于询问一些需要与用户交互的信息。弹出的消息对话框包括一个确定按钮，一个取消按钮和一个文本输入框。语法为prompt(str1, str2);，其中str1是要显示在消息对话框中的文本，对用户来说是不可修改的；str2是文本框中的内容，用户是可以修改的。prompt的返回值，如果用户点击确定按钮，那么文本框中的内容将作为函数返回值；如果用户点击取消按钮，则返回null。 window.open()可以查找一个已经存在或者新建的浏览器窗口。语法window.open([URL], [窗口名称], [参数字符串]) window.close()用于关闭窗口。直接调用则关闭本窗口，使用&lt;窗口对象&gt;.close()则可以关闭指定的窗口。窗口对象可以是在打开窗口时建立一个变量进行存储。 Object.innerHTML用于获取或是替换HTML元素的内容。Object是获取的元素对象，比如通过document.getElementById(&quot;ID&quot;)获取的元素。 改变HTML样式使用Object.style.property = new style;来改变HTML元素的样式。注意，property是CSS样式属性，new style是属性的新值。 显示和隐藏语法：Object.style.display = value 控制类名（className属性）className属性设置或返回元素的class属性。语法：Object.className = classname 创建数组var arrayname = new Array()可以用来创建一个数组。创建的新数组是空数组，没有值，如输出，则显示undefined。并且，虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度，仍然可以将元素存储在规定长度以外。 函数传参js属于弱类型语言，所以在定义方法传入参数的时候并不需要指定其类型。 事件 鼠标点击事件onmouseclick 鼠标经过事件onmouseover 鼠标移开事件onmouseout 光标聚焦事件onfocus 失去焦点事件onblur 内容选中事件onselect（当文本框或者文本域中的文字被选中时触发） 文本框内容改变事件onchange 加载事件onload（该事件在页面加载完成后立即发生，如果不使用js代码则写在body标签中） 卸载事件onunload（用户退出页面时触发，比如页面关闭、页面刷新等） 时间 Date日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000秒）。定义时间对象的语法为：var Udate = new Date() 日期对象提供了以下方法： 返回/设置年份方法get/setFullYear() getDay()返回星期（返回是0-6的数字，其中0表示星期天） get/setTime()返回/设置时间方法（单位为毫秒数，计算从1970年1月1日零时到日期对象所指的日期的毫秒数，即时间戳） 字符串对象 .length可以获取字符串对象的长度 toLowerCase()方法可以将所有大写字母都转为小写字母 toUpperCase()方法则可以将所有小写字母转换为大写字母 charAt()方法返回指定位置的字符 indexOf方法返回指定的字符串首次出现的位置 split()方法分割字符串为字符串数组并返回（两个参数，第一个参数separator必需，用来指定分隔符；第二个参数limit可选，用来指定分割次数） substring()方法用于提取字符串中介于两个指定下标之间的字符（指定开始位置的参数必需，指定结束位置的参数可选） substr()方法从字符串中提取从startPos位置开始指定书目的字符串，语法：stringObj.substr(startPos,length)，其中length可选，默认值到字符串结尾 Math对象 ceil()函数用于对一个数向上取整，返回的是一个大于或等于x并且与x最接近的整数，语法Math.ceil(x) 向下取整函数floor()，语法Math.floor(x)，返回的是一个小于或等于x并且与x最接近的整数 四舍五入函数round()，语法Math.round() 随机数random()，可以返回一个大于等于0但小于1的随机数，语法Math.random() 数组对象 concat()方法用于连接两个或多个数组，语法：arrayObject.concat(array1,array2...arrayN)此方法返回一个新数组，不改变原来的数组 join()方法用于把数组中的所有元素都放入一个字符串，元素是通过指定的分隔符进行分隔的，语法arrayObject.join(分隔符)，该方法返回一个字符串 reverse()方法用于颠倒数组中元素的顺序，该方法会改变原来的数组而不会创建新数组 slice()方法可以从已有的数组中返回选定的元素，语法arrayObject.slice(start,end)，其中start参数必需，end参数可选，默认到数组结束，该方法返回一个新的数组，包括从start到end（不包括end）的arrayObject中的元素，不会修改原有数组 sort()方法使数组中的元素按照一定的顺序排列，语法arrayObject.sort(方法函数名)，如果不规定方法函数，则按unicode码顺序排列，如果指定方法函数，则按方法函数所指定的排序方法进行排序，这个方法函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数a和b，其返回值如下： 若返回值&lt;=-1，则表示a在排序后的序列中出现b之前 若返回值&gt;-1&amp;&amp;&lt;1，则表示a和b具有相同的排序顺序 若返回值&gt;=1，则表示a在排序后的序列中出现在b之后 计时器 计时器有两种： 一次性计时器，仅在指定的延迟时间之后触发一次 间隔性触发计时器，每隔一定的时间间隔就触发一次 setInterval()计时器执行时，从载入页面后每隔指定的时间执行代码，语法setInterval(代码, 交互时间);，其中，交互事件的单位是毫秒。 clearInterval()方法用于取消由setInterval()设置的交互时间，语法clearInterval(id_of_setInterval)，传入的id_of_setInterval是由setInterval()返回的ID值，可以使用一个变量来接收这个值。 setTimeout()计时器，在载入后延迟指定时间后，去执行一次表达式并且只执行一次，语法setTimeout(代码, 延迟时间);，其中延迟时间以毫秒为单位。 clearTimeout()计时器，和setTimeout()计时器一起使用，用于停止计时器，语法clearTimeout(id_of_setTimeout)，其中传入的id_of_setTimeout是由setTimeout()返回的ID值，可以使用一个变量来接收这个值。 History对象 history对象记录了用户曾经浏览过的页面（URL），并可以实现与浏览器前进和后退相似的功能。 注意：从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签乃至每个框架，都有自己的history对象与特定的window对象关联。 语法window.history.[属性|方法]，其中window可以省略。 属性：length，返回浏览器历史列表中的URL总数量。 方法： back()，用于加载history列表中的前一个URL。back()相当于go(-1)。 forward()，用于加载history列表中的后一个URL。forward()相当于go(1)。 go()，用于加载history列表中某个具体的页面，语法window.history.go(number);，其中number是指要访问的URL在history的URL列表中的相对位置，比如返回当前页面之后浏览过的第三个历史页面，number为3；返回当前页面之前浏览过的第二个历史页面，number为-2。 Location对象 location对象用于获取或设置窗体的URL，并且可以用于解析URL。 语法location.[属性|方法] location对象属性示意图： location对象方法： assign()，用于加载新的文档 reload()，重新加载当前文档 replace()，用新的文档替换当前文档 Navigator对象 navigator对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 语法navigator.属性 属性如下 userAgent 用于返回用户代理头的字符串表示，就是包括浏览器版本信息等的字符串 语法navigator.userAgent screen对象 screen对象用于获取用户的屏幕信息。 语法window.screen.属性 属性如下： window.screen对象还包含有关用户屏幕的信息 screen.height返回屏幕分辨率的高 screen.width返回屏幕分辨率的宽 注意，单位以像素计，window这个前缀可以省略。 availwidth和availHeight属性是可用的宽度和高度，会减去界面特性，如任务栏。 文件对象模型DOM getElementsByName()方法返回带有指定名称的节点对象的集合。 语法：document.getElement**s**ByName(name) 与getElementById()不同的地方在于这个方法使通过元素的name属性查询元素而不是通过id属性。 因为文档中的name属性有可能不唯一，所以这个方法返回的是元素的数组而不是一个元素。 getElementsByTagName()方法返回带有指定标签名的节点对象的集合，返回元素的顺序是它们在文档中的顺序。 语法document.getElement**s**ByTagName(Tagname) Tagname是标签的名称，如p，a，img等标签名。 getAttribute()方法通过元素节点的属性名称获取属性的值。 语法elementNode.getAttribute(name) elementNode是通过上述几个方法获取到的元素节点。 setAttribute()方法增加一个指定名称和值的性属性，或者把一个现有的属性设定为指定的值。 语法elementNode.setAttribute(name,value) 类似getAttribute()方法，此方法也是只能通过元素节点对象调用的函数。 节点属性： 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称，是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue ：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 nodeType ：节点的类型，是只读的。以下常用的几种结点类型 元素 -&gt; 1 属性 -&gt; 2 文本 -&gt; 3 注释 -&gt; 8 文档 -&gt; 9 childNodes用于访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，具有length属性。 语法elementNode.childNodes 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 firstChild属性返回‘childNodes’数组的第一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.firstChild firstChild属性与elementNode.childNodes[0]效果相同。 lastChild属性返回‘childNodes’数组的最后一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.lastChild lastChild属性与elementNode.childNodes[elementNode.childNodes.length-1]效果相同。 parentNode用于获取指定节点的父节点 语法elementNode.parentNode 父节点只能有一个 访问兄弟节点 nextSibling属性可以返回某个节点之后紧跟的节点（处于同一树层级中） 语法nodeObject.nextSibling 如果无此节点，则该属性返回null previousSibling属性可以返回某个节点之前紧跟的节点（处于同一树层级中） 语法nodeObject.previousSibling 如果无此节点，则该属性返回null 插入节点 appendChild()用于在指定节点的最后一个子节点列表之后添加一个新的子节点 语法appendChild(newnode) 例子： 1234var otest = document.getElementById(&quot;test&quot;);var newnode = document.createElement(&quot;p&quot;);newnode.innerHTML = &quot;This is a new p&quot;;otest.appendChild(newnode); 注意：应当由父节点来调用这个方法 insertBefore()方法用于在已有的子节点之前插入一个新的子节点 语法insertBefore(newnode,node); 例子： 1234var otest = document.getElementById(&quot;test&quot;); var newnode = document.createElement(&quot;li&quot;);newnode.innerHTML = &quot;PHP&quot;;otest.insertBefore(newnode,otest.firstChild); 注意：应当是父节点来调用这个方法，并定义在某个子节点之前插入新节点 删除节点 removeChild()方法用于从子节点列表中删除某个节点，如果删除成功，此方法返回被删除的节点，如果删除失败则返回NULL。 语法nodeObject.removeChild(node); 注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值，代码如下: 123var otest = document.getElementById(&quot;div1&quot;);var x = otest.removeChild(otest.childNodes[1]);x = null; 替换元素节点 replaceChild方法实现子节点（对象）的替换，返回被替换对象的引用。 语法node.replaceChild(newnode,oldnode) 注意，两个参数都是必须的，当oldnode被替换时，所有与之相关的属性内容都将被移除，并且newnode必须先被建立。 需要父节点调用这个方法，因此可以使用oldnode.parentNode.replaceChild(newnode,oldnode);来进行替换。 创建元素节点 createElement()方法可以创建元素节点，此方法可以返回一个element对象。 语法document.createElement(tagName); createTextNode()方法创建新的文本节点，返回新创建的Text节点。 语法document.createTextNode(data); 参数：data是字符串值，可以规定此节点的文本。 注意：innerHTML和createTextNode都可以把一段内容添加到一个节点中，区别是如果这段内容中有html标签（如例子中的）时表现就不同了，在createTextNode中会当作文本处理，不会被浏览器解析，但用innerHTML就会被当作HTML代码处理（如你的例子中Hello会被加粗显示）。 例子： 1234var element = document.createElement(&quot;p&quot;);var textnode = document.createTextNode(&quot;I love Javascript!&quot;);element.appendChild(textnode);document.body.appendChild(element); 浏览器窗口可视区域大小 获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： 直接求 document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者Document对象的body属性对应HTML文档的标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 12var w= document.documentElement.clientWidth(或 document.body.clientWidth);var h= document.documentElement.clientHeight(或 document.body.clientHeight); 网页尺寸 scrollHeight和scrollWidth，分别用于获取网页内容的高度和宽度 针对IE、Opera:scrollHeight 是网页内容实际高度，可以小于 clientHeight。 针对NS、FF:scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 浏览器兼容写法 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写。并且，scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 offsetHeight和offsetWidth，分别用于获取网页内容的高度和宽度（包括滚动条和等边线，会随窗口的显示大小改变） 值：offsetHeight = clientHeight + 滚动条 + 边框。 浏览器兼容性1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; height、clientHeight、scrollHeight、offsetHeight区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于Node.js Node.js适合高并发、低负载、弱逻辑的项目，适合做如dataAPI或聊天系统等实时性要求比较高的项目。 关于HTML 渲染顺序 HTML文档是从上向下渲染的，因此同一区块有些不重要的内容可以适当往后放，让重要内容先被加载出来（本条是对于结构来讲，也就是对于HTML语言来讲，不涉及表现CSS或行为JS）。 结构与表现分离 前端开发时要注意结构与表现分离，在编写前端页面的过程中，要先从结构考虑，争取做到结构最简，避免有过多不必要的div。当结构编写完后，再考虑表现，也就是CSS样式。通过这种结构与表现分离的思想，争取做到修改业务逻辑时，只需要改动样式，而不需要改动结构。 如何让一段文本向右移动？ 当然可以采取margin或padding的形式将文字元素推到右边，但这样做会造成外部容器的宽度发生变化，就需要再次修改外部容器的宽度。此时，最理想的操作方法应该是使用text-indent属性，来设置文本缩进，它不会影响外部容器的宽度，也可以设置百分比，简洁易用。 背景图片 元素的背景，比如导航栏圆角背景，可以将普通状态下的背景（如灰色）与hover状态下的背景（如橙色）做在同一张图上，上下排列并掌握好宽和高。这样可以给默认状态下的导航栏菜单项（即display属性值为block的a标签）设置这张背景图，通过长宽来确保背景为灰色。当该菜单项处于hover状态或选中状态时，添加class并设置该菜单项的background-position属性，来使背景图向上移动，显示出之前拼接好的橙色背景来。 导航栏的制作 导航栏的结构均为&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;这样的无序列表，如果是竖向导航栏则无需float，如果是横向导航栏则可以设置li标签的float属性的值为left或right。 js代码中的window.onload 是为了让dom加载完毕之后再执行以下代码。jquery的$(function)(){}相当于js中的window.onload，并且比window.onload性能要好。 关于语义 &lt;q&gt;&lt;/q&gt;标签会在html文档中显示为双引号，但使用标签的主要目的并不是为了显示双引号，这样还不如直接输入双引号。它的目的是它的语义：引用别人的话。还有一个引用标签&lt;blockquote&gt;&lt;/blockquote&gt;，浏览器对它的解释是缩进样式，表示引入长文本。 一些HTML标签 &lt;hr /&gt;标签用于添加一条水平横线。 &lt;em&gt;&lt;/em&gt;标签用于斜体。 &lt;address&gt;&lt;/address&gt;用于显示地址，浏览器默认样式是斜体，当然也可用通过css来修改。 插入代码使用&lt;code&gt;标签如：&lt;code&gt;代码语言&lt;/code&gt; &lt;pre&gt;&lt;/pre&gt;标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。可以使用这个标签来包裹大段代码。 可以对&lt;table&gt;标签进行一些优化，&lt;caption&gt;表格标题&lt;/caption&gt;可以指定表格的标题，&lt;table summary=&quot;表格简介文本&quot;&gt;，这里的简介不会在浏览器显示出来，是为了增加表格的可读性（语义化）。 &lt;a&gt;除了常见的功能之外，标签还有一个功能是可以用来链接Email地址，使用mailto可以使访问者便捷的向网站管理者发送电子邮件，这样点击a链接时会打开电子邮件应用，并自动填写收件人等设置好的信息。具体用法如图 img标签可以通过title属性指定鼠标滑过图片时显示的文本。图片格式可以是gif，png，jpg，jpeg等。 在&lt;select&gt;标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 表单的重置按钮，可以通过设置input标签的type值为reset来实现。 label标签：label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。语法：&lt;label for=&quot;控件id名称&quot;&gt;。例子： 123456789&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;br /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;female&quot; /&gt; &lt;label for=&quot;email&quot;&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt;&lt;/form&gt; 可以为span标签添加属性white-space:pre;，这个样式表示空白会被浏览器保留。 css几种设置方法的优先级 12345671. 内联样式表的权值最高 10002. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 CSS 优先级法则： 123456789A 选择器都有一个权值，权值越大越优先B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式D 继承的CSS 样式不如后来指定的CSS 样式E 在同一组属性设置中标有“!important”规则的优先级最大 ID选择器只能在文档中使用一次。可以使用类选择器词列表方法为一个元素同时设置多个样式，ID选择器是不可以的。 子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。二者的区别在于：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通配选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素。 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（,）。 有些特殊的情况需要为某些样式设置具有最高权值，这时候我们可以使用!important来解决。如：p{color:red!important;}。注意：!important要写在分号的前面。 text-decoration可以用于设下划线、删除线等文字样式。 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;}。注意：2em的意思就是文字的2倍大小。em 就是一个全角占位符，则2em 就是2个全角位置。但是，建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。 line-height也是段落排版中一个常用的属性，指定行间距（行高）。 如果想在网页排版中设置文字间隔或者字母间隔就可以使用letter-spacing 来实现。如果想设置英文单词之间的间距可以使用 word-spacing 来实现。 html的标签元素大体被分为三种不同类型：块状元素、内联元素(又叫行内元素)和内联块状元素。它们的区别：块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。 块级元素特点：（display:block; 所有块级元素都具备盒子模型的特征） 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素特点：（display:inline;） 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素特点：（inline-block;） 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型 流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。第二点：在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed) absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。 水平居中：如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素(块状元素的宽度width为固定值)和不定宽块状元素(块状元素的宽度width不固定)。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的，元素的“上下 margin” 是可以随意设置的。不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）： 加入 table 标签。这是利用table标签的长度自适应性——即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置。 设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的。 垂直居中 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。但这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 父元素高度确定的多行文本、图片等的竖直居中的方法有两种：方法一：css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。方法二：在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 隐性改变display类型：只要html代码中出现position : absolute或float:left或float:right其中之一，则元素的display显示类型就会自动变为inline-block，就可以设置宽和高了，并且默认宽度不占满父元素。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习笔记-入门篇]]></title>
    <url>%2F2018%2F03%2F25%2FVue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于“渐进式”的理解想要理解渐进式的概念，首先要理解什么是框架。框架的存在是为了帮助我们应对复杂度，而框架本身也会带来一定的复杂度，所以就可以抽象出一个问题，即所要解决的问题的内在复杂度，与所使用的工具的复杂度进行对比。不难理解，工具复杂度是为了处理内在复杂度所做的投资，所以如果使用一个过于简陋的工具应对一个复杂的问题，就会遇到工具太弱而使得生产力受影响的问题；同样的，如果你想要解决的问题并不复杂，但你却用了很复杂的框架，那么就会遇到工具复杂度所带来的副作用，这样不仅会使工具失去了本身所带来的优势，还会增加各种问题，例如培训成本、上手成本、以及实际开发效率等。 综上所诉，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。而我们目前需要的可能是一个能够根据项目需要自由“伸缩”的框架，这种自由“伸缩”的概念，就是渐进式的概念，渐进式的框架不需要做太多职责之外的事情，你完全可以根据你的需要来选择让框架完成什么功能。 使用vue无需关心DOM操作，所有的DOM操作都交给vue来完成，你编写的代码只需要关注逻辑层面即可。 数据双向绑定示例如下，input表单中的值如果改变，data中的message也会跟着改变，而如果data中的message改变了，则input中的值也会改变。html代码：1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/input&gt;&lt;/div&gt; js代码：12345678&lt;script&gt;new Vue(&#123; el: &apos;#app&apos; data:&#123; message: &quot;Hello World!&quot; &#125;&#125;);&lt;/script&gt; 数据双向绑定有个好处，如果input表单的值发生变化，则h1标签中的值会同步更新。而这个过程要用jQuery等框架实现并不容易。tips:可以使用下列语句打印data中的message内容，也会随input框中内容的变化实时更新。其中|是个过滤器，用于控制文本以json格式输出。123&lt;pre&gt; &#123;&#123; $data | json &#125;&#125;&lt;/pre&gt; v-show与v-if的区别v-show实际上是控制DOM元素的display属性，而v-if如果不为真，则直接不渲染该元素。在查看源代码时可以看出这个区别。 vue中的事件vue中的事件使用v-on绑定，比如表单绑定提交事件可以写为v-on:submit=&quot;functionName/表达式（使用的变量要在data中声明）&quot;或@submit=&quot;functionName对应的js代码如下：123456789new Vue(&#123; el: &quot;#...&quot; methods:&#123; functionName: function()&#123; ... //这里可以使用this.变量名来获取data中的数据 &#125; &#125;&#125;); *注意：默认情况下点击提交可能会跳转到一个页面，可以在上述代码中向函数传入一个e作为参数，使用e.preventDefault();阻止表单的默认提交行为。也可以简写在html中v-on:submit.prevent=&quot;functionName&quot; Vue的组件组件可以扩展 HTML 元素，封装可重用的代码。Vue中的组件化使得你可以创造自己的html标签，从而方便重用。要注册一个全局组件，可以使用 Vue.component(tagName, options)。例如，想要在html中使用一个&lt;test&gt;&lt;/test&gt;标签，则需要以下js代码：12345&lt;script&gt; Vue.component(&apos;test&apos;,&#123; template: &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos; &#125;);&lt;/script&gt; 此时浏览器会将template中的内容替换到&lt;test&gt;&lt;/test&gt;的位置。template中的内容可以在html代码中指定一个&lt;template&gt;&lt;/template&gt;标签，并赋予id，在template处指定值为#id。props指定了组件的属性，自定义组件中如果要使用某个属性并赋值，需要在props声明。注意：vue中的组件是不允许有大写字母存在的，如果你的组件使用了驼峰式命名，如myCounter，则使用这个组件的时候标签会自动变成&lt;my-counter&gt;&lt;/my-counter&gt;。 示例：使用同一段代码来实现一个点赞及不喜欢的计数功能：注意：此示例中标签是包裹在一个id为app的div中的，因此必须要实例化Vue并指明el的值为#app，否则没有效果。即官方文档中说的注意确保在初始化根实例。并且，组件应该在初始化根实例之前被注册。 vue的两个彩蛋 在cdn中搜索vue并复制vue的非压缩版本，在浏览器中的console窗口中，如果你的代码有错误，则会有十分友好的提示。开发过程中最好不要使用压缩版本，不然就失去了所有常见错误的警告。 vue-devtoos，一款chrome插件，需要在有服务器的情况下使用，本地服务器也可以，它会显示出vue本来的样子，结构清晰，对vue的开发也会有一定的帮助。 computed可以用于一些需要处理代码逻辑或业务逻辑的输出，或者是一些需要经过多方判断最终输出到屏幕的数据。如果与input进行了数据绑定那么也是可以实时更新的。示例如下： 循环输出使用v-for来循环输出data中的json数组中的数据。 举例：12345&lt;ul&gt; &lt;li v-class=&quot;task.completed ? &apos;completed&apos; : &apos;&apos;&quot; v-for=&quot;task in tasks&quot; &gt;&#123;&#123; task.body &#125;&#125;&lt;/li&gt; 或者写为以下格式也可以根据json数据中的complete字段来指定元素的样式 &lt;li :class=&quot;&#123;&apos;completed&apos;:task.completed&#125;&gt;&lt;/li&gt;&quot;&lt;/ul&gt; tips：v-class可以简写为:class。如果直接写:class=&quot;completed&quot;是不起作用的，需要在data中对complete进行声明或者写为:class=&quot;[&#39;completed&#39;, &#39;something&#39;]&quot;。js代码：1234567data:&#123; tasks:[ &#123;body: &apos;go to the movie&apos;, completed: false&#125;, &#123;body: &apos;learn vue.js by video&apos;, completed: true&#125;, &#123;body: &apos;go to the shop&apos;, completed: false&#125; ]&#125; 12345&lt;style&gt; .completed&#123; text-decoration: line--through; &#125;&lt;/style&gt; 一些建议自定义标签尽量添加一些前缀或后缀，或者使用多个单词，因为html一般使用单个单词作为标签，这样可以最大程度的避免重复的可能，也避免了需要修改代码的可能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础学习笔记]]></title>
    <url>%2F2018%2F03%2F22%2FMarkDown%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文源于Markdown官方文档，自行整理后发布，首发于CSDN，Markdown常用语法学习笔记 标题（1）atx形式： # 表示一级标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 ## 表示二级标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 …… ######表示六级标题，即HTML语言中的&lt;h6&gt;&lt;/h6&gt;标签 （2）Setext形式： = 底线 表示最高阶标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 - 底线 表示二阶标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 段落一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，例如只有空白和tab）。 注意，一个以上空行的意思是，当前行输入完毕换行后，再次按下回车键换行，这样即为一个以上空行。显示上看起来是两行文字之间留出一行了空白行。 段落即为HTML语言中的&lt;p&gt;&lt;/p&gt; 区块&gt; 表示区块，即首行缩进一个单位长度（通常为四个空格的长度），即HTML语言中的&lt;blockquote&gt;&lt;/blockquote&gt; 列表* 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; + 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; - 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; 1. 有序列表，数字加英文句点，对应HTML语言中的&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 注意： 你在列表标记上使用的数字并不会影响HTML的输出结果。如果你使用懒惰的写法，建议第一个项目最好从1.开始，因为Markdown未来有可能会支持有序列表的start属性。 如果在插入列表时，在列表的两项之中插入了空行，则该项内容会用&lt;p&gt;标签包裹起来，你也可以在一项中插入多个段落，只要正确的保证了空行，并且最好开头能够空出四个空格或一个tab，或者是添加一个&gt;使它变成区块，这样和列表显示起来比较整齐。 链接Markdown支持两种形式的链接语法：行内和参考两种形式。 （1）行内形式： 格式：This is an [example link](www.example.com) 解释：在HTML语言中即为，将example link包裹在&lt;a&gt;标签中，并且href地址为www.example.com。 格式：This is an [example link](www.example.com &quot;With a title&quot;) 解释：基本同上，区别是指定了该a标签的title属性值为With a title。 （2）参考形式： 参考形式的链接可以让你为链接定一个名称，之后在其他地方统一定义链接的内容。 格式：This is an [example link][1], and [the second example link][2]. [1]: www.example.com [2]: www.example2.com &quot;title&quot; 解释基本同上，需要注意的地方是，[1]不一定非要使用数字，可以使用字母、数字和空格或其组合，但是不分大小写。 图片图片的语法和链接很像，也分为行内形式和参考形式两种。 （1）行内形式（title是选择性的）： 1![alt text](/path/to/image.jpg &quot;Title&quot;) （2）参考形式：123![alt text][id][id]: /path/to/image.jpg &quot;Title&quot; 上面两种形式都会输出HTML为：&lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot;&gt; 代码Markdown文档中如果输入HTML代码，是会直接生效的。如果想要显示出一一段代码来而不是让它被解析运行，就使用` `（反引号，英文模式下按键盘左上角的波浪号键，注意不能跨行）将代码部分包裹起来，这样就可以显示出原原本本的代码了。 分割线可以在一行中使用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或减号中间插入空格。如： * * * - - - ****** ------ 强调使用星号*和底线_作为标记强调字符的符号，被一个*或_包围的内容会以标签的形式显示，即斜体。被两个*或_包围的内容将会以标签的形式显示，即加粗。 注意，如果*或_的两边有空白，则会显示成普通的星号或底线。如果想要在文字前后直接插入普通的星号或底线，则需要用到转义字符\。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2FHello-World%2F</url>
    <content type="text"><![CDATA[Update in 2018.03.25更新了搜索功能，博客基本功能全部配置完毕。绑定了域名fnine59.top，以后可以通过fnine59.top或www.fnine59.top访问本站。 Update in 2018.03.22程序员面对任何一门新技术，第一句话似乎永远都是Hello World。 从大约3月18号左右开始着手准备这个项目，Hexo基于Git和Nodejs，所以先是花了一两天左右，利用课余时间学习了Git。到最后真正用于搭建这个网站的时间差不多也就一个下午。 这个网站目前还有些功能没有完善起来，会进一步改善的。 欢迎留言，欢迎联系我❤]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery笔记整理（DOM篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88DOM%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建节点与属性处理 $(&quot;html结构&quot;)可以创建出来，例如$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)，如果要指定属性，则$(&quot;&lt;div id=&#39;test&#39; class=&#39;aaron&#39;&gt;我是文本节点&lt;/div&gt;&quot;)即可。 DOM内部插入append()与appendTo() .append(content)向每个匹配id元素内部追加内容 .appendTo(content)把所有匹配的元素追加到另一个指定的元素集合中 这个方法可以使得创建的新节点显示在文档中，将新创建的元素当作页面某一个元素的子元素放到其内部即可。 append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。 appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。 区别：append()前面是被插入的对象，后面是要在对象内插入的元素内容；appendTo()前面是要插入的元素内容，而后面是被插入的对象 DOM内部插入prepend()与prependTo() .prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素。 .prependTo()方法把所有匹配的元素前置到另一个指定的元素集合中。 DOM外部插入after()与before() 内部插入着重于节点之间的父子、祖辈关系；而外部插入着眼于节点之间的兄弟关系。 .after(content)方法在匹配元素集合中的每个元素后插入参数指定的内容，作为其兄弟节点。 .before(content)方法按参数设定，在匹配元素的前面插入内容。 DOM外部插入insertAfter()与insertBefore() .insertBefore()方法在目标元素前面插入集合中每个匹配的元素 .insertAfter()方法在目标元素后面插入集合中每个匹配的元素 注意：after和before方法都是将要插入的内容作为参数，而insertBefore和insertAfter方法则相反，要插入的内容在方法前面。 删除节点 empty() empty方法用于清除指定元素中的所有子节点 remove() remove方法与empty方法一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 remove方法可以传参，比如$(&quot;p&quot;).remove(&quot;:contains(&#39;3&#39;)&quot;)，意思是找到所有p元素中，包含了3的元素，这个也是一个过滤器的处理。可以通过类似于$(&quot;p&quot;).filter(&quot;:contains(&#39;3&#39;)&quot;).remove()的方式进行处理。 detach() 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理。 可以使用一个变量接收detach方法的返回值，当执行完detach方法后会移除对象，但仅仅是显示效果没有了，在内存中还是存在的，可以使用append(刚才接收返回值的变量)将元素重新放回文档流中。这时可以发现该元素绑定的事件仍然生效。 DOM拷贝clone() clone方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 注意：如果节点有事件或者数据之类的其他处理，我们需要通过clone(true)传递一个布尔值true用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。 clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色。 DOM替换replaceWith()和replaceAll() .replaceWith(newContent)用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。 .replaceAll(target)用集合的匹配元素替换每个目标元素。 注意：这两个方法都会删除与节点相关联的所有数据和事件处理程序。 DOM包裹 wrap()方法 .wrap(wrappingElement)在集合中匹配的每个元素周围包裹一个HTML结构 .wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。使用后的效果与直接传递参数是一样的，只不过可以把代码写在函数体内部，写法不同而已。 unwrap()方法 这个方法与wrap的方法是相反的，将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在的话）在原来的位置。 wrapALl()方法 .wrapAll(wrappingElement)：给集合中匹配的元素增加一个外面包裹的HTML结构。 这个方法同样有.wrapALl(function)的写法，通过回调的方式可以单独处理每一个元素，等同于wrap的处理。 wrapInner()方法 .wrapInner(wrappingElement)：给集合中匹配的元素的内部增加包裹的HTML结构。 例子： 12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 给所有元素增加一个p包裹 1$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;) 最后的结构 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 此方法也有.wrapInner( function )的写法，允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行并返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。效果等同于第一种处理。 jQuery的遍历 children()方法 用于快速查找元素合集里面的第一级子元素。由于jQuery是一个合集对象，所以通过children是匹配合集中每一个元素的第一级子元素。同时也因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，因此允许传一个选择器的表达式。比如$(&#39;.div&#39;).children(&#39;:last&#39;)。 find()方法 find是遍历当前元素集合中每个元素的后代，不仅是儿子，祖孙辈也可以。 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 *。 find只在后代中遍历，不包括自己。 parent()方法 用于快速查找合集里面每一个元素的父元素。 jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素。同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 parents()方法 用于快速查找合集里面每一个元素的所有祖辈元素。 也有无参或带参两种使用方法。 closest()方法 该方法从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。closest()方法接受一个匹配元素的选择器字符串。 与parents方法类似，但还是有些区别： 起始位置不同：.closest开始于当前元素 .parents开始于父元素 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 next()方法 用于快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合。 next()无参数：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素。 next()方法选择性地接受同一类型选择器表达式： 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 prev()方法 用于快速查找合集里面每一个元素紧邻的前面同辈元素的元素集合。 prev方法也有无参和有参两种用法。 siblings()方法 用于快速查找指定元素集合中每一个元素的同辈元素 此方法也有也有无参和有参两种用法。 add()方法 用来创建一个新的jQuery对象，元素添加到匹配的元素集合中。 each()方法 .each()方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始计数）。 例子： 1234&lt;ul&gt; &lt;li&gt;慕课网&lt;/li&gt; &lt;li&gt;Aaron&lt;/li&gt;&lt;/ul&gt; 以上是结构，现在开始迭代li，循环2次···$(“li”).each(function(index, element) { //index 索引 0,1 //element是对应的li节点 li,li //this 指向的是li //如果需要提前退出，可以以通过返回 false以便在回调函数内中止循})`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（基础篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[jQuery版本进入官方网站获取最新的版本http://jquery.com/download/，这里需要注意 jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于 2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。由于减少了一些代码，使得该版本比 jQuery 1.x 更小、更快。 $(document).ready 等页面的文档(document)中的节点都加载完毕后，再执行后续代码。 jQuery对象和DOM对象的转换 jQuery-&gt;DOM：jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。可以利用数组下标的方式读取到jQuery中的DOM对象。 DOM-&gt;jQuery：如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象。通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了。 选择器 id选择器 语法：$( &quot;#id&quot; ) 注意：id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的。 类选择器 语法：$( &quot;.class&quot; ) 元素选择器（根据给定的标记名称选择所有的元素） 语法：$( &quot;element&quot; ) 全选择器 语法$( &quot;*&quot; ) 层级选择器 &gt; （大于号）紧跟父子关系 如$(“div &gt; p”)表示选择div下的直接层是p的节点。 + （加号） 紧跟兄弟关系 如$(“div + p”)表示选择div同层的左右相邻的p节点。 ~ （波浪线）任意距离兄弟关系 如$(“div ~ p”)表示选择div同层的p节点。 （空格） 任意层父子关系 如$(“div p”)表示选择div下的p节点（不管中间隔多少层）。 , （逗号） 表示选择器组合，如$(“div p, span p”)表示div下p节点和span下p节点。 基本筛选选择器 注意jQuery合集都是从0开始索引 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 可见性筛选选择器 $(&quot;:visible&quot;) 选择所有显示的元素 $(&quot;:hidden&quot;) 选择所有隐藏的元素 注意：:hidden选择器，不仅仅包含样式是display=”none”的元素，还包括隐藏表单、visibility等等。 隐藏一个元素的方法有以下几种 CSS display的值是none type=”hidden”的表单元素 宽度和高度都显式设置为0 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 属性筛选选择器 属性选择器让你可以基于属性来定位一个元素，可以只指定该元素的某个属性，这样所有使用该属性而不管它的值，这个元素都将被定位，也可以更加明确并定位在这些属性上使用特定值的元素。 描述如下： 在这么多属性选择器中[attr=&quot;value&quot;]和[attr*=&quot;value&quot;]是最实用的，[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等。[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件。 表单元素选择器 具体方法描述： 注意：除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。因此大部分表单类别筛选器可以使用属性筛选器替换。比如 $(&#39;:password&#39;) == $(&#39;[type=password]&#39;) 表单对象属性筛选选择器 具体方法描述： 注意：选择器适用于单选框和复选框，对于下拉框元素应该使用:selected选择器。在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素。 特殊选择器this **this和$(this)的区别： this是JavaScript中的关键字，指的是当前的上下文对象，简单地说就是方法/属性的所有者。 $(this)：通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法直接处理样式了。 总结来说，this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 jQuery的属性与样式 .attr()与.removeAttr() .attr() attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } .removeAttr()删除方法：为匹配的元素集合中的每个元素中移除一个属性（attribute） 注意区分Attribute和Property的概念，property是DOM中的属性，是JavaScript里的对象，例如tagName，nodeName，nodeType，defaultChecked，和 defaultSelected等；而attribute是HTML标签上的特性，它的值只能够是字符串；例如html中常用的id、class、title、align等。 获取Attribute就需要用.attr()，获取Property就需要用.prop() .html()与.text() .html()方法获取集合中第一个匹配元素的html内容，或者设置每一个匹配元素的html内容，具体有3中用法如下： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 注意：因为.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） .text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .text()结果返回一个字符串，包含所有匹配元素的合并文本 .val() .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function )，一个用来返回设置值的函数 .html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 .addClass()与.removeClass() .addClass()方法通过动态改变类名（class），可以让其修改元素呈现出不同的效果。用法如下： .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ): 这个函数返回一个或更多用空格隔开的要增加的样式名 注意：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上。 .removeClass()方法从匹配的元素中删除全部或者指定的class，用法如下： .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) )： 一个函数，返回一个或多个将要被移除的样式名 注意：如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。 .toggleClass()样式切换 通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass。用法如下： .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名。 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意：toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加。并且，toggleClass会保留原有的Class名后新增，通过空格隔开。 .css() 用于获取元素样式属性的计算值或者设置元素的CSS属性。用法如下： 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 通过.css方法设置的样式属性优先级要高于.addClass方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记及技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面马上要面试了，重新温习一下基础，把慕课网上的前端工程师课程走了一遍，整理了一些平时不太注意到的、或是个人印象不够深刻的JavaScript相关知识，希望可以巩固一下自己的印象。也能保证自己随时可以查看这些笔记。 关于大小写JS是大小写敏感的 document.write()直接向HTML输出流写内容，也将就是直接在网页中输出内容。如果要使用write方法输出一个HTML标签，则要使用&quot;&quot;将标签扩起来。 confirm对话框alert()对话框经常被用于调试程序，它包含一个确定按钮。而confirm对话框包括一个确定按钮和一个取消按钮，通常用于允许用户做选择的动作，语法为confirm(str);。confirm的返回值，当用户点击“确定”按钮时，返回true；当用户点击“取消”按钮时，返回false。可以定义一个变量来接收confirm的返回值。 prompt消息对话框除了上述两种对话框，还有一种prompt消息对话框。它通常用于询问一些需要与用户交互的信息。弹出的消息对话框包括一个确定按钮，一个取消按钮和一个文本输入框。语法为prompt(str1, str2);，其中str1是要显示在消息对话框中的文本，对用户来说是不可修改的；str2是文本框中的内容，用户是可以修改的。prompt的返回值，如果用户点击确定按钮，那么文本框中的内容将作为函数返回值；如果用户点击取消按钮，则返回null。 window.open()可以查找一个已经存在或者新建的浏览器窗口。语法window.open([URL], [窗口名称], [参数字符串]) window.close()用于关闭窗口。直接调用则关闭本窗口，使用&lt;窗口对象&gt;.close()则可以关闭指定的窗口。窗口对象可以是在打开窗口时建立一个变量进行存储。 Object.innerHTML用于获取或是替换HTML元素的内容。Object是获取的元素对象，比如通过document.getElementById(&quot;ID&quot;)获取的元素。 改变HTML样式使用Object.style.property = new style;来改变HTML元素的样式。注意，property是CSS样式属性，new style是属性的新值。 显示和隐藏语法：Object.style.display = value 控制类名（className属性）className属性设置或返回元素的class属性。语法：Object.className = classname 创建数组var arrayname = new Array()可以用来创建一个数组。创建的新数组是空数组，没有值，如输出，则显示undefined。并且，虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度，仍然可以将元素存储在规定长度以外。 函数传参js属于弱类型语言，所以在定义方法传入参数的时候并不需要指定其类型。 事件 鼠标点击事件onmouseclick 鼠标经过事件onmouseover 鼠标移开事件onmouseout 光标聚焦事件onfocus 失去焦点事件onblur 内容选中事件onselect（当文本框或者文本域中的文字被选中时触发） 文本框内容改变事件onchange 加载事件onload（该事件在页面加载完成后立即发生，如果不使用js代码则写在body标签中） 卸载事件onunload（用户退出页面时触发，比如页面关闭、页面刷新等） 时间 Date日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000秒）。定义时间对象的语法为：var Udate = new Date() 日期对象提供了以下方法： 返回/设置年份方法get/setFullYear() getDay()返回星期（返回是0-6的数字，其中0表示星期天） get/setTime()返回/设置时间方法（单位为毫秒数，计算从1970年1月1日零时到日期对象所指的日期的毫秒数，即时间戳） 字符串对象 .length可以获取字符串对象的长度 toLowerCase()方法可以将所有大写字母都转为小写字母 toUpperCase()方法则可以将所有小写字母转换为大写字母 charAt()方法返回指定位置的字符 indexOf方法返回指定的字符串首次出现的位置 split()方法分割字符串为字符串数组并返回（两个参数，第一个参数separator必需，用来指定分隔符；第二个参数limit可选，用来指定分割次数） substring()方法用于提取字符串中介于两个指定下标之间的字符（指定开始位置的参数必需，指定结束位置的参数可选） substr()方法从字符串中提取从startPos位置开始指定书目的字符串，语法：stringObj.substr(startPos,length)，其中length可选，默认值到字符串结尾 Math对象 ceil()函数用于对一个数向上取整，返回的是一个大于或等于x并且与x最接近的整数，语法Math.ceil(x) 向下取整函数floor()，语法Math.floor(x)，返回的是一个小于或等于x并且与x最接近的整数 四舍五入函数round()，语法Math.round() 随机数random()，可以返回一个大于等于0但小于1的随机数，语法Math.random() 数组对象 concat()方法用于连接两个或多个数组，语法：arrayObject.concat(array1,array2...arrayN)此方法返回一个新数组，不改变原来的数组 join()方法用于把数组中的所有元素都放入一个字符串，元素是通过指定的分隔符进行分隔的，语法arrayObject.join(分隔符)，该方法返回一个字符串 reverse()方法用于颠倒数组中元素的顺序，该方法会改变原来的数组而不会创建新数组 slice()方法可以从已有的数组中返回选定的元素，语法arrayObject.slice(start,end)，其中start参数必需，end参数可选，默认到数组结束，该方法返回一个新的数组，包括从start到end（不包括end）的arrayObject中的元素，不会修改原有数组 sort()方法使数组中的元素按照一定的顺序排列，语法arrayObject.sort(方法函数名)，如果不规定方法函数，则按unicode码顺序排列，如果指定方法函数，则按方法函数所指定的排序方法进行排序，这个方法函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数a和b，其返回值如下： 若返回值&lt;=-1，则表示a在排序后的序列中出现b之前 若返回值&gt;-1&amp;&amp;&lt;1，则表示a和b具有相同的排序顺序 若返回值&gt;=1，则表示a在排序后的序列中出现在b之后 计时器 计时器有两种： 一次性计时器，仅在指定的延迟时间之后触发一次 间隔性触发计时器，每隔一定的时间间隔就触发一次 setInterval()计时器执行时，从载入页面后每隔指定的时间执行代码，语法setInterval(代码, 交互时间);，其中，交互事件的单位是毫秒。 clearInterval()方法用于取消由setInterval()设置的交互时间，语法clearInterval(id_of_setInterval)，传入的id_of_setInterval是由setInterval()返回的ID值，可以使用一个变量来接收这个值。 setTimeout()计时器，在载入后延迟指定时间后，去执行一次表达式并且只执行一次，语法setTimeout(代码, 延迟时间);，其中延迟时间以毫秒为单位。 clearTimeout()计时器，和setTimeout()计时器一起使用，用于停止计时器，语法clearTimeout(id_of_setTimeout)，其中传入的id_of_setTimeout是由setTimeout()返回的ID值，可以使用一个变量来接收这个值。 History对象 history对象记录了用户曾经浏览过的页面（URL），并可以实现与浏览器前进和后退相似的功能。 注意：从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签乃至每个框架，都有自己的history对象与特定的window对象关联。 语法window.history.[属性|方法]，其中window可以省略。 属性：length，返回浏览器历史列表中的URL总数量。 方法： back()，用于加载history列表中的前一个URL。back()相当于go(-1)。 forward()，用于加载history列表中的后一个URL。forward()相当于go(1)。 go()，用于加载history列表中某个具体的页面，语法window.history.go(number);，其中number是指要访问的URL在history的URL列表中的相对位置，比如返回当前页面之后浏览过的第三个历史页面，number为3；返回当前页面之前浏览过的第二个历史页面，number为-2。 Location对象 location对象用于获取或设置窗体的URL，并且可以用于解析URL。 语法location.[属性|方法] location对象属性示意图： location对象方法： assign()，用于加载新的文档 reload()，重新加载当前文档 replace()，用新的文档替换当前文档 Navigator对象 navigator对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 语法navigator.属性 属性如下 userAgent 用于返回用户代理头的字符串表示，就是包括浏览器版本信息等的字符串 语法navigator.userAgent screen对象 screen对象用于获取用户的屏幕信息。 语法window.screen.属性 属性如下： window.screen对象还包含有关用户屏幕的信息 screen.height返回屏幕分辨率的高 screen.width返回屏幕分辨率的宽 注意，单位以像素计，window这个前缀可以省略。 availwidth和availHeight属性是可用的宽度和高度，会减去界面特性，如任务栏。 文件对象模型DOM getElementsByName()方法返回带有指定名称的节点对象的集合。 语法：document.getElement**s**ByName(name) 与getElementById()不同的地方在于这个方法使通过元素的name属性查询元素而不是通过id属性。 因为文档中的name属性有可能不唯一，所以这个方法返回的是元素的数组而不是一个元素。 getElementsByTagName()方法返回带有指定标签名的节点对象的集合，返回元素的顺序是它们在文档中的顺序。 语法document.getElement**s**ByTagName(Tagname) Tagname是标签的名称，如p，a，img等标签名。 getAttribute()方法通过元素节点的属性名称获取属性的值。 语法elementNode.getAttribute(name) elementNode是通过上述几个方法获取到的元素节点。 setAttribute()方法增加一个指定名称和值的性属性，或者把一个现有的属性设定为指定的值。 语法elementNode.setAttribute(name,value) 类似getAttribute()方法，此方法也是只能通过元素节点对象调用的函数。 节点属性： 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称，是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue ：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 nodeType ：节点的类型，是只读的。以下常用的几种结点类型 元素 -&gt; 1 属性 -&gt; 2 文本 -&gt; 3 注释 -&gt; 8 文档 -&gt; 9 childNodes用于访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，具有length属性。 语法elementNode.childNodes 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 firstChild属性返回‘childNodes’数组的第一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.firstChild firstChild属性与elementNode.childNodes[0]效果相同。 lastChild属性返回‘childNodes’数组的最后一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.lastChild lastChild属性与elementNode.childNodes[elementNode.childNodes.length-1]效果相同。 parentNode用于获取指定节点的父节点 语法elementNode.parentNode 父节点只能有一个 访问兄弟节点 nextSibling属性可以返回某个节点之后紧跟的节点（处于同一树层级中） 语法nodeObject.nextSibling 如果无此节点，则该属性返回null previousSibling属性可以返回某个节点之前紧跟的节点（处于同一树层级中） 语法nodeObject.previousSibling 如果无此节点，则该属性返回null 插入节点 appendChild()用于在指定节点的最后一个子节点列表之后添加一个新的子节点 语法appendChild(newnode) 例子： 1234var otest = document.getElementById(&quot;test&quot;);var newnode = document.createElement(&quot;p&quot;);newnode.innerHTML = &quot;This is a new p&quot;;otest.appendChild(newnode); 注意：应当由父节点来调用这个方法 insertBefore()方法用于在已有的子节点之前插入一个新的子节点 语法insertBefore(newnode,node); 例子： 1234var otest = document.getElementById(&quot;test&quot;); var newnode = document.createElement(&quot;li&quot;);newnode.innerHTML = &quot;PHP&quot;;otest.insertBefore(newnode,otest.firstChild); 注意：应当是父节点来调用这个方法，并定义在某个子节点之前插入新节点 删除节点 removeChild()方法用于从子节点列表中删除某个节点，如果删除成功，此方法返回被删除的节点，如果删除失败则返回NULL。 语法nodeObject.removeChild(node); 注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值，代码如下: 123var otest = document.getElementById(&quot;div1&quot;);var x = otest.removeChild(otest.childNodes[1]);x = null; 替换元素节点 replaceChild方法实现子节点（对象）的替换，返回被替换对象的引用。 语法node.replaceChild(newnode,oldnode) 注意，两个参数都是必须的，当oldnode被替换时，所有与之相关的属性内容都将被移除，并且newnode必须先被建立。 需要父节点调用这个方法，因此可以使用oldnode.parentNode.replaceChild(newnode,oldnode);来进行替换。 创建元素节点 createElement()方法可以创建元素节点，此方法可以返回一个element对象。 语法document.createElement(tagName); createTextNode()方法创建新的文本节点，返回新创建的Text节点。 语法document.createTextNode(data); 参数：data是字符串值，可以规定此节点的文本。 注意：innerHTML和createTextNode都可以把一段内容添加到一个节点中，区别是如果这段内容中有html标签（如例子中的）时表现就不同了，在createTextNode中会当作文本处理，不会被浏览器解析，但用innerHTML就会被当作HTML代码处理（如你的例子中Hello会被加粗显示）。 例子： 1234var element = document.createElement(&quot;p&quot;);var textnode = document.createTextNode(&quot;I love Javascript!&quot;);element.appendChild(textnode);document.body.appendChild(element); 浏览器窗口可视区域大小 获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： 直接求 document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者Document对象的body属性对应HTML文档的标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 12var w= document.documentElement.clientWidth(或 document.body.clientWidth);var h= document.documentElement.clientHeight(或 document.body.clientHeight); 网页尺寸 scrollHeight和scrollWidth，分别用于获取网页内容的高度和宽度 针对IE、Opera:scrollHeight 是网页内容实际高度，可以小于 clientHeight。 针对NS、FF:scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 浏览器兼容写法 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写。并且，scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 offsetHeight和offsetWidth，分别用于获取网页内容的高度和宽度（包括滚动条和等边线，会随窗口的显示大小改变） 值：offsetHeight = clientHeight + 滚动条 + 边框。 浏览器兼容性1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; height、clientHeight、scrollHeight、offsetHeight区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于Node.js Node.js适合高并发、低负载、弱逻辑的项目，适合做如dataAPI或聊天系统等实时性要求比较高的项目。 关于HTML 渲染顺序 HTML文档是从上向下渲染的，因此同一区块有些不重要的内容可以适当往后放，让重要内容先被加载出来（本条是对于结构来讲，也就是对于HTML语言来讲，不涉及表现CSS或行为JS）。 结构与表现分离 前端开发时要注意结构与表现分离，在编写前端页面的过程中，要先从结构考虑，争取做到结构最简，避免有过多不必要的div。当结构编写完后，再考虑表现，也就是CSS样式。通过这种结构与表现分离的思想，争取做到修改业务逻辑时，只需要改动样式，而不需要改动结构。 如何让一段文本向右移动？ 当然可以采取margin或padding的形式将文字元素推到右边，但这样做会造成外部容器的宽度发生变化，就需要再次修改外部容器的宽度。此时，最理想的操作方法应该是使用text-indent属性，来设置文本缩进，它不会影响外部容器的宽度，也可以设置百分比，简洁易用。 背景图片 元素的背景，比如导航栏圆角背景，可以将普通状态下的背景（如灰色）与hover状态下的背景（如橙色）做在同一张图上，上下排列并掌握好宽和高。这样可以给默认状态下的导航栏菜单项（即display属性值为block的a标签）设置这张背景图，通过长宽来确保背景为灰色。当该菜单项处于hover状态或选中状态时，添加class并设置该菜单项的background-position属性，来使背景图向上移动，显示出之前拼接好的橙色背景来。 导航栏的制作 导航栏的结构均为&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;这样的无序列表，如果是竖向导航栏则无需float，如果是横向导航栏则可以设置li标签的float属性的值为left或right。 js代码中的window.onload 是为了让dom加载完毕之后再执行以下代码。jquery的$(function)(){}相当于js中的window.onload，并且比window.onload性能要好。 关于语义 &lt;q&gt;&lt;/q&gt;标签会在html文档中显示为双引号，但使用标签的主要目的并不是为了显示双引号，这样还不如直接输入双引号。它的目的是它的语义：引用别人的话。还有一个引用标签&lt;blockquote&gt;&lt;/blockquote&gt;，浏览器对它的解释是缩进样式，表示引入长文本。 一些HTML标签 &lt;hr /&gt;标签用于添加一条水平横线。 &lt;em&gt;&lt;/em&gt;标签用于斜体。 &lt;address&gt;&lt;/address&gt;用于显示地址，浏览器默认样式是斜体，当然也可用通过css来修改。 插入代码使用&lt;code&gt;标签如：&lt;code&gt;代码语言&lt;/code&gt; &lt;pre&gt;&lt;/pre&gt;标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。可以使用这个标签来包裹大段代码。 可以对&lt;table&gt;标签进行一些优化，&lt;caption&gt;表格标题&lt;/caption&gt;可以指定表格的标题，&lt;table summary=&quot;表格简介文本&quot;&gt;，这里的简介不会在浏览器显示出来，是为了增加表格的可读性（语义化）。 &lt;a&gt;除了常见的功能之外，标签还有一个功能是可以用来链接Email地址，使用mailto可以使访问者便捷的向网站管理者发送电子邮件，这样点击a链接时会打开电子邮件应用，并自动填写收件人等设置好的信息。具体用法如图 img标签可以通过title属性指定鼠标滑过图片时显示的文本。图片格式可以是gif，png，jpg，jpeg等。 在&lt;select&gt;标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 表单的重置按钮，可以通过设置input标签的type值为reset来实现。 label标签：label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。语法：&lt;label for=&quot;控件id名称&quot;&gt;。例子： 123456789&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;br /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;female&quot; /&gt; &lt;label for=&quot;email&quot;&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt;&lt;/form&gt; 可以为span标签添加属性white-space:pre;，这个样式表示空白会被浏览器保留。 css几种设置方法的优先级 12345671. 内联样式表的权值最高 10002. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 CSS 优先级法则： 123456789A 选择器都有一个权值，权值越大越优先B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式D 继承的CSS 样式不如后来指定的CSS 样式E 在同一组属性设置中标有“!important”规则的优先级最大 ID选择器只能在文档中使用一次。可以使用类选择器词列表方法为一个元素同时设置多个样式，ID选择器是不可以的。 子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。二者的区别在于：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通配选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素。 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（,）。 有些特殊的情况需要为某些样式设置具有最高权值，这时候我们可以使用!important来解决。如：p{color:red!important;}。注意：!important要写在分号的前面。 text-decoration可以用于设下划线、删除线等文字样式。 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;}。注意：2em的意思就是文字的2倍大小。em 就是一个全角占位符，则2em 就是2个全角位置。但是，建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。 line-height也是段落排版中一个常用的属性，指定行间距（行高）。 如果想在网页排版中设置文字间隔或者字母间隔就可以使用letter-spacing 来实现。如果想设置英文单词之间的间距可以使用 word-spacing 来实现。 html的标签元素大体被分为三种不同类型：块状元素、内联元素(又叫行内元素)和内联块状元素。它们的区别：块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。 块级元素特点：（display:block; 所有块级元素都具备盒子模型的特征） 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素特点：（display:inline;） 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素特点：（inline-block;） 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型 流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。第二点：在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed) absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。 水平居中：如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素(块状元素的宽度width为固定值)和不定宽块状元素(块状元素的宽度width不固定)。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的，元素的“上下 margin” 是可以随意设置的。不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）： 加入 table 标签。这是利用table标签的长度自适应性——即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置。 设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的。 垂直居中 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。但这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 父元素高度确定的多行文本、图片等的竖直居中的方法有两种：方法一：css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。方法二：在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 隐性改变display类型：只要html代码中出现position : absolute或float:left或float:right其中之一，则元素的display显示类型就会自动变为inline-block，就可以设置宽和高了，并且默认宽度不占满父元素。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习笔记]]></title>
    <url>%2F2018%2F03%2F25%2FVue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于“渐进式”的理解想要理解渐进式的概念，首先要理解什么是框架。框架的存在是为了帮助我们应对复杂度，而框架本身也会带来一定的复杂度，所以就可以抽象出一个问题，即所要解决的问题的内在复杂度，与所使用的工具的复杂度进行对比。不难理解，工具复杂度是为了处理内在复杂度所做的投资，所以如果使用一个过于简陋的工具应对一个复杂的问题，就会遇到工具太弱而使得生产力受影响的问题；同样的，如果你想要解决的问题并不复杂，但你却用了很复杂的框架，那么就会遇到工具复杂度所带来的副作用，这样不仅会使工具失去了本身所带来的优势，还会增加各种问题，例如培训成本、上手成本、以及实际开发效率等。 综上所诉，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。而我们目前需要的可能是一个能够根据项目需要自由“伸缩”的框架，这种自由“伸缩”的概念，就是渐进式的概念，渐进式的框架不需要做太多职责之外的事情，你完全可以根据你的需要来选择让框架完成什么功能。 Vue.js的安装兼容性：Vue不支持IE8及以下版本，因为Vue使用了IE8无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 Vue Devtools：推荐在浏览器上安装Vue Devtools，它提供了一个更为友好的界面来审查和调试Vue应用。Vue Devtools可以直接从chrome商店下载安装，但是需要翻墙；也可以手动安装，步骤如下： 找到vue-devtools#vue-devtools的github项目，并将其clone到本地.vue-devtoolsgit clone https://github.com/vuejs/vue-devtools.git 安装项目所需要的npm包npm install 编译项目文件npm run build 添加至chrome浏览器 安装Vue直接下载Vue并用&lt;script&gt;标签引入，Vue会被注册为一个全局变量。 CDN推荐链接到一个你可以手动更新的指定版本号：&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt; 使用时建议将vue.js更换为vue.min.js从而缩小项目构建。 命令行工具（CLI）Vue提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：1234567#全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ npm run dev CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，在熟悉 Vue 本身之后再使用 CLI。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础学习笔记]]></title>
    <url>%2F2018%2F03%2F22%2FMarkDown%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文源于Markdown官方文档，自行整理后发布，首发于CSDN，Markdown常用语法学习笔记 标题（1）atx形式： # 表示一级标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 ## 表示二级标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 …… ######表示六级标题，即HTML语言中的&lt;h6&gt;&lt;/h6&gt;标签 （2）Setext形式： = 底线 表示最高阶标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 - 底线 表示二阶标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 段落一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，例如只有空白和tab）。 注意，一个以上空行的意思是，当前行输入完毕换行后，再次按下回车键换行，这样即为一个以上空行。显示上看起来是两行文字之间留出一行了空白行。 段落即为HTML语言中的&lt;p&gt;&lt;/p&gt; 区块&gt; 表示区块，即首行缩进一个单位长度（通常为四个空格的长度），即HTML语言中的&lt;blockquote&gt;&lt;/blockquote&gt; 列表* 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; + 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; - 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; 1. 有序列表，数字加英文句点，对应HTML语言中的&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 注意： 你在列表标记上使用的数字并不会影响HTML的输出结果。如果你使用懒惰的写法，建议第一个项目最好从1.开始，因为Markdown未来有可能会支持有序列表的start属性。 如果在插入列表时，在列表的两项之中插入了空行，则该项内容会用&lt;p&gt;标签包裹起来，你也可以在一项中插入多个段落，只要正确的保证了空行，并且最好开头能够空出四个空格或一个tab，或者是添加一个&gt;使它变成区块，这样和列表显示起来比较整齐。 链接Markdown支持两种形式的链接语法：行内和参考两种形式。 （1）行内形式： 格式：This is an [example link](www.example.com) 解释：在HTML语言中即为，将example link包裹在&lt;a&gt;标签中，并且href地址为www.example.com。 格式：This is an [example link](www.example.com &quot;With a title&quot;) 解释：基本同上，区别是指定了该a标签的title属性值为With a title。 （2）参考形式： 参考形式的链接可以让你为链接定一个名称，之后在其他地方统一定义链接的内容。 格式：This is an [example link][1], and [the second example link][2]. [1]: www.example.com [2]: www.example2.com &quot;title&quot; 解释基本同上，需要注意的地方是，[1]不一定非要使用数字，可以使用字母、数字和空格或其组合，但是不分大小写。 图片图片的语法和链接很像，也分为行内形式和参考形式两种。 （1）行内形式（title是选择性的）： 1![alt text](/path/to/image.jpg &quot;Title&quot;) （2）参考形式：123![alt text][id][id]: /path/to/image.jpg &quot;Title&quot; 上面两种形式都会输出HTML为：&lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot;&gt; 代码Markdown文档中如果输入HTML代码，是会直接生效的。如果想要显示出一一段代码来而不是让它被解析运行，就使用` `（反引号，英文模式下按键盘左上角的波浪号键，注意不能跨行）将代码部分包裹起来，这样就可以显示出原原本本的代码了。 分割线可以在一行中使用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或减号中间插入空格。如： * * * - - - ****** ------ 强调使用星号*和底线_作为标记强调字符的符号，被一个*或_包围的内容会以标签的形式显示，即斜体。被两个*或_包围的内容将会以标签的形式显示，即加粗。 注意，如果*或_的两边有空白，则会显示成普通的星号或底线。如果想要在文字前后直接插入普通的星号或底线，则需要用到转义字符\。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2FHello-World%2F</url>
    <content type="text"><![CDATA[Update in 2018.03.25更新了搜索功能，博客基本功能全部配置完毕。绑定了域名fnine59.top，以后可以通过fnine59.top或www.fnine59.top访问本站。 Update in 2018.03.22程序员面对任何一门新技术，第一句话似乎永远都是Hello World。 从大约3月18号左右开始着手准备这个项目，Hexo基于Git和Nodejs，所以先是花了一两天左右，利用课余时间学习了Git。到最后真正用于搭建这个网站的时间差不多也就一个下午。 这个网站目前还有些功能没有完善起来，会进一步改善的。 欢迎留言，欢迎联系我❤]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>

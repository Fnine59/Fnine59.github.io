<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React+Nodejs项目搭建记录]]></title>
    <url>%2F2018%2F12%2F25%2FReact-Nodejs%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言平时的工作中要么是使用dva这种高度封装、开箱即用的框架，要么是基于别人搭建好的项目进行开发，十分缺乏从无到有搭建项目的经验，也缺乏对React框架的深刻理解。因此这次的毕业设计决定作为一次学习，从无到有的搭建一个前端基于React+Redux，后端基于nodejs的项目架子。 项目搭建一、Nodejs部分本次项目不再使用Java作为后端语言，而是使用nodejs开发后端部分，数据库使用MySQL。 服务器雏形生成（脚手架）nodejs应用程序常用的一个框架是express，也是本次开发选用的框架，具体使用可以参考express官方说明文档。 运行命令$ express -e myapp &amp;&amp; cd myapp &amp;&amp; npm install，使用express脚手架工具生成服务端雏形。 服务端项目架构修改既然是后端代码，就仿照之前学习Java的经验，进行简单的MVC分层。View层即视图层，在服务端雏形中已经存在，这部分等到后端部分搭建完后再着手修改。 首先实现Model层，即数据模型层。 在项目根目录下创建一个database文件夹，这个文件夹就用来存放所有属于Model层的文件，现规定该文件夹下的文件统一使用.db.js作为后缀。这一层主要负责与数据库交互。 node要连接mysql需要用到第三方的mysql库，先进行安装，命令如下： $ npm install mysql -save 新建一个config.db.js文件，项目中所有关于数据库连接的代码都放在这里。 这里不再遵循之前的做法，每次发送请求都重新创建数据库连接，创建数据库连接是一个十分消耗性能的操作。这里使用数据库连接池的方式获取数据库连接。对于数据库连接池的概念模糊的地方可以查看数据库连接池原理进行了解。 在nodejs项目中创建mysql数据库的连接池的操作具体可以查看express+mysql连接池的创建方式。 最终config.db.js文件中内容如下： 123456789101112131415161718192021222324252627282930313233343536/** * @description 数据库配置文件 * @author NaiyingZhang &lt;fnine59@163.com&gt; * @date 2018-12-24 */var mysql = require('mysql'); // 引入所需的第三方mysql库var pool = mysql.createPool(&#123; // 创建连接池 host: 'localhost', port: 3306, // 端口号 user: 'root', // 用户名 password: '*******', // 密码 database: 'xxxxxx', // 数据库名&#125;);var db = &#123;&#125;; // 创建一个空对象用于export出去/** * 从数据库连接池中获取数据库连接的方法 */db.conn = function (callback)&#123; pool.getConnection(function (err, connection) &#123; // 从连接池中获取到数据库连接 console.log('connect start...'); if(err) &#123; // 如果出现异常直接抛出 throw err; &#125; else &#123; if(typeof callback === 'function')&#123; // 如果传入了callback函数，执行它并将得到的连接传入 callback(connection); &#125; &#125; connection.release(); // 释放连接 console.log('connect end...'); &#125;)&#125;;module.exports = db; 至此，config.db.js文件编写完毕，上面的代码中提供了一个公用的获取数据库连接的方法。得到了数据库连接后，下一步是执行sql语句。在routes文件夹下创建一个放置后端开发用工具方法的类helper.js。 12345678910111213141516171819202122232425262728293031323334/** * @description 后端用工具模块 * @author NaiyingZhang &lt;fnine59@163.com&gt; * @date 2018-12-24 */var db = require('../database/config.db'); // 引入数据库配置文件暴露出的对象var helper = &#123; /** * 执行sql语句的方法，该方法接收一个opt对象，该对象属性如下： * name：请求名 * sql：要执行的sql语句 * callback：该请求的回调函数 */ db_query: function(opt) &#123; // 调用db对象中的conn方法并传入一个callback函数，参数即为拿到的数据库连接 db.conn(function (connection)&#123; console.log(`request method: $&#123;opt.name&#125;`) connection.query(opt.sql, function(err, res) &#123; if (err) &#123; console.log(`request method $&#123;opt.name&#125; err: + $&#123;err&#125;`); &#125; else &#123; console.log(`request method $&#123;opt.name&#125; success!`); if (typeof(opt.callback) === 'function') &#123; opt.callback(err, res); &#125; &#125; &#125;) &#125;); &#125;,&#125;;module.exports = helper; 上面的代码中，建立了一个用于执行sql语句的方法，并且还会执行请求成功后的回调。接下来看下刚才封装好的方法的具体使用。先在数据库中创建一张测试用表命名为test，在database文件夹下创建goods.db.js文件，内容如下。 1234567891011121314151617181920212223/** * @description 物品表数据模型层 * @author NaiyingZhang &lt;fnine59@163.com&gt; * @date 2018-12-24 */var helper = require('../routes/helper');/*物品模块 构造方法*/var Goods = function(goods) &#123; this.props = goods.props;&#125;;Goods.prototype.getTestAllItems = function(callback) &#123; // model层方法，用于与数据库交互 var _sql = "select * from test"; helper.db_query(&#123; sql: _sql, name: 'getTestAllItems', callback: callback &#125;)&#125;module.exports = Goods; 至此，Model层的工作进行完毕，然后来编写Control层，即控制层。这层主要负责定义和调用Model，也可以可以决定要显示哪一个View。因为这部分与后端路由有关，因此放在脚手架为我们搭建好的routes/services文件夹下。 在该文件夹下创建goods.ctrl.js文件，并约定Control层的文件统一使用.ctrl.js作为后缀。 1234567891011121314151617181920212223242526272829303132333435/** * @description 物品表控制层 * @author NaiyingZhang &lt;fnine59@163.com&gt; * @date 2018-12-24 */var Goods = require('../../database/goods.db'); // 从Model层拿到Goods的构造方法var Helper = require('../helper');module.exports = &#123; // 模块初始化 init: function(app) &#123; app.get('/user', this.doGetTestAllItems) // 使用get方法请求/user时，执行doGetTestAllItems &#125;, // 获取测试表中的所有信息 doGetTestAllItems: function(req, res) &#123; // Control层中用于调用Model层的方法 var props = &#123;&#125;; // 不传入参数 var goods = new Goods(&#123; props: props &#125;); // 创建goods实例 goods.getTestAllItems(function(err, data) &#123; // 调用Model层方法，并传入callback函数 if (data.length) &#123; return res.send(&#123; code: 200, data: data &#125;) &#125; else &#123; console.log(err) return res.send(&#123; code: 500, message: '出错了' &#125;) &#125; &#125;) &#125;&#125; 编写完Control层，再来做些其他配置。 routes/api.js文件内容如下： 12345678910111213141516171819202122var express = require('express');var router = express.Router();var fs = require('fs');var FS_PATH_SERVICES = './routes/services/';var REQUIRE_PATH_SERVICES = './services/';router.options('*', function (req, res, next) &#123; next();&#125;);try &#123; var list = fs.readdirSync(FS_PATH_SERVICES); for (var e; list.length &amp;&amp; (e = list.shift());) &#123; var service = require(REQUIRE_PATH_SERVICES + e); service.init &amp;&amp; service.init(router); &#125;&#125; catch(e) &#123; console.log(e);&#125;module.exports = router; 因为前端也会涉及到路由，为了做区分，我们为后端提供的API做一层单独的区分，修改app.js文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142var createError = require('http-errors');var express = require('express');var path = require('path');var cookieParser = require('cookie-parser');var bodyParser = require('body-parser');var logger = require('morgan');var routes = require('./routes/index');var api = require('./routes/api'); // 添加这句var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));app.use('/', routes);app.use('/api', api); // 添加这句// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);module.exports = app; 看下引用的./routes/index中有什么内容： 123456789var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);module.exports = router; 至此，后端架子基本搭建完毕，重启node服务，可以试着请求一下http://localhost/api/user来测试刚才写的案例接口是否正常。 请求成功后截图如下：]]></content>
      <categories>
        <category>Nodejs</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式训练问题总结]]></title>
    <url>%2F2018%2F11%2F01%2FCSS%E6%A0%B7%E5%BC%8F%E8%AE%AD%E7%BB%83%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言在完成纯css实现中台首页样式这个练习的过程中，遇到了一系列问题，现总结如下。 外边距（margin）塌陷问题描述在编写左侧导航栏的过程中，发现了这样的情况。 外边距塌陷是什么？经过查询，发现上面这种情况被称为“外边距塌陷”或“外边距重叠”，它是指，两个或多个盒子（可能相邻也可能嵌套）的相邻边界（其间没有任何非空内容、补白、边框）重合在一起而形成一个单一边界。 通过图示可以直观的理解外边距塌陷的几种情况。 当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生合并： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的顶和底边界也发生合并： 假设有一个空元素，它有边界，但是没有边框或填充。在这种情况下，顶边界与底边界就碰到了一起，它们会发生叠加： 为什么存在外边距塌陷？外边界塌陷乍看上去可能显得有些奇怪，但它是有实际意义的。以由几个段落组成的典型文本页面为例（见下图）。第一个段落上面的空间等于段落的顶边界。如果没有边界叠加，后续所有段落之间的边界将是相邻顶边界和底边界的和。这意味着段落之间的空间是页面顶部的两倍。如果发生边界叠加，段落之间的顶边界和底边界就叠加在一起，这样各处的距离就一致了。简单来说，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，就不会产生双倍的距离。 不会出现外边距塌陷的情况 水平边距永远不会重合。 在规范文档中，2个或以上的块级盒模型相邻的垂直margin会重叠。最终的margin值计算方法如下： 全部都为正值，取最大者； 不全是正值，则都取绝对值，然后用正值减去最大值； 没有正值，则都取绝对值，然后用0减去最大值。 注意：相邻的盒模型可能由DOM元素动态产生并没有相邻或继承关系。 相邻的盒模型中，如果其中的一个是浮动的（float），垂直margin不会重叠，并且浮动的盒模型和它的子元素之间也是这样。 设置了overflow属性的元素和它的子元素之间的margin不被重叠（overflow取值为visible除外）。 设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，并且和他们的子元素之间也是一样。 设置了display:inline-block的元素，垂直margin不会重叠，甚至和他们的子元素之间也是一样。 如果一个盒模型的上下margin相邻，这时它的margin可能重叠覆盖（collapse through）它。在这种情况下，元素的位置（position）取决于它的相邻元素的margin是否重叠。 如果元素的margin和它的父元素的margin-top重叠在一起，盒模型border-top的边界定义和它的父元素相同。 另外，任意元素的父元素不参与margin的重叠，或者说只有父元素的margin-bottom是参与计算的。如果元素的border-top非零，那么元素的border-top边界位置和原来一样。 一个应用了清除操作的元素的margin-top绝不会和它的块级父元素的margin-bottom重叠。 注意，那些已经被重叠覆盖的元素的位置对其他已经重叠的元素的位置没有任何影响；只有在对这些元素的子元素定位时，border-top边界位置才是必需的。 根元素的垂直margin不会被重叠。 外边距塌陷时的解决方法虽然外边距的重叠有一定的意义，但有时候我们在设计上却不想让元素之间产生重叠，那么可以有如下几个建议可供参考： 外层元素padding代替 内层元素透明边框border:1px solid transparent; 内层元素绝对定位postion:absolute; 外层元素overflow:hidden; 内层元素加float:left;或display:inline-block; 内层元素padding:1px; 底部元素设置为浮动float:left; 底部元素的position的值为absolute/fixed 在设置margin-top/bottom值时统一设置上或下 参考文章CSS 外边距(margin)重叠及防止方法 —— blog 什么是外边距重叠，重叠的结果是什么？ —— 简书 CSS中margin边界叠加问题及解决方案 —— 51CTO CSS外边距(margin)重叠及防止方法 —— 掘金 如何解决外边距叠加的问题？ —— 知乎 子元素的margin-top影响父元素问题描述因为当时的代码没有保留，我们写一个最简单的例子来重现这种情况。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; &#125; html, body &#123; background-color: #cccccc; &#125; .container&#123; width: 200px; height: 200px; background-color: #999999; &#125; .container h2&#123; margin-top: 50px; border: 10px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;sub content&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段代码运行后，展现的效果如下图。 只有一张图也许不够清晰，我们添加一些标注： 我们为h2添加一个border，可以更加直观地看到问题。 12345678910111213141516*&#123; margin: 0px; padding: 0px; &#125;html, body &#123; background-color: #cccccc;&#125;.container&#123; width: 200px; height: 200px; background-color: #999999;&#125;.container h2&#123; margin-top: 50px; border: 10px solid red;&#125; 很明显，我们并没有为深灰色的父级元素添加margin-top属性，明明是将margin-top属性添加到了红色边框的部分，但展现出来的效果却像是为父元素添加了margin-top属性。 上面的代码，我们预期得到的效果如下图。 我们通过chrome开发者工具来查看父元素和子元素。 父元素： 子元素： 可以发现，这个50px的margin-top依旧属于子元素。 问题分析来看css2.1盒模型中规定的内容： 123In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin.所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔。 可以发现，这个问题属于第一个问题中的父子元素外边距塌陷问题。 解决方案 父级元素或子元素使用浮动或者绝对定位absolute（因为浮动或绝对定位不参与margin的折叠） 父级元素overflow:hidden; 父级元素设置padding（破坏父子元素的外边距之间没有非空内容的折叠条件） 父级元素设置border（破坏父子元素的外边距之间没有非空内容的折叠条件） 我们采取上述任意一种解决方案，都可以发现显示效果恢复正常。 参考文章子元素margin-top为何会影响父元素？ —— CSDN 子元素应用margin-top为何会影响父元素【转】 子元素浮动导致父元素高度塌陷在使用float属性的时候，我们经常可以碰到如下图所示这种父元素高度塌陷的情况。 想要理解这种情况，首先要理解浮动是什么。 关于浮动浮动是样式编写中经常使用到的一个属性，对于浮动的理解简单来说就是五个字：“脱离文档流”。来看一下官方对于浮动的解释： 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 子元素浮动导致的父元素高度塌陷如果对浮动有了一个清晰的认识，也就不难理解父元素为什么会“塌陷”。子元素脱离了普通文档流而父元素没有，因此处于普通文档流中的父元素就会“表现得就像浮动框不存在一样”，对于父元素来说，它的子元素就像不存在一样，因此高度也就“塌陷”了。 一旦出现了这种父元素高度塌陷问题，应该如何解决？ 方法一：为某个子元素设置clear属性 如下图右侧示例。 这种方法能够实现我们希望的效果，但通常出现高度塌陷的父元素，其子元素基本均是浮动元素，如果找不到一个可以应用清理的元素，我们就只能添加一个空元素并且对它应用清理，这部分代码实际上是多余的。 方法二：对容器 div 进行浮动 这种方法是最容易理解的方法了。既然子元素浮动后脱离了普通文档流从而导致处于普通文档流中的父元素高度塌陷，那么只要让父元素也一起浮动，它就可以再次感知到子元素的存在了，高度自然也会被子元素撑开。但这种方法也有不尽人意的地方，那就是下一个处于普通文档流中的父元素也会受到这个浮动元素的影响。 要解决这个问题，可以对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记，并且能够实现我们想要的效果。 方法三：为float元素的父元素添加overflow:hidden 为浮动元素的父元素添加overflow:hidden;即可解决这种塌陷问题。 只要给外面大容器加上overflow:hidden的属性，可以解决IE7和火狐浏览器下的清除浮动问题，但是IE6下不生效，所以我们还需要使用zoom这个IE的私有属性来达到彻底清除浮动的兼容效果，代码如下。 12345#container &#123; border: 1px solid green; overflow: hidden; zoom: 1;&#125; 方法四：使用after伪对象清除浮动 代码如下。 1234567#container:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden;&#125; 参考文章CSS 浮动 —— w3school CSS中子元素浮动导致父元素高度塌陷解决方案 —— CSDN HTML的文档流和文本流分别是什么？ —— 知乎 clear属性 —— w3school]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《You don't know JS》——作用域和闭包]]></title>
    <url>%2F2018%2F09%2F25%2F%E3%80%8AYou-don-t-know-JS%E3%80%8B%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文来自《You don&apos;t know JS》一书，所用引用内容禁止商用。 内容概述本书上卷的第一部分主要讲解了作用域和闭包。作者深入解析了作用域、编译器以及引擎在JavaScript代码运行前及运行时具体做了哪些事情，在读者对各部分的职责有所了解之后，深入讲解了JavaScript中的各种作用域以及JavaScript中的提升，最终在读者对作用域有了深入的理解之后，引出了闭包。这一部分在内容安排上层层递进，前一部分为后一部分的理解做了很好的铺垫，有助于读者真正理解类似“提升”、“闭包”等概念的本质。 这一部分的英语原文见github地址。 引擎、编译器与作用域关于JavaScript首先要明确的一个概念是，尽管通常将JavaScript归类为“动态”或“解释执行”语言，但JavaScript实际上是一门编译语言，但它与传统的编译语言不同，JavaScript不是提前编译的，编译结果也不能在分布式系统中进行移植。 尽管如此，JavaScript引擎进行编译的步骤和传统的编译语言非常相似。 通常来讲，传统编译语言的流程分为三部分：分词/词法分析、解析/语法分析、代码生成。与传统编译过程相比，JavaScript引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒内。 引擎、编译器与作用域现有一句代码var a = 2，现针对这句代码梳理一下JavaScript执行的过程以及引擎、编译器和作用域在这个过程中发挥的作用。 首先来看一下这三部分在代码执行过程中的职责： 引擎：从头到尾负责整个JavaScript程序的编译及执行过程。 编译器：负责语法分析及代码生成等。 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 理解了这三部分的具体职责之后，可以想到代码var a = 2的执行过程如下： 首先，这段代码会分为两部分进行处理，一部分（var a）由编译器在编译时处理，另一部分(a = 2)则由引擎在运行时处理。 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。 接下来编译器会为引擎生成运行时所需的代码，这些代码用于处理a = 2这个赋值操作。而引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续向上级作用域询问查找该变量，直到抵达最外层的作用域（也就是全局作用域）为止。 如果引擎最终找到了a变量，就会将2赋值给它；否则就会抛出异常。 LHS与RHS在上面的案例中，引擎会针对变量a进行查询，这种查询实际上是在查找a这个“容器”并为其赋值，我们将这种查询称为LHS查询。而有了LHS，不难想到还有一种查询称为RHS，那么“L”和“R”指代的是什么呢？ 是一个赋值操作的左侧和右侧。 需要注意的是，这里的“赋值操作”不只是一个=那么简单，代码中还会存在一些隐式的赋值操作，比如函数的形参。 下面详细的解释一下LHS和RHS。 当变量出现在赋值操作的左侧时进行LHS查询，出现在非左侧时进行RHS查询。换句话说，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从而可以对其赋值。 举一个RHS的例子：console.log(a);。这句代码中对a的引用就是一个RHS引用，因为这里a并没有被赋予任何值。 异常为什么说区分LHS和RHS是十分重要的，这是因为这两种查询如果出现错误，相应的处理方式是不同的。 如果RHS查询在所有嵌套的作用域中找不到所需的变量，引擎就会抛出一个ReferenceError异常。 而当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非严格模式下。而如果是严格模式下，严格模式禁止自动或隐式地创建全局变量，因此在严格模式中LHS查询失败时，引擎会抛出同RHS查询失败时类似的ReferenceError异常。 还有一种异常情况是，如果RHS找到了一个变量，但是代码中尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，那么引擎会抛出一个TypeError异常。 作用域的嵌套上文中提到，如果引擎在当前作用域内找不到需要的变量，就会继续向上级作用域询问查找该变量。 这里有一个小技巧，我们可以将作用域想象成几个逐级包含的气泡。没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 还有一点要注意的是，作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”，内部的标识符“遮蔽”了外部的标识符。关于全局变量，我们可以通过window.xxx来访问被同名变量所遮蔽的全局变量。 词法作用域词法作用域的简介简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。 词法作用域查找只会查找一级标识符，类似foo.bar.baz，词法作用域只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。 欺骗词法作用域如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”词法作用域呢？ JavaScript中有两种机制来实现这个目的。但一定要注意的是，欺骗词法作用域会导致性能下降。 这两种机制分别是eval()函数和with关键字。 eval()函数的原理是，它接受一个字符串作为参数，将其中的内容视为好像在书写时就存在于程序中这个位置的代码。案例如下。 1234567function foo(str, a) &#123; eval(str); // 欺骗 console.log(a, b);&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1); // 1, 3 默认情况下，如果eval()中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对eval()所处的词法作用域进行修改。 在严格模式下，eval()在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。 JavaScript中还有其他一些功能效果和eval()很相似，setTimeout()和setInterval()的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能也已经过时并且不被提倡，不要使用它们。new Function()函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成函数的形参）。这种构建函数的语法比eval()略微安全一些，但也要尽量避免使用。 with的原理是，它可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 需要注意的是，尽管with块可以将一个对象处理为词法作用域，但这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。 案例如下： 1234567891011var obj = &#123; a: 1, b: 2, c: 3&#125;with (obj)&#123; a = 3; b = 4; c = 5;&#125; 在严格模式下，with会被完全禁止。 上面的两种方案都极度不推荐使用，原因有三。 安全性过低 会受到严格模式的影响 降低性能 关于性能方面作些解释，JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了eval()和with，它只能简单地假设关于标识符位置的判断都是无效的，因为它无法知道eval()和with会对词法作用域作出什么修改。最悲观的情况是，如果出现了eval()和with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 函数作用域和块作用域函数作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。 关于函数作用域，因为概念比较清楚，这里不再过多赘述。 目前来讲需要注意的一点是，函数的形参也是归属于当前函数作用域范围内的。 关于隐藏软件设计中有这样一个原则，我们应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来。 这个原则，通俗点说，就是某个函数中本应该私有的变量，就不要将其暴露在外部作用域中。具体思想类似于Java中的getter和setter，以及private变量等。 “隐藏”还能够带来一个好处，就是可以避免同名标识符之间的冲突。两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突，而冲突会导致变量的值被意外覆盖。 从很多第三方的库中可以看出这一点，通常来讲，这些库会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为学这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。 函数声明与函数表达式区分函数声明和函数表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。它们之间最重要的区别就是名称标识符会绑定在何处，函数声明会将名称标识符绑定在所在作用域中，而函数表达式则会将名称标识符绑定在函数表达式自身的函数中而不是所在作用域中，被隐藏在自身中意味着不会非必要地污染外部作用域。 函数的匿名和具名本书的作者不推荐使用匿名函数，原因有三： 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 作者根据以上观点，认为具名函数优于匿名函数，但匿名函数书写起来也确实简单快捷，很多库和工具也倾向于鼓励使用匿名函数风格的代码，个人习惯来讲比起过多的具名函数，也更喜欢匿名函数多一些，因此具体使用匿名函数还是具名函数有待进一步考究、积累与确认。 IIFEIIFE，代表立即执行函数表达式。 IIFE通常使用匿名函数表达式，但本书作者认为使用具名函数的IIFE也是一个值得推广的实践。 IIFE的原理是，由于函数被包含在一对( )内部，因此成为了一个表达式，通过在末尾加上另外一个( )可以立即执行这个函数。 关于IIFE有一个注意点，(function(){ ... })()和(function(){ ... }())这两种写法在功能上是一致的，选择哪种全凭个人喜好。 块作用域try/catch在使用var声明变量的时候，它写在哪里都是一样的，因为它们最终都会属于外部作用域。表面上来看，JavaScript似乎没有块作用域的相关功能。 但非常少人会注意到，JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。也因此，它可以在ES6之前的环境中作为块作用域的替代方案。举例如下： 123456789&#123; try&#123; throw undefined; &#125; catch(a)&#123; a = 2; console.log(a); // 2 &#125;&#125;console.log(a); // undefined 最后简单地看一下try/catch带来的性能问题。 首先，try/catch的性能的确很糟糕，但技术层面上没有合理的理由来说明它必须这么慢。从ES6转换器开始使用try/catch后，Traceur团队已经要求Chrome对try/catch的性能进行改进。其次，如果想要用IIFE来替代try/catch，但会涉及到一些问题，如果将一段代码中的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的this、return、break、continue都会发生变化。IIFE并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。 with除了try/catch块之外，with关键字也会创建一个块作用域。 ES6中的let和constES6中的let关键字可以将变量绑定到所在的任意作用域中（通常是{ ... }内部）。 而除了let之外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量），之后任何视图修改值的操作都会引起错误。 这里需要理解的一点是，let和const并不是形成了一个块作用域，而是将变量绑定到了所在的块作用域中，换句话说，let和const为其声明的变量隐式地劫持了所在的块作用域。 提升至此，有了块作用域这个概念之后，其实函数作用域和块作用域的行为是一样的，因此可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。 这里，我们从原理层面深入的理解一下“变量提升”。 首先回顾一下编译阶段，编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，我们可以这样考虑，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 举个例子，当看到var a = 2时，我们可能会认为这是一个声明，但JavaScript实际上会将其看成两个声明：var a和a = 2，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。因此，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面面，这个过程就叫作提升。 一定要注意的是，只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。因此区分好声明和赋值是十分重要的，对于函数来说，区分好是函数声明还是函数表达式也是十分重要的，看下面的例子。 123456foo();function foo() &#123; console.log(a); // undefined var a = 2;&#125; 上面的代码中，foo()是可以正常执行的，这是因为function foo()是一个函数声明，被提升了。另外值得注意的是，每个作用域都会进行提升操作，上面的代码中除了函数声明function foo()被提升之外，对变量a的声明也被提升到该函数作用域的顶部了。因此打印a出现的是undefined，而不是ReferenceError（RHS查询未找到该值时抛出的异常）。 捋清了上面的代码之后，我们再来看下面的代码。 12345foo(); // 不是ReferenceError，而是TypeErrorvar foo = function bar() &#123; // ...&#125; 这段代码中，函数并不是使用函数声明的方式，而是使用了函数表达式。可以发现函数表达式是没有被提升的。foo()能够被正常调用，没有返回ReferenceError，说明foo()找到了声明好的变量，这个变量就是下面的var foo部分，但foo()这句代码抛出了TypeError异常，通过前面的异常部分我们得知TypeError异常是试图对某个值进行非法操作，这里的非法操作就是试图对undefined进行函数调用，因此可以得知，函数表达式是不会被提升的。 函数优先函数声明和变量声明都会被提升，但是一个值得注意的细节是，函数会首先被提升，然后才是变量。 如果同时出现一个函数声明和一个变量声明，而该函数与该变量同名，那么函数声明会被首先提升，提升变量声明时会判定该声明为重复声明因而忽略。如果再出现下一个同名的函数声明，则该函数声明会覆盖掉之前的函数声明。 因此，这也说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题，不要这样使用。 小结提升的本质：JavaScript是一门编译语言，它的编译过程是在执行之前，JavaScript的编译器负责语法分析及代码生成，在这个过程中，有一部分工作就是需要找到所有的声明，并将它们联系到作用域（词法作用域）上。因此，JavaScript代码中的所有声明都会被首先处理，而这一过程看起来就像是声明部分的代码被提升到各自作用域的顶端。 var a = 2这一句代码分为两部分： var a声明部分，会被提升（首先处理） a = 2赋值部分，不会被提升（留在原地） function a() { ... }是函数声明，会被提升；(function a() { ... })是函数表达式，不会被提升。 闭包当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面我们来看一段代码，清晰地展示了闭包：12345678910111213function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 我们看到，函数bar()的词法作用域能够访问foo()的内部作用域，然后我们将bar()函数本身当做一个值类型进行传递。当我们调用baz()时，实际上只是通过不同的标识符引用调用了内部的函数bar()。 在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器来释放不再使用的内存空间，但“闭包”则可以阻止这件事情的发生，事实上内部作用域依然存在，而在使用这个内部作用域导致其一直存活的就是bar()。换句话说，因为bar()声明的位置特殊，它拥有涵盖foo()内部作用域的闭包，从而使得该作用域能够一直存活，以供bar()在之后任何时间进行引用。 bar()依然持有对该作用域的引用，而这个引用就叫作闭包。 当然，由此我们可以想到，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。即，无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。本质上，无论何时何地，如果将（访问它们各自词法作用域的）函数到处传递，就可以看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 闭包与IIFE通常认为IIFE是典型的闭包例子，但作者认为严格来讲它并不是闭包。因为IIFE并不是在它本身的作用域以外执行的，它在定义时所在的作用域中执行。 作者认为，尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此IIFE的确同作用域息息相关，即时它本身并不会真的创建作用域。 闭包与循环看下面的代码。 12345for (var i=1; i&lt;=5; i++)&#123; setTimeout(function timer()&#123; // 这里是按照作者推荐的具名函数的方式使用的 cosole.log(i); &#125;, i*1000);&#125; 看到这段代码，我们的预期是分别输出数字1~5，每秒一次，每次一个。但实际上，这段代码会以每秒一次的频率输出五次6。 这是因为，根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此，实际上所有函数共享一个i的引用，而循环结构让我们误认为背后还有更复杂的机制在起作用，但其实没有。如果将延迟函数的回调重复定义五次，完全不使用循环，那它同这段代码是完全等价的。 因此，我们需要借助闭包，为每一次循环赋予一个独立的作用域，也就是赋予每次循环一个独立的i。 1234567for (var i=1; i&lt;=5; i++)&#123; (function() &#123; setTimeout(function timer()&#123; // 这里是按照作者推荐的具名函数的方式使用的 cosole.log(i); &#125;, i*1000); &#125;)();&#125; 那么上面这段代码可行吗？ 答案是否定的，这是因为我们的IIFE只是一个什么都没有的空座用于，它需要有自己的变量，用来在每个迭代中储存i的值才可以为我们所用。 12345678for (var i=1; i&lt;=5; i++)&#123; (function() &#123; var j = i; setTimeout(function timer()&#123; // 这里是按照作者推荐的具名函数的方式使用的 cosole.log(j); &#125;, j*1000); &#125;)();&#125; 这段代码就可以正常工作了，我们可以再进行一些优化。 1234567for (var i=1; i&lt;=5; i++)&#123; (function(j) &#123; setTimeout(function timer()&#123; // 这里是按照作者推荐的具名函数的方式使用的 cosole.log(j); &#125;, j*1000); &#125;)(i);&#125; 在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 但其实这段代码还可以更简洁。 本质上我们在做的事情是，将一个块转换为一个可以被关闭的作用域，这就会让我们联想到之前介绍过的let声明，它可以用来劫持块作用域，并在这个块作用域中声明一个变量。 12345funtion (let i=1; i&lt;=5; i++)&#123; setTimeout(function timer()&#123; // 这里是按照作者推荐的具名函数的方式使用的 cosole.log(i); &#125;, i*1000);&#125; 上面这段代码，完全可以实现我们的预期，但并没有过多冗余代码，只是将var换为let即可。 闭包与模块模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 根据上面的定义，我们可以联想到，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 动态作用域我们知道JavaScript中的作用域是词法作用域，而与之相对的是动态作用域，这里大致介绍一些动态作用域与词法作用域的区别。 主要的区别在于：词法作用域是在写代码或者说定义时确定的，而动态作用域时在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 JavaScript中的this机制，某种程度上很像动态作用域。 关于this这里简单的提一下this，之后的第二部分还会有详细的说明。 首先需要明确的一点是，this是在运行时确定指向的。 我们知道，ES6中添加了一个特殊的语法形式用于函数的声明，叫做箭头函数。值得注意的一点是，箭头函数在涉及this绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this本来的值。因此，箭头函数并非是以某种不可预测的方式同所属的this进行了解绑定，而只是“继承”了函数的this绑定。 作者认为，箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了this绑定规则和词法作用域规则。但在代码中将两种风格混在一起使用，这种做法不值得提倡。因此作者更推荐使用bind()函数对this的指向进行绑定。 总的来说，ES6中的箭头函数，将原有的this绑定规则放弃掉了，而改为与词法作用域相同的规则，将程序员经常犯的错误标准化。bind函数保留了原来的this绑定规则，但依旧能够解决this指向在函数运行过程中改变的问题，因此作者更为推荐使用bind函数。 总之，无论以后的编程过程中使用哪种方式，心里一定要清楚箭头函数不仅仅是简化代码这么简单。]]></content>
      <categories>
        <category>You don&#39;t know JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6基础学习]]></title>
    <url>%2F2018%2F07%2F01%2FES6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ES6简介可以在js代码头部声明&#39;use strict&#39;;指定使用严格模式。 定义变量ES6中的let变量提升因为ES5中使用var定义变量的时候存在变量提升的问题。 123console.log(a); // undefined，因为变量a只声明未定义var a = 1;console.log(a); // 1 如果使用let来定义变量就不会出现变量提升的情况。 全局作用域下：123console.log(b); //b is not definedlet b = 2;console.log(b); // 1 私有作用域下：12345function fn()&#123; console.log(c); // c is not defined let c = 3;&#125;fn(); 变量重复定义使用let声明的变量不可以重复声明，无论是函数还是变量都不可以重复声明。 使用var声明的时候，后边的变量会覆盖前边的变量，导致最终变量的值模糊不清。1234567var d = 12;var d = 13;function d()&#123; console.log(d);&#125;console.log(d);d(); // d is not a function 使用let声明，一旦出现重复声明的变量就会报错。1234let e = 12;let e = 13; //Identifier &apos;e&apos; has already been declaredfunction e()&#123;&#125; //Identifier &apos;e&apos; has already been declaredconsole.log(e); //Identifier &apos;e&apos; has already been declared 预扫描代码123console.log(A);let A = 20;let A = 30; //Identifier &apos;A&apos; has already been declared 上面这段代码本来应该先报第一行的未定义错误，但真正执行时直接报第三行的重复声明错误。而let本应不使用变量提升。这个原因是，虽然使用let不会产生变量提升，但在代码执行之前，是会先扫描一遍代码中定义的变量是否存在错误，如果存在，则直接报错，代码也不再执行。 块级作用域概念在ES6中，所有被{}包裹的地方都会形成块级作用域。 12345let a = 10;if(a)&#123; let a = 1; console.log(a); //1&#125; 上面的代码，如果{}没有形成一个私有的块级作用域，则let a = 1;应该报错，但最终运行正常，说明{}形成了一个块级作用域，与全局变量之间互相不发生影响。 使用块级作用域代替闭包解决问题在没有块级作用域概念时，存在一个问题：123456789101112131415// html代码&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;//js代码let oLis = document.getElementsByTagName(&quot;li&quot;);for(var i=0; i&lt;oLis.length; i++)&#123; oLis[i].onclick = function()&#123; console.log(i); // 这里每次点击输出的都是4 &#125;&#125; 上面的代码本意是想实现点击对应的li时输出它的索引值，但上边因为循环不存在块级作用域，并且在点击事件产生时这些事件早就绑定完毕，i已经变成了4，因此导致每次输出的都是4。 这种情况以往我们使用闭包来解决，而现在使用下面的ES6代码就可以解决：123456let oLis = document.getElementsByTagName(&quot;li&quot;);for(let i=0; i&lt;oLis.length; i++)&#123; oLis[i].onclick = function()&#123; console.log(i); // 这里输出的就是当前li的索引 &#125;&#125; 代码和上面一样，只不过var变成了let。循环中每一次循环都形成一个块级作用域，因此绑定的事件中的i都是该块级作用域中的i，从而输出的就是当前的索引值。 块级作用域中未声明的变量12345let b = 100;function fn()&#123; console.log(b); // 100&#125;fn(); 上面的代码，块级作用域中虽然没有定义变量，但不会报错，因为全局作用域这种存在变量b。这也是刚才提到的，即使使用let不存在变量提升，但还是会在执行代码之前扫描一遍变量的定义，如果存在错误就直接报错。 自执行函数由于{}就可以指定一个块级作用域，因此ES6中的自执行函数存在一种简便写法如下。1234&#123; let c = 500; console.log(c); // 500&#125; 注意：因为js中使用{}来定义对象，因此使用eval函数将字符串转为对象的时候，一定要加一个()，避免转换为自执行函数。 const概念const定义的是静态变量，不能修改，并且必须赋值。不赋值或者修改静态变量就会报错。使用const定义的变量和let一样不可以重复声明。 12let a = 1;const a = 2; 上面的代码也会报错，提示变量不可以重复声明。 数组赋值数组解构赋值正常情况下声明多个变量可以使用下面的代码。1let a=1, b=2, c=3; 使用数组解构赋值，则上面的代码可以写为下面这种形式。12let [a, b, c] = [1, 2, 3];console.log(a, b, c); // 1 2 3 如果数组中需要赋值的元素比给出的值多，则没有值对应的那个元素的值为undefined。123let ary = [&quot;a&quot;, &quot;b&quot;];let [a, b, c] = ary; console.log(a, b, c); // a b undefined 上面的代码中变量c没有对应的值，因此输出会得到undefined。 如果数组中的元素比给出的值少，多余的值直接舍弃。123let ary = [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;];let [a, b, c] = ary; console.log(a, b, c); // aa bb cc 上面的代码中给出的dd这个值是多余的，不会被使用。 嵌套赋值12let [x, y, [s], [[f]]] = [1, 2, [3], [[4]]];console.log(x, y, s, f);// 1 2 3 像上面的这种书写形式被称为嵌套赋值，注意这里并没有定义数组，依旧是定义了四个变量。赋值的时候变量是怎么写的，赋給它的值就怎么写即可。 省略赋值本质上也是数组解析赋值。只不过不需要接收的值不使用变量接收即可，如下。123let ary = [1, 2, 3, 4, 5, 6];let [x,,,,y] = ary;console.log(x, y); // 1 5 上面的几个逗号中间本来应该是用于接收值的变量，现因为我们不需要，所以省略不写即可。 不定参数赋值可以使用...来标注某个参数，使它变为一个不定长参数，该参数是个数组。 12let [a, ...b] = [1, 2, 3, 4, 5];console.log(a, b); // 1 [2, 3, 4, 5] 上面的代码中，b接收了四个值，是个数组。 省略赋值和不定参数赋值可以结合使用。12let [,,x,,...y] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];console.log(x, y); // 3 [5, 6, 7, 8, 9, 0] 默认值123456let [f0, f1] = [1];console.log(f0, f1);// 1 undefined// 使用默认值let [f2, f3=2] = [1];console.log(f2, f3);// 1 2 在判断一个变量对应的位置是否有值的时候，是按照三等号判断严格相等。如果数组中成员不严格等于undefined则默认值不会生效。123let [f=1] = [undefined];let [f5=1] = [null];console.log(f,f5); // 1 null 关于执行顺序，下面的代码中，fn函数不会被执行，因为变量x对应的位置上有值。12345function fn()&#123; console.log(&apos;触发了fn函数&apos;);&#125;let [x=fn(),y=0] = [1];console.log(x); 对象赋值对象解构赋值对象解构赋值和数组结构赋值的原理差不多。但对象解构赋值是根据对象属性名进行匹配的，数组因为是有序的，因此可以有省略赋值的情况；而对象是无序的，因此不存在省略赋值。 变量名等于对象属性名的情况123456let obj = &#123; n1: &quot;p1&quot;, n2: &quot;p2&quot;&#125;let &#123;n1, n2&#125; = obj;console.log(n1, n2); // &quot;p1&quot; &quot;p2&quot; 如果要声明的变量名与对象中的属性名正好相等， 那么用上面这种写法即可。 变量名不等于对象属性名的情况如果要声明的变量名与对象中的属性名不相等，则使用下面的方式进行声明。注意哪个是声明的变量，哪个用于和值对应。123456let obj = &#123; n1: &quot;p1&quot;, n2: &quot;p2&quot;&#125;let &#123;n1: x1, n2: x2&#125; = obj;console.log(x1, x2); // &quot;p1&quot; &quot;p2&quot; 混合情况12let &#123;n1, n2:m1&#125; = obj;console.log(n1, m1);// &quot;p1&quot; &quot;p2&quot; 对象数组嵌套对象赋值和数组赋值可以混合使用，如下。123456let obj = &#123; a1: [1, 2, 3], a2: 123&#125;;let &#123;a2, a1:[x,y]&#125; = obj;console.log(a2, x, y); //123 1 2 一个较为复杂的例子：123let obj1 = &#123;s:&#123;n: &quot;1&quot;&#125;, n:[1, &quot;2&quot;, 3, &quot;4&quot;], m:[[1]]&#125;;let &#123;m:[x1], s:&#123;n&#125;, n:[,...m2]&#125; = obj1;console.log(x1, n, m2); // [1] &quot;1&quot; [&quot;2&quot;, 3, &quot;4&quot;] 一定要注意区分哪些是变量。 默认值如果出现需要赋值的变量在对象中不存在的情况，会输出undefined，如下。123let obj = &#123;y:2&#125;;let &#123;x, y&#125; = obj;console.log(x, y); // undefined 2 要解决这种情况，可以使用默认值。12let &#123;x=1, y&#125; = obj;console.log(x, y);// 1 2 上面的代码是变量名和对象中属性名相等的情况。 如果是变量名和对象中属性名不相等的情况，代码如下。12345let &#123;y: n&#125; = &#123;&#125;;console.log(n);// undefinedlet &#123;y: m=1&#125; = &#123;&#125;;console.log(m); // 1 注意，默认值生效的条件是对应对象属性的值必须严格等于undefined。12345678let &#123;a: cc=22&#125; = &#123;a: 12&#125;;console.log(cc); // 12let &#123;v=3&#125; = &#123;v: null&#125;;console.log(v); // nulllet &#123;v=3&#125; = &#123;v: undefined&#125;;console.log(v); // 3 如果解构嵌套的是一个对象，而子对象所在的父对象不存在，那么就会报错。如下。12let &#123;f: &#123;b&#125;&#125; = &#123;b: &apos;aa&apos;&#125;;console.log(b); // Cannot destructure property `b` of &apos;undefined&apos; or &apos;null&apos;. 上面的代码中，因为f的值为undefined，因此变量b相当于是在undefined中匹配名字为b的属性，这样使用就会报错。 其他问题赋的值不是一个对象如果使用对象赋值，而用于赋值的不是一个对象而是其他数据类型，那么JavaScript引擎会先使用Object()方法将该值转换为一个对象，然后再进行匹配。 12345678let &#123;x,y&#125; = 1;console.log(x, y); // undefined undefined//实际进行的转化过程如下console.log(Object(1)); // &#123;__proto__: Number&#125;let &#123;__proto__&#125; = 1;console.log(__proto__); //转换出来的对象中__proto__属性对应的Number对象 如果给出的值是数组的形式也是一样。12345let &#123;x,y&#125; = [1, 2];console.log(x, y); // undefined undefinedlet &#123;length,__proto__&#125; = [1, 2];console.log(length, __proto__); 上面的代码中实际上也是使用了Object([1, 2])语句，它转化出来的对象属性名是数字，因此无法调用。但转化出的对象中还有length和__proto__两个属性，可以调用。 需要注意的是，null和undefined是没办法被转换为对象的，因此如果使用对象赋值，而赋的值是null或者undefined，就会报错。 为已经声明的变量赋值如果已经声明了某个变量，想要再进行对象赋值，会出现什么情况呢？123let a;&#123;a&#125; = &#123;a: 1&#125;;console.log(a);// Uncaught SyntaxError: Unexpected token = 我们发现，上面的代码报错了。这是因为对于以{}开头的行，JavaScript引擎会将它解析为一个块级作用域，也就是一个代码块。为代码块使用等号，自然会报错。 那么如果非要先声明变量，再进行对象赋值应该如何操作？代码如下。123let a;(&#123;a&#125; = &#123;a: 1&#125;);console.log(a);// 1 刚才提到过，使用eval的时候为了避免被解析为代码块，需要加()。这里也是一样的，使用一个()将需要{}开头的行进行包裹，就可以避免该行被解析为一个代码块，自然也就能为a赋值。 注意，以后为了避免产生错误，应当避免将{}写在行首。 字符串字符串的解构赋值字符串的解构赋值和数组解构赋值比较类似。字符串的解构赋值中，是将字符串转换为一个类似数组的对象。因为这个对象有length属性，因此可以使用对象解构赋值来获取这个length的值。如下。12345let [x, y, z] = &apos;123&apos;;console.log(x, y, z); // 1 2 3 let &#123;length&#125; = &apos;12345&apos;;console.log(length); // 5 字符串中的方法includes()ES5中提供了一个字符串的方法indexOf()，它用于判断字符串中是否含有某个字符，如果含有返回该字符的索引值，没有则返回-1。 ES6中新增了一个字符串方法includes()，该方法也是用于判断字符串中是否含有某个字符，但返回的值不太一样。如果字符串中含有该字符则返回true，没有则返回false。这就省去了之前判断是否为-1的步骤。这个方法可以有第二个参数，第二个参数指定了开始查找的索引，默认值是0。 123let str = &apos;adfjlkfjsdll&apos;;console.log(str.includes(&apos;a&apos;)); // trueconsole.log(str.includes(&apos;a&apos;,2)); // false startsWith()、endsWith()startsWith()用于判断一个字符串是否以某个字符开头，是则返回true，不是则返回false。endsWith()用于判断一个字符是否以某个字符结尾，是则返回true，不是则返回false。这两个方法都可以有第二个参数，用于指定开始查找的位置，默认是0。 1234let str = &apos;adfjlkfjsdll&apos;;console.log(str.startsWith(&apos;a&apos;)); // trueconsole.log(str.endsWith(&apos;f&apos;)); // false console.log(str.startsWith(&apos;f&apos;,2)); // true repeat()repeat(n)方法用于将字符串重复n次返回，并且它不会影响原字符串。 1234567891011121314151617console.log(str.repeat(2), str);//adfjlkfjsdlladfjlkfjsdll adfjlkfjsdll //小数会向下取整console.log(str.repeat(2.6));//adfjlkfjsdlladfjlkfjsdll//负数和Infinity会报错// console.log(str.repeat(-2));// console.log(str.repeat(Infinity));//0到-1之间的小数会先向下取整，得到0，因此返回空串console.log(str.repeat(-0.3));//&apos;&apos;//NaN也就相当于0次，因此返回空串console.log(str.repeat(NaN));//&apos;&apos;//其他数据类型，会先转换为数字类型console.log(str.repeat(&quot;2&quot;));//adfjlkfjsdlladfjlkfjsdll 模板字符串ES6中可以使用一对反引号来标记模板字符串。在模板字符串中可以自由的使用单双引号、调用变量、调用函数、带格式输出换行和空格、实现简单运算等。 在模板字符串中使用变量在es6的模板字符串中，可以使用${}来调用某个变量。1234let str = &apos;hello es6&apos;;document.body.innerHTML = `&lt;h2&gt;$&#123;str&#125;&lt;/h2&gt;`;//页面上会出现hello es6 模板字符串会保留格式直接输出一个带有换行和空格的模板字符串，换行和空格都会被保留。 1234567891011121314//es5中想要输出换行console.log(&apos;hello\nworld&apos;);//es6中反引号引起来的部分可以直接保留格式let s = `testenter br!`console.log(s);/*打印出来的值如下，保留了换行和空格test enter br ! */ 反引号的输出可以使用\对模板字符串中的反引号进行转义并输出。 12let s1 = `test\`output`;console.log(s1);// test`output 在模板字符串中进行简单运算在${}中可以进行一些简单的运算如下。1234let x = 1;let y = 3;let s2 = `$&#123;x&#125; + $&#123;y&#125; = $&#123;x+y&#125;`;console.log(s2); 函数的调用${}中除了可以进行简单运算之外，还可以调用函数。12345function fn()&#123; return &quot;xxx&quot;;&#125;let s3 = `函数fn输出的结果是$&#123;fn()&#125;`;console.log(s3);//函数fn输出的结果是xxx 调用函数的时候还可以传入参数。123456function fn1(name)&#123; return name;&#125;let name = &apos;test&apos;;let s4 = `函数fn1输出的结果是$&#123;fn1(name)&#125;`;console.log(s4);//函数fn1输出的结果是test 使用模板字符串本身123let s5 = &apos;return &apos; + &apos;`Hello $&#123;wd&#125;`&apos;;let fun = new Function(&apos;wd&apos;, s5);console.log(fun(&apos;test!&apos;)); //Hello test! 上面的代码和下面的代码是等价的，其中在return 语句后面使用了模板字符串本身。12345function fun(wd)&#123; return `Hello $&#123;wd&#125;`;&#125;fun(&apos;test!&apos;);// 输出Hello test! 数组的扩展Array类上的方法Array.of()Array()方法可以将多个参数转换为一个数组返回。需要注意的是，当传入一个参数的时候，该参数是作为数组的长度被使用的，比如传入一个n，返回的值是有n个空位的数组[empty * n]。 如果想要得到数组[n]，需要使用Array.of(n)。这样n就不会被作为数组的长度使用了。 Array.of()与Array()作用一样，只有一点区别是当传入一个参数的时候Array.of()返回当前参数组成的数组，而Array()根据当前参数创建对应个数个空位的数组。 123console.log(Array(1, 2, 3)); // [1, 2, 3]console.log(Array(4)); // [empty * 4]console.log(Array.of(4)); // [4] Array.from()这个方法接收数组或类数组作为参数，返回一个新数组。当参数为一个数组的时候，这个方法相当于将该数组克隆了一份；而当参数为一个类似数组的对象时，这个方法可以将类数组转换为真正的数组。 12345678910//传入一个数组相当于数组的拷贝let ary = [1, 2, 3, 4];let newAry = Array.from(ary);console.log(newAry); // [1, 2, 3, 4]//传入一个类数组是将类数组对象转换为真正的数组function toArray()&#123; return Array.from(arguments); // arguments是一个类似数组的对象&#125;console.log(toArray(1, 2, 3, 4)); // [1, 2, 3, 4] Array原型上的方法copyWithin()该方法的用法是copyWithin(target, start, end)，其中参数target必填，指定从该位置开始替换数据；参数start选填，默认值为0，指定从该位置开始读取数据；参数end选填，默认值为数组的长度，指定到该位置前停止读取数据，该位置不被包括。 这个方法会改变原数组，它会将原数组从target位置开始，使用[start,end)位置的数据进行替换，超出数组长度的部分会被舍弃掉。 12345let ary = [1, 2, 3, 4, 5, 6, 7, 8];console.log(ary.copyWithin(0,2,5), ary); // [3, 4, 5, 4, 5, 6, 7, 8] [3, 4, 5, 4, 5, 6, 7, 8]let ary1 = [1, 2, 3, 4, 5, 6, 7, 8];console.log(ary.copyWithin(5,2,6));// [1, 2, 3, 4, 5, 3, 4, 5] find()、findIndex()find()方法的用法如下：1234567let ary = [1, 2, 3, 4, 5, 6, 7, 8];ary.find(function(item, index, input)&#123; // item: 当前项 // index: 索引值 // input: 原数组 return true/false;&#125;); find方法会遍历数组，传入数组的每一项去执行这个函数，一旦函数返回值为true，就停止查找并返回当前项。如果直到遍历完整个数组都没有返回true，则最终结果返回undefined。 1234let ary = [1, 2, 3, 4, 5, 6, 7, 8];console.log(ary.find(function(item, index, input)&#123; return item == 4; // 4&#125;)); 上面的代码查找数组中值为4的项并返回，如果不存在这样的项，最终会返回undefined。 findIndex()方法和find()方法作用相同，只不过findIndex()方法返回的是匹配项的索引值。可以理解为find()返回的是item，而findIndex()返回的是index。如果直到遍历完整个数组都没有返回true，则findIndex()方法会返回-1。 fill()fill(value, start, end)方法用于替换数组中匹配位置的值为value，并且会改变原数组。其中，参数value是必填的，用来指定替换的值；参数start是选填的，默认值为0，指定开始替换的位置；参数end是选填的，默认值为数组的长度，指定停止替换的位置，该位置不包括在内。 123456let arr = [1, 2, 3, 4, 5];console.log(arr.fill(1)); // [1, 1, 1, 1, 1]console.log(arr.fill(2, 4, 5)); // [1, 1, 1, 1, 2]//初始化一个有七个1的数组console.log(Array(7).fill(1)); // [1, 1, 1, 1, 1, 1, 1] includes()es5中要判断数组中是否含有某一项，使用的方法是indexOf()或lastIndexOf()，这两个方法如果查找到数组中存在该项则返回该项的索引值，而如果不存在则返回-1。不便于判断。 因此es6中引进了includes()方法。 includes()方法的作用是判断数组中是否包含某一项，如果有就返回true，没有就返回false。 123let arr = [1, 2, 3, 4, 5];console.log(arr.includes(1)); // trueconsole.log(arr.includes(&apos;1&apos;)); //false 数组中的空位空位和undefined的概念是不一样的。123456let ary1 = Array(3); // 3个空位let ary2 = [undefined, undefined, undefined];console.log(1 in ary1); // false，说明数组中不存在键1console.log(1 in ary2); // true，说明数组中存在键1console.log(ary1, ary2); // 空位是没有键值的，只有length属性。undefined有键值，键为对应的数字，值为undefined。 如果要产生空位，一种方法是使用Array()方法只传入一个参数。另一种方法是在为数组赋值是直接写逗号。12var ary3 = [1,,,2,,];console.log(ary3.length); // 5，注意最后一个逗号后边没有内容了 ES5中方法对空格的处理不太一致，大部分都是跳过空位，但也有一些方法不会跳过空位，会将空位看作undefined处理。而ES6中对空位的处理就统一看为undefined进行处理，不会跳过。1234567891011121314151617//es5中//forEach方法会跳过空位ary3.forEach(function(item) &#123; console.log(item);&#125;); // 1 2//map方法不会跳过空位console.log(ary3.map(function(item) &#123; return item;&#125;)); // [1, empty × 2, 2, empty]//es6中ary3.find(function(item)&#123; console.log(item);&#125;); // 1 undefined undefined 2 undefined 数组的遍历123456789101112131415161718192021222324let ary = [1, 2, 3, 4, 5];// for-in循环默认遍历键值，通常用于对象来取得对象的属性名for (var key in ary)&#123; console.log(&quot;索引 &quot; + key);&#125;// 对于数组，使用for-of循环比较好for (let item of ary)&#123; console.log(&quot;当前项 &quot; + item);&#125;// 如果想用for-of循环取得索引值for (let key of ary.keys())&#123; console.log(key);&#125;// 如果索引值和当前项都想取得for (let entry of ary.entries())&#123; console.log(entry); // 这里返回的entry是一个数组，第一个值是索引第二个值是当前项&#125;//使用数组解析变量接收entries返回的值for (let [key, value] of ary.entries())&#123; console.log(key, value);&#125; 函数的扩展函数参数问题参数默认值函数的参数是可以有默认值的，它和数组解析赋值一样，只有在传入参数为undefined时才会走默认值。1234function fn1(x=&quot;x&quot;, y)&#123; console.log(x, y);&#125;fn1(1, 2); // 1 2 要注意下面这两种写法的区别：1234567891011function fn2(&#123;x=0, y=0&#125; = &#123;&#125;)&#123; return &#123;x,y&#125;;&#125;console.log(fn2());// &#123;x: 0, y: 0&#125;console.log(fn2(&#123;x:1&#125;)); // &#123;x: 1, y: 0&#125;function fn3(&#123;x,y&#125; = &#123;x: 0, y: 0&#125;)&#123; return &#123;x,y&#125;;&#125;console.log(fn3());// &#123;x: 0, y: 0&#125;console.log(fn3(&#123;x:1&#125;)); // &#123;x: 1, y: undefined&#125; 注意，一般都会把默认值放在后面。1234function fn4(x, y=2, z)&#123; console.log(x,y,z);&#125; // fn4(1,,2); //这样写会报错 就比如上边的代码，只给中间的参数默认值，但之后的第三个参数又不能不赋值，直接写逗号跳过某个参数又会报错。因此这种方式基本没用，通常都将有默认值的参数放在最后。 参数集合长度123456789101112131415function fn5()&#123; //arguments.length表示实参的长度 console.log(arguments.length); // 5&#125;fn5(1, 2, 3, 4, 5);//没有默认值时，函数.length表示形参的长度function fn6(x, y, z)&#123;&#125;fn6();console.log(fn6.length); // 3//有默认值时，表示默认值的位置function fn7(x, y=2, z)&#123;&#125;fn7();console.log(fn7.length); // 1 参数的作用域123456let n=10, m=20;function fn1(x=n, y=m)&#123; let n=1, m=2; console.log(x, y);&#125;fn1(); // 10 20 上面的例子说明，形参中的变量是不会再函数内部去寻找的。 12345let x = 10;function fn2(x=1, y=x)&#123; console.log(x, y);&#125;fn2(); // 1 1 上面的例子说明，形参的小括号内是一个单独的作用域，在为形参赋默认值时，首先查找小括号自己的作用域中是否有这样的变量，如果没有再在上一级作用域中找。 函数中的扩展运算符基本使用扩展运算符...可以将数组变成非数组，也可以将非数组变成数组。 可以变成数组的非数组包括：字符串、类似数组的对象等具有length属性的对象。 将数组变为非数组：12let ary = [1, 2, 3];console.log(...ary); // 1 2 3 将非数组变为数组：123456789//字符串let str = &quot;12345&quot;;console.log([...str]); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]//类似数组的对象function fn1()&#123; return [...arguments].sort();&#125;console.log(fn1(1, 5, 6, 4, 2, 3)); // [1, 2, 3, 4, 5, 6] 扩展运算符的应用 求数组中的最大值。 12345678910let ary1 = [23, 52, 35.2, 562, 11, 49];// 求最大值通常使用Math.max方法，但max方法不能接收数组作参数，因此通常用以下两种方式来使用// 使用eval函数console.log(eval(&quot;Math.max(&quot; + ary1 + &quot;)&quot;)); //562// 使用apply方法console.log(Math.max.apply(null, ary1));//562//现在可以使用扩展运算符来直接转化数组console.log(Math.max(...ary1)); // 562 拼接数组 123let a1 = [1, 2, 3], a2 = [4, 5, 6];console.log(a1.concat(a2));//[1, 2, 3, 4, 5, 6]console.log([...a1,...a2]);//[1, 2, 3, 4, 5, 6] 函数的name属性一个具名函数的name属性的值就是函数的名字。一个匿名函数的name属性的值是&#39;&#39;空字符串。 123456function fn()&#123;&#125;;/*let fn1 = function ()&#123;&#125;;console.log(fn.name); // fnconsole.log(fn1.name); // fn1console.log((function()&#123;&#125;).name); // &apos;&apos;*/ 有几个特例需要注意：12345678910function fn()&#123; console.log(this);&#125;;//bind方法比较特殊let obj = &#123; test: &apos;test&apos;&#125;;var fn2 = fn.bind(obj);fn2(); //&#123;test: &quot;test&quot;&#125;，bind方法改变了fn中this的指向。console.log(fn2.name); // bound fn ，指这个函数来自fn 123//通过构造函数创建的函数，即new Function(&quot;形参&quot;,&quot;函数体&quot;)let f = new Function (&quot;n&quot;,&quot;return n&quot;);console.log(f.name); // anonymous 几个特例：bind方法绑定的函数name属性的值都为bound xxx，其中xxx是它绑定的函数的名字。通过构造函数创建的函数name属性的值都为anonymous，意思是匿名。 箭头函数箭头函数的写法如下：1234let fn=(x)=&gt;&#123; let a = 1; return a;&#125; 箭头函数有个特例，如果函数是只有一个形参x，并且函数体只有一句return时，可以使用下面的简写。1x=&gt;x 箭头中的this也需要注意。箭头函数是没有this指向，它里面的this指向上一级作用域中的this。 对象的扩展对象属性的简洁表示1234567891011let a = &quot;aa&quot;,b = &quot;bb&quot;;let obj=&#123; a: &apos;aaaaa&apos;, [a]: &apos;AAA&apos;, // 一种简洁的表达方式，属性名是变量a [a + b]: &apos;A+B&apos;, // 一种简洁的表达方式，属性名是变量a+b fn: funtion()&#123;&#125;, // 可以简写为fn1的形式 fn1()&#123;&#125;&#125;;console.log(obj.a); // aaaaaconsole.log(obj[&quot;a&quot;]); // aaaaa，这里注意如果中括号中的a不加引号，意思是变量aconsole.log(obj); // &#123;a: &quot;aaaaa&quot;, aa: &quot;AAA&quot;, aabb: &quot;A+B&quot;&#125; Object类上的方法Object.is()基本使用Object.is()方法用于判断两个对象的值是否相等。之前使用严格相等的时候，NaN和任何值都不相等，甚至是它本身。而is方法就解决了这个问题。12console.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // true ES6中对NaN的处理都是比较友好的。比如数组的includes方法，也能够识别NaN，如下。12let ary = [1, 2, NaN, NaN, 1, 3];console.log(ary.includes(NaN)); // true 上面的代码用来检测ary数组中是否含有NaN，而如果使用双等号或三等号进行判断则是判断不出来的。 案例：数组去重实现数组去重，思路是循环原数组，创建一个新的数组，如果新数组中已经存在该元素就不放入，不存在则放入。 1234567891011121314let ary = [1, 2, NaN, NaN, 1, 3];let arr = [];ary.forEach((item)=&gt;&#123; let flag = true; for(var i=0; i&lt;arr.length; i++)&#123; if(Object.is(item, arr[i]))&#123; // 这里如果使用双等或三等，NaN是去不掉的 flag = false; &#125; &#125; if(flag)&#123; arr.push(item); &#125;&#125;);console.log(arr); // [1, 2, NaN, 3] Object.assign()Object.assign(Obj1, Obj2)合并对象方法，是将对象Obj2中的内容合并到Obj1上，并返回Obj1。 12let obj1 = &#123;a: &quot;1&quot;&#125;, obj2 = &#123;b:1&#125;;console.log(Object.assign(obj1, obj2),Object.assign(obj1, obj2)==obj1); // &#123;a: &quot;1&quot;, b: 1&#125; true 如果出现obj2中的属性名和obj1中某个属性名相同的情况，则会发生覆盖。12let obj1 = &#123;a: &quot;1&quot;&#125;, obj2 = &#123;a:1&#125;;console.log(Object.assign(obj1, obj2),Object.assign(obj1, obj2)==obj1);// &#123;a: 1&#125; true Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor()方法用于获取对一个对象属性的描述。 我们知道字符串的length属性不可枚举也不可修改，而数组的length属性可以修改但也不可枚举。要查看这些对象属性的描述，就要使用这个方法。注意：这个方法只能获取私有属性，共有属性是不能获取的。 12345let str = &quot;123&quot;;console.log(Object.getOwnPropertyDescriptor(str, &quot;length&quot;));// &#123;value: 3, writable: false, enumerable: false, configurable: false&#125;console.log(Object.getOwnPropertyDescriptor([1, 2, 3], &quot;length&quot;));// &#123;value: 3, writable: true, enumerable: false, configurable: false&#125; 属性的遍历for-infor-in方法前面已经讲过就不再赘述了。 Object.keys()Object.keys()方法返回的是一个数组，返回对象自身私有的所有可枚举的属性。 Object.getOwnPropertyNames()Object.getOwnPropertyNames()方法返回的是一个数组，返回对象自身私有的所有属性，包括不可枚举属性。 Set和Map数据结构Set创建SetSet可以通过构造函数创建，传入的参数是一个数组，返回值是一个Set的实例。Set自身具备一个功能是将传入的数组去重后返回对应的Set实例。 Set对象中存在一个[[Entries]]，类型是Array，它里面的每一项元素展开后都只有value没有键值。 12let set1 = new Set([1, 2, 4, 1, 2, 3, NaN, NaN]);console.log(set1); // &#123;1, 2, 4, 3, NaN&#125; Set变为数组Set实例具有length属性，是一个类似数组的对象，可以将Set实例变为数组。12console.log([...set1]); // [1, 2, 4, 3, NaN]console.log(Array.from(set1)); // [1, 2, 4, 3, NaN] 案例利用Set实现数组去重。1234function fun (ary)&#123; return [...new Set(ary)]&#125;console.log(&apos;去重&apos;,fun([1, 2, 4, 1, 2, 3, NaN, NaN])); // 去重 [1, 2, 4, 3, NaN] Set原型上的方法其实任何类型的对象都可以查看它的__proto__属性，该属性指明了当前对象的类型，而该属性展开之后就可以查看该对象原型上的方法。 size()size()方法用于获取set的长度，相当于数组的length add()add()该方法用于添加set中原本不存在的值到set的最后，返回值是当前的实例。因为返回值是当前的实例，所以可以实现链式写法。 123let set = new Set([1, 2, 3, 4, 1, 2]);console.log(set);console.log(set.add(5).add(4)); // &#123;1, 2, 3, 4, 5&#125; has()has()方法用于判断集合中是否存在某一项，如果存在返回true，不存在返回false。 1console.log(set.has(1)); // true delete()delete()方法用于删除set中的某一项，删除成功返回true，删除失败返回false。12console.log(set.delete(1)); // trueconsole.log(set.delete(6)); // false clear()clear()方法用于清空set，没有返回值，即返回undefined。 12console.log(set.clear()); // undefinedconsole.log(set); // Set(0) &#123;&#125; 案例求两个数组的并集。12345let arr1 = [1, 2, 3, 4, 5, 6], arr2 = [2, 4, 6, 8, 10];function bingji(arr1, arr2)&#123; return [...new Set([...arr1,...arr2])];&#125;console.log(bingji(arr1, arr2)); // [1, 2, 3, 4, 5, 6, 8, 10] 求两个数组的交集1234567// 求两个数组的交集function jiaoji(arr1, arr2)&#123; return arr1.filter((item)=&gt;&#123; return arr2.includes(item); &#125;);&#125;console.log(jiaoji(arr1, arr2)); // [2, 4, 6] 求两个数组的差集1234567// 求两个数组的差集function chaji(arr1, arr2)&#123; return bingji(arr1, arr2).filter((item)=&gt;&#123; return !jiaoji(arr1, arr2).includes(item); &#125;);&#125;;console.log(chaji(arr1, arr2)); // [1, 3, 5, 8, 10] Map创建Map实例可以使用构造函数的方式来创建一个Map实例，参数是一个数组，并且数组中的每一项都是一个只有两项的数组，第一项作为键，第二项作为值。我们知道对象中的键只能是字符串，但是Map中的键可以是任意数据类型。 和Set一样，Map对象中也存在一个[[Entries]]，类型是Array，和Set不同的是它里面的每一项元素展开后都有key和value两项。 常用方法get()get(key)通过键值来获取某一项的值。 1console.log(map1.get(&quot;a&quot;)); // A set()set(key, value)方法，用来向map对象中设值。 12map1.set(2,&quot;js&quot;);console.log(map1); 上面的代码会将键为2值为js的键值对加入map实例对象中。 delete()delete()方法用于删除某个元素。 has()has()方法用于查看是否包含某个元素。 clear()clear()方法用于清空map对象。 案例将数组变成map12345678910// 将数组变成map// 1 =&gt; [1]// 2 =&gt; [1, 2]// 3 =&gt; [1, 2, 3]let ary = [1, 2, 3, 4, 5 ,6];let map = new Map();ary.forEach((item, index)=&gt;&#123; map.set(index+1, ary.slice(0, index+1));&#125;);console.log(map); forEach(), keys(), values(), entries()这些方法都可以用于map的遍历。 12345678910111213141516map.forEach((val, key, map)=&gt;&#123; // val：值 // key：键 // map：原map实例&#125;);for(var key of map.keys())&#123; // key：键&#125;for (var val of map.values())&#123; // val：值&#125;for(var [key, val] of map.entries())&#123; // val：值 // key：键&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记]]></title>
    <url>%2F2018%2F06%2F26%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ES6简介ES6简化了代码，提高了开发效率。其中最常用的几种功能是：解构赋值、箭头函数、Set和Map、异步操作、类与对象、模块化。 ES6项目构建基础架构基础架构分为几部分： 业务逻辑部分，包括页面和交互。 自动构建部分，编译、辅助。辅助又分为自动刷新（非常实用）、文件合并、资源压缩。 服务接口部分，包括数据和接口。 上面的基础架构结构具体如下图： 以上就是一个相对来说非常完善的基础架构。 任务自动化gulp任务自动化：减少人工操作，让电脑自动监听作出的操作并且自动响应。 gulp是一个工具，解决自动化构建，增强工作流程的一个工具。 学习gulp，应当首先去官网了解api，并且了解插件，然后通过实际经验学习gulp的使用。 编译工具（babel、webpack）babel现在十分流行，是用于编译ES6的工具，因为ES6目前是无法直接在浏览器上运行的。 webpack-stream的作用是webpack针对于gulp的支持。 代码实现代码实现的流程，首先创建一个ES6前端工程，然后完成目录结构、自动化构建、服务器搭建。 构建ES6的运行环境ES6项目构建主要分为几个部分：基础架构、任务自动化、编译工具、代码实现。 项目构建的步骤： 创建根目录 在根目录中创建三个并行的模块： app目录：用于放置前端代码； server目录：服务器目录； tasks目录：构建工具目录。 进入app文件夹并创建下面几个目录： css目录：用于存放css文件； js目录：用于存放js文件； views目录：用于存放模板的目录； 进入js目录进行以下操作： class目录：用于存放类文件（因为ES6中有类的概念）； 初始化test.js文件，作为一个类使用； 初始化index.js文件，作为入口文件； 进入views目录并进行以下操作： 初始化错误模板文件error.html/error.ejs； 初始化入口模板文件index.html/index.ejs； 上面的文件后缀名，是根据服务器端使用的模板文件格式来定的。因为这个项目中的后端想要使用express脚手架，它默认的模板格式是ejs格式，因此使用ejs格式，其实就可以看做html格式的文件。 进入server目录，借用脚手架express -e .命令创建服务，其中-e表示要使用ejs格式的模板文件，.表示在当前目录创建。创建完后接着需要执行npm install命令。 进入tasks构建文件目录。 创建util目录，用于存放常见脚本。 初始化一个util/args.js文件。 回到根目录，进行如下操作： 使用npm init文件初始化出package.json文件。 创建一个.babelrc文件用于babel的配置。 创建一个gulpfile.babel.js文件用于gulp的配置。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue的两个ui组件库]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E4%B8%A4%E4%B8%AAui%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[关于UI组件库其实UI组件就是一些别人提供好的东西，使用这样的组件库的目的就是为了提高开发效率，组件库为开发人员提供了一些功能，使用原则是要做到拿过来就可以直接使用。 关于第三方文件的引入这些第三方文件的引入有两种方式，一种是在main.js文件中使用import关键字引入，但这种引入方式最终会被webpack打包到build.js文件中，会使最终打包出来的文件体积变大，因此不推荐使用。还有一种方式是在index.html中使用&lt;link&gt;或&lt;script&gt;标签引入，通常推荐使用这种方式。 bootstrap本身是由twitter开源的一个响应式布局的基于jQuery的组件库，bootstrap也可以和vue结合使用，bootstrap一大特点就是简洁、大方。 下载方式可以是bower下载或者npm下载。 关于bower和npmbower是一个前端包管理器，指定版本号的时候使用#。npm是一个node包管理器，指定版本号的时候使用@。 使用步骤 使用bower install bootstrap或者npm命令下载bootstrap，或者直接下载bootstrap文件。bower会直接把依赖的jQuery也下载好。 在index.html文件中引入bootstrap和jQuery。 在App.vue文件中使用bootstrap Element-UIElement-UI是由饿了么团队开源的一个基于vue的组件库，是为PC端使用的组件库。官网。 基本使用（全部引入） 安装element-ui，官方推荐使用npm安装，命令为npm i element-ui -D或者写为npm install element-ui --save-dev。命令中的i即为install，-D即为--save-dev，-S即为--save，这些都是简写而已。 引入（所有的这些第三方库都可以在index.html中直接引入，这里介绍和vue集成的引入方法） 首先在main.js中引入element-ui。使用import ElementUI from &#39;element-ui&#39;语句，注意这个from后面的名字是根据package.json文件中的配置来写的。 依旧是main.js文件中，引入element-ui的css文件，代码为import &#39;element-ui/lib/theme-default/index.css&#39;。 注意：使用上面的方式引入element-ui是将组件库的内容全部引入。 使用组件 在main.js文件中使用语句Vue.use(ElementUI)来使用element-ui。 项目运行报错 注意，这时候运行项目可能会报错，因为没有配置css-loader。vue-cli脚手架搭建的项目默认是下载了css-loader的，但是并没有在webpack.config.js文件中配置，因此需要配置一下css-loader。 配置完css-loader后，webpack最终会将css文件打包到一个文件中，我们还需要style-loader，但vue-cli默认没有下载style-loader，需要使用cnpm install style-loader --save-dev去下载，然后在webpack.config.js中进行配置。 1234&#123; test:/\.css$/, loader: &apos;style!css&apos; // 这两个顺序一定不能反，反了就会报错&#125; 配置过css-loader之后通常还是会报错，因为有些字体图标无法加载，要解析字体图标需要使用file-loader。因此还要再配置file-loader。 1234&#123; test:/\.(eot|svg|ttf|woff|woff2)$/, loader: &apos;file&apos;&#125; 这些配置方式在官网上都有。配置完这两个就不会报错了。 在App.vue中使用 比如&lt;el-button type=&quot;primary&quot; icon=&quot;search&quot;&gt;主要按钮&lt;/el-button&gt;就会显示一个按钮。这些东西去官网照着手册使用就可以，和bootstrap大同小异。 按需引入按需引入的方式比较推荐使用，可以提高项目的性能。按需引入意思是，比如我只需要element-ui中的一个日期组件，那么就只引入日期组件的部分，这样可以减小项目体积。 具体使用步骤如下。 使用cnpm install babel-plugin-component -D安装插件babel-plugin-component。 配置babel-plugin-component插件 在.babelrc文件中对插件进行配置。这个文件之前也手写过，只不过之前是写在webpack.config.js文件中的，现在单独提取出来了，本质都是一样的。配置代码如下。 123456&quot;plugins&quot;: [[&quot;component&quot;,[ &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-default&quot; &#125;]]] 引入和使用 在main.js文件中使用import {Button,Radio} from &#39;element-ui&#39;引入。 使用Vue.use(Button);Vue.use(Radio);使用该部分组件。 使用组件的语句也可以写为Vue.component(Button.name, Button)，但这种书写方式比较长。 如果引入的组件比较多，可以新建一个element-ui.js文件，把引入和使用的代码写到这个文件中，记得还要引入Vue。然后在main.js文件中只需要一句代码将这个文件引入即可，代码为import &#39;./element-ui.js&#39;。 Mint-UIMint-UI是由饿了么团队开源的一个基于vue的组件库，是为移动端使用的组件库。官网 和Element-UI使用方法基本一致。 使用cnpm install mint-ui -D下载mint-ui。 引入mint-ui 引入和element-ui也类似，也有两种引入方式。 引入全部组件： 1234import Vue from &apos;vue&apos;;import Mint from &apos;mint-ui&apos;;import &apos;mint-ui/lib/style.css&apos;;Vue.use(Mint); 按需引入组件： 1234import &apos;mint-ui/lib/style.css&apos;;import &#123;Cell, Checklist&#125; from &apos;mint-ui&apos;;Vue.component(Cell.name, Cell);Vue.component(Checklist.name, Checklist); 注意如果要开发移动端的页面，index.html文件头部需要添加一行meta如下。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;&gt; 在代码中使用即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习笔记]]></title>
    <url>%2F2018%2F06%2F10%2Fvue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vue基本使用vue是以数据为基础的框架，凡是涉及到数据就交给vue处理。 vue的使用其实就是一片html代码加上一段js代码即可。 具体步骤如下： 引入vue.js文件编写html代码创建Vue对象，并且在其中实现数据、方法等接口 新建的Vue对象代码如下： 123456789101112131415161718192021new Vue(&#123; el: &apos;#box&apos;, data: &#123; item1: &apos;...&apos;, item2: true, item3: 59, item4: [&apos;apple&apos;, &apos;banana&apos;], item5: [ &#123;name: &apos;Tom&apos;, age: &apos;21&apos;&#125;, &#123;name: &apos;John&apos;, age: &apos;23&apos;&#125; ] &#125;, methods: &#123; example: function()&#123; ... &#125; &#125;,&#125;)//html代码&lt;div id=&quot;box&quot;&gt; &#123;&#123;item3&#125;&#125;&lt;/div&gt; 其中，el选项就是选择器，可以是id选择器、class选择器或标签选择器等。它决定了这个Vue对象中的数据可以在哪里使用。 常用指令指令其实就是对于html标签属性的扩展。 v-modelv-model用于一般表单元素，最常见的用法是用在input元素上，它实现了双向数据绑定。 v-forv-for用于循环，格式为v-for=&quot;item in arr&quot;，或v-for=&quot;item in json&quot;。 vue1.x版本中，可以使用来输出当前item的索引值，2.x版本后想要使用索引要用v-for=&quot;(item, index) in items&quot;，然后通过index来获取当前元素的索引值。 事件v-on绑定一个事件通过v-on:事件类型来进行绑定。 以click事件为例，绑定click事件的指令为v-on:click=&quot;method()&quot;。 这里绑定的事件函数具体实现写在Vue对象中的methods中。 （推荐）v-on:可以简写成为@ 获取事件对象在事件调用的方法中添加参数$event，注意，这个写法一点不能变。 然后在Vue对象的methods中的对应事件处理方法中，使用一个参数接收该事件处理对象，这个参数名字就随意了。此时该参数可以调用类似clientX等属性，这些写法与原生js相同。 阻止事件冒泡事件冒泡的顺序是由内而外的，vue项目中阻止事件冒泡有两种方法。 （1）传入一个$event参数，在函数中接收到事件对象后，使用原生js的event.cancelBubble=true来阻止事件冒泡（2）（推荐）使用vue提供的简写方式，比如是一个click事件，写为`@click.stop=”函数”`即可阻止事件冒泡 默认行为默认行为比如a标签点击后跳转，比如右键点击事件contextmenu，点击后不仅触发用户定义的事件，还会弹出右键菜单，此时就需要我们阻止默认行为。vue中阻止事件默认行为有两种方法。 （1）传入一个$event参数，在函数中接收到事件对象后，使用原生js的event.preventDefault();来阻止默认行为（2）（推荐）使用vue提供的简写方式，比如是一个右键点击事件contextmenu，写为`@contextmenu.prevent=”函数”`即可阻止事件默认行为 键盘事件比如@keydown，@keyup，这两个事件的区别体现在输入框上的现象是，前者在执行事件函数的时候输入内容还没有进入输入框，后者在执行事件函数的时候输入内容已经进入输入框了。 可以通过给事件函数传入事件对象，然后在函数中获取该事件对象的keyCode属性来获取该按键的键值。 常用按键，vue提供了一些简写方式： 回车键 `@keyup.13，或者@keyup.enter上方向键@keyup.up下方向键@keyup.down左方向键@keyup.left右方向键@keyup.right删除键@keyup.delete`….等等 一点关于bootstrap的补充bootstrap是一个依赖于jquery的css框架，它主要使用class和role两个属性。 比如，使用bootstrap声明一个表单，代码如下：1234567891011121314&lt;form role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot; v-model=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;age&quot;&gt;年 龄&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; class=&quot;form-control&quot; placeholder=&quot;请输入年龄&quot; v-model=&quot;age&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn btn-primary&quot; value=&quot;添加&quot; v-on:click=&quot;add()&quot;&gt;&lt;/input&gt; &lt;input type=&quot;reset&quot; class=&quot;btn btn-danger&quot; value=&quot;重置&quot; v-on:click=&quot;reset()&quot;&gt;&lt;/input&gt; &lt;/div&gt;&lt;/form&gt; 再比如，使用bootstrap声明一个模式对话框。 12345678910111213141516171819202122&lt;div role=&quot;dialog&quot; class=&quot;modal fade&quot; id=&quot;layer&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;!-- 对话框的头部 --&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;!-- data-dismiss：关闭模态对话框 --&gt; &lt;button class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt; &lt;!-- 这里的&amp;times;是一个html字符 --&gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;p&gt;确认删除吗？&lt;/p&gt; &lt;div class=&quot;text-right&quot;&gt; &lt;button data-dismiss=&quot;modal&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;取消&lt;/button&gt; &lt;button data-dismiss=&quot;modal&quot; class=&quot;btn btn-danger btn-sm&quot; v-on:click=&quot;deleteItem()&quot;&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面这个模态，在调用它的按钮上声明data-toggle=&quot;modal&quot; data-target=&quot;#layer&quot;即可打开这个对话框。 其中，data-toggle设置了以什么事件触发，如modal； data-target设置了事件的目标，对于本例来说也就是要打开谁。 bootstrap有很多实用的属性，比如text-center就是居中，text-right就是居右，text-info是改变文本的颜色为提示信息的颜色等等。在以后的使用过程中要善于尝试和积累。 属性v-bind绑定属性现在假设我们已经在data中声明了一个url的值，此时使用html原生语法&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;也可以获取到该图片，但是f12控制台会报错，它发送了一个404请求，并建议我们使用v-bind。 使用v-bind的写法是&lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt;，这是就不会发404请求。 （推荐）v-bind:可以简写成为:，即上例可以写为&lt;img :src=&quot;url&quot; alt=&quot;&quot;&gt;。 下面介绍属性中的两个特例。 class属性vue中要绑定class属性的值，有两种方法。 现在我们假定有一个.red样式表和一个.blue样式表，则要为一个元素绑定class属性，有以下两种写法。 （1）:class=&quot;[red,b]&quot;，其中，red和b不是直接对应样式表，而是先找到data中的数据。即，data中的内容如下：1234data: &#123; red: &apos;red&apos;, b: &apos;blue&apos;&#125; 这样才能最终找到样式表。 （2）也可以使用:class=&quot;{red: true, blue: false}&quot;这种方式来给class属性赋值，此时的red和blue指的就是样式表中的red和blue，后边的true或false指定该样式是否添加到该元素上。 （3）（推荐）第三种方式实际上是第二种方式的改进写法，我们说vue是基于数据的，能够使用数据的地方就要使用数据。指定元素的class属性还可以写为:class=&quot;{red: a, blue: b}&quot;，其中，a和b是data中的数据，data具体内容如下：1234data: &#123; a: true, b: false&#125; 这时就可以很方便的指定某个样式是否添加到该元素上了。 （4）（推荐）第四种方式又是第三种方式的衍生，第三种方式class的值实际上是一个json数据。第四种方式其实就是将这个json数据放到data里。也就是指定class属性的语句写为:class=&quot;json&quot;，data中写为：123456data: &#123; json: &#123; red: true, blue: false &#125;&#125; stylestyle基本和class相同。（1）第一种方式也是可以将数据写成数组的形式赋值给style，即:style=&quot;[a,b]&quot;，a和b在data中赋值：1234data: &#123; a: &#123;color: &apos;red&apos;&#125;, b: &#123;backgroundColor: &apos;blue&apos;&#125;&#125; 注意，在js中写复合样式要采用驼峰命名法，即background-color写为backgroundColor。 （2）（推荐）第二种方式也是可以使用json的形式。即:style=&quot;json&quot;，data中赋值为：123456data: &#123; json: &#123; color: &apos;red&apos;, backgroundColor: &apos;blue&apos; &#125;&#125; 模板1&#123;&#123; msg &#125;&#125; 类似上面的代码就是模板。 有几种形式：123&#123;&#123;msg&#125;&#125; 数据更新模板变化&#123;&#123;*msg&#125;&#125; 数据只绑定一次，数据更新模板不会变化&#123;&#123;&#123;msg&#125;&#125;&#125; 会执行msg中的HTML代码 过滤器用于过滤模板中的数据。 语法：12&#123;&#123;msg|filterA [ 参数]&#125;&#125;&#123;&#123;msg|filterA|filterB&#125;&#125; 系统提供了一些过滤器：1234567&#123;&#123;&apos;welcome&apos;|uppercase&#125;&#125; 全部转换为大写字母&#123;&#123;&apos;WELCOME&apos;|lowercase&#125;&#125; 全部转换为小写字母&#123;&#123;&apos;welcome&apos;|captalize&#125;&#125; 首字母大写&#123;&#123;&apos;WELCOME&apos;|lowercase|captalize&#125;&#125; 先转换为小写在首字母大写&#123;&#123;12|currency&#125;&#125; 将数字转换为美元钱的格式，12会变成`$12.00`&#123;&#123;12|currency &apos;￥&apos;&#125;&#125; 将数字转换为人民币的格式，12会变成`￥12.00`&#123;&#123;12|currency &apos;rmb&apos;&#125;&#125; 将数字转换为人民币的格式，12会变成`rmb12.00` 下面再介绍几个过滤器。 debouncedebounce过滤器一般配合事件使用，用于延迟执行。 12345678910111213141516&lt;div id=&quot;box&gt; &lt;input type=&quot;text&quot; @keyup=&quot;show | debounce 2000&quot;&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; &#125;, methods:&#123; show: function()&#123; alert(1); &#125; &#125; &#125;);&lt;/script&gt; 上面的代码意思是，在输入框中按下键盘按键，触发keyup事件后，延迟2000毫秒也就是2秒后执行show函数。 limitBylimitBy过滤器一般配合数组使用，用于限制返回元素的个数。 1234567891011121314151617&lt;div id=&quot;box&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr | limitBy 2&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; arr: [1, 2, 3, 4, 5] &#125; &#125;);&lt;/script&gt;// · 1// · 2 上面的代码表示只显示数组arr中的前两项。 limitBy还可以接受第二个参数，代表从哪一项开始取值。1234567891011121314151617&lt;div id=&quot;box&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr | limitBy 2 1&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; arr: [1, 2, 3, 4, 5] &#125; &#125;);&lt;/script&gt;// · 2// · 3 上面的代码表示从arr数组中下标为1的那一项开始，取两个元素。 综上所述，limitBy最多可以接收两个参数，第一个参数表示取几个元素，第二个参数表示从哪开始取。 filterByfilterBy 用于过滤数据。 1234567891011121314151617&lt;div id=&quot;box&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr | filterBy &apos;o&apos;&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; arr: [&apos;width&apos;, &apos;height&apos;, &apos;background&apos;, &apos;orange&apos;] &#125; &#125;);&lt;/script&gt;// · background// · orange 上面的代码意思是，过滤出arr中所有包含字母o的元素。 12345678910111213141516&lt;div id=&quot;box&gt; &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr | filterBy a&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; arr: [&apos;width&apos;, &apos;height&apos;, &apos;background&apos;, &apos;orange&apos;], a: &apos;&apos; &#125; &#125;);&lt;/script&gt; 上面的代码实现的效果是，在输入框中输入什么，就过滤包含什么内容的元素。也就是说filterBy后边可以跟一个变量。 综上所述，filterBy的用法就是 filterBy 参数，这里的参数代表要过滤谁。 orderByorderBy用于排序。 orderBy 1 代表正序排序。orderBy -1 代表倒序排序。 1234567891011121314&lt;div id=&quot;box&gt; &lt;ul&gt; &lt;li v-for=&quot;val in arr | orderBy -1&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/box&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; arr: [&apos;width&apos;, &apos;height&apos;, &apos;background&apos;, &apos;orange&apos;], &#125; &#125;);&lt;/script&gt; 上面的代码表示将arr中的元素倒序排序。 还有很多自带的过滤器可以去vue的官方api中查看。但是，需要注意的是，这些过滤器仅可以在1.x版本中使用，2.x版本中删除了所有自带的过滤器，所有的过滤器都需要自己实现。 自定义过滤器可以在创建Vue实例之前使用下面的代码来自定义一个全局过滤器。123Vue.filter(name,function(input)&#123; ...&#125;); 也可以使用下面的代码在一个组件的选项中定义本地的过滤器。12345filters: &#123; name: function (value) &#123; ... &#125;&#125; 下面是一个例子，用于将小于10的数经过过滤器改变为两位数格式。 1234567891011121314151617&lt;div id=&quot;box&quot;&gt; &#123;&#123;a | toDouble&#125;&#125;&lt;/div&gt;&lt;script&gt; Vue.filter(&apos;toDouble&apos;,function(input)&#123; return input&lt;10?&apos;0&apos;+input:&apos;&apos;+input; &#125;); var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; a: 9, &#125;, methods: &#123; &#125; &#125;);&lt;/script&gt; 上面的例子会将9输出为09。 自定义的过滤器可以接受多个参数，第一个参数始终使用过滤器进行操作的数据，后面的操作对应接收过滤器传入的参数。例子如下：123456789101112131415161718&lt;div id=&quot;box&quot;&gt; &#123;&#123;a | toDouble 1 2&#125;&#125;&lt;/div&gt;&lt;script&gt; Vue.filter(&apos;toDouble&apos;,function(input, a, b)&#123; alert(a+&apos;,&apos;+b); // 会输出1,2 return input&lt;10?&apos;0&apos;+input:&apos;&apos;+input; &#125;); var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; a: 9, &#125;, methods: &#123; &#125; &#125;);&lt;/script&gt; 这样我们可以写一个将时间戳转化为格式化日期的过滤器。 123456789101112131415161718&lt;div id=&quot;box&quot;&gt; &#123;&#123;a | date&#125;&#125;&lt;/div&gt;&lt;script&gt; Vue.filter(&apos;date&apos;,function(input)&#123; var oDate = new Date(input); return oDate.getFullYear() + &apos;-&apos; + (oDate.getMonth()+1) + &apos;-&apos; + oDate.getDate() + &apos; &apos; + oDate.getHours() + &apos;:&apos; + oDate.getMinutes() + &apos;:&apos; + oDate.getSeconds(); &#125;); var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; a: Date.now(), &#125;, methods: &#123; &#125; &#125;);&lt;/script&gt; 双向过滤器Vue中有双向过滤器的概念。 平时使用的过滤器其实也就是过滤器的read实现。 12345678Vue.filter(&apos;filterHtml&apos;,&#123; // model-view read: function(input)&#123; return input.replace(/&lt;[^&lt;]+&gt;/g,&apos;&apos;); &#125;, write: function(val)&#123; // view -&gt; model return val; &#125;&#125;) 交互注意，这里要启动服务器。 vue如果想做ajax交互，必须下载vue官方的一个库，vue-resource。 引入vue-resource.js文件之后，就会在Vue对象中添加一个$http属性。 get方法获取一个普通文本数据现在假设与该html文件同目录下有一个a.txt文件，现要通过get方法获取它里面的数据。首先写明一个html元素，点击它的时候请求testGet方法。具体实现get方法的步骤如下：123456789methods:&#123; testGet: function()&#123; this.$http.get(&apos;a.txt&apos;).then(function(res)&#123; alert(&apos;请求成功，请求到的数据是：&apos; + res.data); &#125;,function(res)&#123; alert(&apos;请求失败，请求返回的状态码是：&apos; + res.status); &#125;); &#125;&#125; 给服务器发送数据12345678this.$http.get(&apos;请求服务器上的url地址&apos;,&#123; data1: 1, data2: &apos;test&apos;&#125;).then(function(res)&#123; alert(&apos;请求成功，请求到的数据是：&apos; + res.data);&#125;,function(res)&#123; alert(&apos;请求失败，请求返回的状态码是：&apos; + res.status);&#125;); POST方法1234567891011this.$http.post(&apos;请求服务器上的url地址&apos;,&#123; data1: 1, data2: &apos;test&apos;&#125;,&#123; // 这一句也就相当于发送post请求的时候修改post请求头 emulateJSON:true &#125;).then(function(res)&#123; alert(&apos;请求成功，请求到的数据是：&apos; + res.data);&#125;,function(res)&#123; alert(&apos;请求失败，请求返回的状态码是：&apos; + res.status);&#125;); jsonpJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。这样的话我们就可以请求其他网站的接口。如果使用jquery框架，然后要使用这种类型的话，会创建一个查询字符串参数callback=?，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。而放在我们vue框架中，也是指定一个jsonp的值。 Jquery 在每次跨域发送请求时都会有callback这个参数，其实这个参数的值就是回调函数名称，所以，服务器端在发送json数据时，应该把这个参数放到前面，这个参数的值往往是随机生成的，如：jsonp1294734708682，同时也可以通过$.ajax方法设置callback方法的名称。明白了原理后，服务器端应该这样发送数据：1string message = &quot;jsonp1294734708682(&#123;\&quot;userid\&quot;:0,\&quot;username\&quot;:\&quot;null\&quot;&#125;)&quot;; 这样，json 数据 {\&quot;userid\&quot;:0,\&quot;username\&quot;:\&quot;null\&quot;}就作为了 jsonp1294734708682回调函数的一个参数。 了解了上面的内容过后，就可以来学习vue中如何使用jsonp类型的请求了，具体代码如下。1234567891011121314this.$http.jsonp(&apos;请求的接口地址&apos;,&#123; params: &#123; wd:this.searchText &#125;, //比如请求好搜的接口，能正常请求到 //而如果请求百度的接口这里可能就要设置一些选项了 //因为好搜的callback没有改名 //而百度的callback函数改名叫做cb jsonp:&apos;cb&apos;&#125;).then(function(res)&#123; alert(&apos;请求成功，请求到的数据是：&apos; + res.data);&#125;, function(res)&#123; alert(&apos;请求失败，请求返回的状态码是：&apos; + res.status);&#125;); 接口可以在浏览器的控制台NETWORK选项卡中，右键copy link来获取接口地址，去掉一些没有的参数就可以拿来使用。 $http方法$http方法就相当于jquery中的$.ajax()方法，它默认发送get请求。 123456this.$http(&#123; url: 请求地址, data: 给后台提交的数据, method: 指定请求的方法类型, jsonp: &apos;cb&apos; // 原来的jsonp&#125;).then(successFunction, failFunction); vue的生命周期vue提供了一系列钩子函数： created -&gt; 实例创建完毕的时候执行，也就是Vue对象实例化出来之后执行。beforeCompile -&gt; 实例编译之前执行compiled -&gt; 编译之后执行ready -&gt; 真正的把创建的文档节点插入到文档中，也就是最终加载完毕beforeDestroy -&gt; 对象销毁之前destroyed -&gt; 销毁之后 如何销毁对象：使用一个变量vm接收new Vue创建的对象，使用vm.$destroy()来销毁这个实例。 正常来讲ready函数用的比较多。 用户看到花括号vue因为html中使用的都是花括号标记，如果用户网络状态不好，会看到花括号闪烁。解决办法：（1）在会闪烁的元素（的父元素）上加上v-cloak，用于防止闪烁（2）在&lt;style&gt;标记中，书写以下代码：123[v-cloak]&#123; display:none;&#125; 上边代码中，[v-cloak]表示属性选择器。v-cloak一般会用到一大段里面，也就是用到一个很大的父元素上，但要用于某个标签也是可以的。 另一种思路是，不使用花括号，使用花括号的代替指令v-text。 123&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 上边代码中的两种表示形式是等价的，而第二种形式能够防止闪烁。 如果要将内容中的html代码编译出来，有以下两种形式：123&lt;span&gt;&#123;&#123;&#123;msg&#125;&#125;&#125;&lt;/span&gt;&lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt; 上面代码中第二种形式能够防止闪烁。需要注意的是，vue2.0中，第一种表示形式已经删掉了。 计算属性的使用下面介绍计算属性computed的使用。 data中可以放各种类型的属性，但是不能放业务逻辑代码。这时候就可以使用用computed计算属性了。 12345678910data: &#123; a: 1&#125;computed: &#123; b: function()&#123; // 可以写一些业务逻辑代码 return 2; &#125;&#125; 上面代码中，b就是一个计算属性，它看起来虽然很像一个函数，但它不是，它是一个属性，使用下面的代码即可获取它的值，不需要调用。它的值完全取决于return返回值，return语句之前可以填写一些逻辑代码。1&#123;&#123; b &#125;&#125; // 即可获取计算属性b的值 比如如果想要实现b永远比a大一，则代码如下：123456789data: &#123; a: 1&#125;computed: &#123; b: function()&#123; return this.a+1; &#125;&#125; get与set上面的这种写法，默认调用计算属性的get方法。此时如果用户对b赋值，vm.b=1，是完全无效的，因为b的get方法中的return语句指定了b的值取决于a。 那么如何才能对b赋值呢？ 可以采用计算属性的另外一种写法： 12345678910computed:&#123; b:&#123; get: function()&#123; return a+2; &#125; set: function(val)&#123; this.a = val; &#125; &#125;&#125; 上述代码中设置a的值是因为只有这样才能改变b的值。此时如果调用vm.b=1，最后返回的结果里，a为1，b为3。 综上所述，computed里面可以放置一些业务逻辑代码，一定记得return。 vue实例自带的一些方法123456var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: 1 &#125;&#125;) vm.$el -&gt; 返回el指定的元素vm.$data -&gt; 返回data数据对象，使用vm.$data.a可以返回1vm.$mount(&#39;#box&#39;) -&gt; 手动挂载，有了这句代码，Vue对象中可以不指定elvm.$options -&gt; 用于访问Vue对象中自定义的属性vm.$destroy -&gt; 销毁对象vm.$log() -&gt; 用来看data中的数据现在是什么状态，也就是现在的值是什么 因此，创建vue实例还有一种手动挂载的写法：12345new Vue(&#123; data: &#123; a: 1 &#125;&#125;).$mount(&apos;#box&apos;); 访问自定义属性：123456789101112new Vue(&#123; aa: 11, show: function()&#123; alert(1); &#125;, data: &#123; a: 1 &#125;&#125;).$mount(&apos;#box&apos;);// 使用vm.$options.aa对aa的值进行访问// 使用vm.$options.show来调用show属性指代的函数 123456new Vue(&#123; data: &#123; a: 1, b: 2 &#125;&#125;).$mount(&apos;#box&apos;); 此时如果调用console.log(vm.$log())，会打印出来一个object，里边是a和b两个属性。 循环循环有些时候会有重复数据。如果是1.0版本需要使用track-by来输出重复属性，2.0版本v-for支持重复数据输出了。 12345678910new Vue(&#123; data: &#123; arr: [&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;] &#125;, methods: &#123; add: function()&#123; arr.push(&apos;tomato&apos;); &#125; &#125;&#125;).$mount(&apos;#box&apos;); 自定义指令前面我们介绍过了自定义过滤器，下面我们来学习一下自定义指令。 首先，我们知道类似v-text、v-for、v-html等都是Vue中的指令。指令也就是对html语法的扩展。 那么自定义指令如何使用呢？ 定义自定义指令的语法如下： 1234Vue.directive(指令名称, function()&#123; this.el; // 这里调用的是原生的DOM元素 ...&#125;); 需要注意的一点是，上面指定的这个指令名称，一定是v-之后的部分。举例来说，如果上面的代码中指定了指令名称为test，那么使用这个指令的方法应当是在html标签中使用v-test。 如果有参数，则代码如下： 123456Vue.directive(name, function(参数)&#123; this.el; // 这里调用的是原生的DOM元素 ...&#125;);&lt;div v-name=&quot;参数&quot;&gt;&lt;/div&gt; 下面我们使用指令来实现一个div块的拖拽，代码如下。12345678910111213141516171819202122232425262728293031&lt;script&gt; Vue.directive(&apos;drag&apos;, function()&#123; var oDiv = this.el; oDiv.onmousedown = function(ev)&#123; var disX = ev.clientX - oDiv.offsetLeft; var disY = ev.clientY - oDiv.offsetTop; document.onmousemove = function(ev)&#123; var l = ev.clientX - disX; var t = ev.clientY - disY; oDiv.style.left = l + &apos;px&apos;; oDiv.style.top = t + &apos;px&apos;; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;; &#125;); window.onload = function()&#123; var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; &#125; &#125;); &#125;;&lt;/script&gt;&lt;div id=&quot;box&quot;&gt; &lt;div v-drag :style=&quot;&#123;width: &apos;100px&apos;, height: &apos;100px&apos;, background: &apos;blue&apos;, position: &apos;absolute&apos;, right: 0, top: 0&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 监听数据变化虽然Vue的计算属性中可以书写代码，但是如果要使用它来监听数据的变化就太费劲了。我们可以使用Vue中提供的数据监听功能，即Vue组件中的watch选项，或者说vm.$watch（vm即为Vue组件实例）。 监听数据变化有两种模式，浅度监视和深度监视。语法如下：12vm.$watch(name, functionCallback); // 浅度监视vm.$watch(name, functionCallback, &#123;deep: true&#125;); // 深度监视 上面代码中的name指的是监听的参数的名称。 浅度监听例子如下：123456789101112131415161718&lt;div id=&quot;#box&quot;&gt;&#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: 111, b: 2 &#125;&#125;);vm.$watch(&apos;a&apos;, function()&#123; alert(&apos;变量a发生变化了！&apos;);&#125;);document.onclick = functionn()&#123; vm.a = 1;&#125;;&lt;/script&gt; 深度监视例子：123456789101112131415161718&lt;div id=&quot;#box&quot;&gt;&#123;&#123;a | json&#125;&#125; &#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &#123;name: &apos;test&apos;, age: &apos;22&apos; &#125;, b: 2 &#125;&#125;);vm.$watch(&apos;a&apos;, function()&#123; alert(&apos;变量a发生变化了！&apos;);&#125;, &#123;deep: true&#125;);document.onclick = functionn()&#123; vm.a.name = &apos;John&apos;;&#125;;&lt;/script&gt; 上面代码中有几点需要注意的地方，首先是a | json的意思是使用了json过滤器，json过滤器的作用与JSON.stringify的作用是相同的，都是格式化json字符串。当然这是vue 1.x版本中的用法，vue 2.x版本中内置的这些过滤器都被删除了，需要自己实现。其次，我们应当结合上面的案例来理解一下深度监听，如果这个案例没有指定深度监听，那么a中的属性值的改变是不会被监听到的。 自定义元素指令（用处不大）例子如下：1234567891011121314151617&lt;style&gt; zns-red &#123; background: gray; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;zns-red&gt;&lt;/zns-red&gt; &lt;script&gt;Vue.elementDirective(&apos;zns-red&apos;, &#123; bind: function()&#123; this.el.style.background = &apos;red&apos;; &#125;&#125;);&lt;/script&gt; 上面就是自定义了一个元素指令，实际用处并不大，因为vue中有组件可以来替代这种写法。 自定义键盘信息我们知道，使用类似@keydown等键盘事件时，可以在后边使用.连接键盘上某个按键的别名。例如`@keydown.enter`就是检测回车键的按下事件。那么vue是否覆盖了整个键盘上的按键呢？ 答案是否定的，vue虽然已经对大部分按键进行了别名处理（@keydown.a/b/c…都可以），但仍有一些按键没有被处理，最典型的就是ctrl键。 自定义键盘按键信息的代码如下。 12Vue.directive(&apos;on&apos;).keyCodes.ctrl = 17;Vue.directive(&apos;on&apos;).keyCodes.myenter = 13; // 为enter键取一个别名 有了上面的代码，就可以使用类似`@keydown.ctrl或@keydown.myenter`来检测ctrl键和回车键的按下事件了。 补充：如何获取一个按键的键值？123document.onkeydown = function(ev)&#123; console.log(ev.keyCode);&#125; bowerbower是一个前端的包管理器，使用npm install bower -g来安装。验证是否安装成功可以使用bower --version。可以在git bash中使用bower。主要使用点有三个： bower install &lt;包名&gt; -&gt; 安装某个包bower uninstall &lt;包名&gt; -&gt; 卸载某个包bower info &lt;包名&gt; -&gt; 查看某个包的信息，包括可以获取该包的版本信息 可以使用包名#版本号来制定某个包的版本。 下载完毕的包会存放在bower_components文件夹中。 vue中的过渡（动画）本质是使用的css3中的transition和animation。 12345678910111213141516171819202122232425262728293031&lt;style&gt; .fade-transition&#123; transition: 1s all ease; &#125; .fade-enter&#123; opacity: 0; &#125; .fade-leave&#123; opacity: 0; transform: translateX(200px); &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;toggle&quot;&gt; &lt;div id=&quot;div1&quot; v-show=&quot;bSign&quot; transition=&quot;fade&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &apos;#box&apos;, data: &#123; bSign: true &#125;, methods: &#123; toggle: function()&#123; this.bSign = !this.bSign; &#125; &#125; &#125;);&lt;/script&gt; 结合上面的案例来看，vue中要书写动画，首先要在html标签中使用transition来指定动画的名字。注意这里使用的依旧是1.x版本，指定好名字之后，在style中指定该动画的类，类名为.name-transition，再指定一个.name-enter为进入时的动画，一个.name-leave为离开时的动画。 在vue中手写动画可能不能写的太精美，一般结合animate.css使用。 首先是下载animate.css，可以用到之前提过的bower。 1bower install animate.css 下载完毕后引入编写的文件中。 Vue实例可以定义一个transitions，其中定义所有动画名称。12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .fade-transition&#123; transition: 1s all ease; &#125; .fade-enter&#123; opacity: 0; &#125; .fade-leave&#123; opacity: 0; transform: translateX(200px); &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;toggle&quot;&gt; &lt;div id=&quot;div1&quot; v-show=&quot;bSign&quot; transition=&quot;bounce&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &apos;#box&apos;, data: &#123; bSign: true &#125;, methods: &#123; toggle: function()&#123; this.bSign = !this.bSign; &#125; &#125;, transitions: &#123; // 用来定义所有的动画名称 bounce: &#123; enterClass: &apos;zoomInLeft&apos;, // 进入使用的css，后边的是animate.css中的类 leaveClass: &apos;zoomOutRight&apos; // 离开的使用的css &#125; &#125; &#125;);&lt;/script&gt; Vue中的组件组件实质上就是一个大对象。 定义一个组件有以下几种方式。 使用extend定义组件定义全局组件1234567var Aaa = Vue.extend(&#123; template: &apos;组件的内容&apos;&#125;);Vue.component(&apos;aaa&apos;,Aaa);// 此时如果使用&lt;aaa&gt;&lt;/aaa&gt;就会被替换为上面定义好的组件的内容。 此时组件里面如果想放数据要怎么处理？ 组件中要使用数据十分特殊，需要注意。 12345678910111213141516171819202122var Aaa = Vue.extend(&#123; data: function()&#123; return &#123; msg: &apos;我是数据&apos; &#125;; &#125;, template: &apos;&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&apos;&#125;);// 或者使用ES6的函数简写形式var Aaa = Vue.extend(&#123; data()&#123; return &#123; msg: &apos;我是数据&apos; &#125;; &#125;, template: &apos;&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&apos;&#125;);Vue.component(&apos;aaa&apos;,Aaa); 组件中要使用数据，data必须是函数的形式，并且这个函数必须返回一个对象（json）。 除了data比较特殊之外，其他的比如methods都与原来实例化一个Vue组件的形式是相同的。 局部组件也就是将组件放在某个组件内部。 123456789101112131415161718var Aaa = Vue.extend(&#123; template: &apos;&lt;h3&gt;Hello components&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&apos;, data: function()&#123; return &#123; msg: &apos;welcome&apos; &#125; &#125;&#125;);var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; &#125;, components:&#123; // 局部组件，只有在box中才能用。 &apos;aaa&apos;: Aaa, &#125;&#125;); 使用component定义组件定义全局组件1234567Vue.component(&apos;my-aaa&apos;,&#123; template: &apos;&lt;strong&gt;test&lt;/strong&gt;&apos;&#125;);var vm = new Vue(&#123; el:&apos;#box&apos;&#125;); 定义局部组件123456789101112131415161718var vm = new Vue(&#123; el:&apos;#box&apos;, components:&#123; &apos;my-aaa&apos;: &#123; data()&#123; return &#123; msg: &apos;welcome vue&apos; &#125; &#125;, methods:&#123; change()&#123; this.msg = &apos;changed&apos;; &#125; &#125; template: &apos;&lt;strong @click=&quot;change&quot;&gt;test&#123;&#123;msg&#125;&#125;&lt;/strong&gt;&apos; &#125; &#125;&#125;); vue中的template 可以是html代码字符串 可以统一放在某个地方 12345678910111213141516171819202122&lt;script type=&quot;x-template&quot; id=&quot;aaa&quot;&gt; &lt;strong @click=&quot;change&quot;&gt;test&#123;&#123;msg&#125;&#125;&lt;/strong&gt;&lt;/script&gt;var vm = new Vue(&#123; el:&apos;#box&apos;, components:&#123; &apos;my-aaa&apos;: &#123; data()&#123; return &#123; msg: &apos;welcome vue&apos; &#125; &#125;, methods:&#123; change()&#123; this.msg = &apos;changed&apos;; &#125; &#125; template: &apos;#aaa&apos; &#125; &#125;&#125;); 这样就是将模板写在统一的一个地方。 使用template标签（模板代码很多的时候推荐使用）。 12345678910111213141516171819202122&lt;template id=&quot;aaa&quot;&gt; &lt;strong @click=&quot;change&quot;&gt;test&#123;&#123;msg&#125;&#125;&lt;/strong&gt;&lt;/template&gt;var vm = new Vue(&#123; el:&apos;#box&apos;, components:&#123; &apos;my-aaa&apos;: &#123; data()&#123; return &#123; msg: &apos;welcome vue&apos; &#125; &#125;, methods:&#123; change()&#123; this.msg = &apos;changed&apos;; &#125; &#125; template: &apos;#aaa&apos; &#125; &#125;&#125;); 动态组件动态组件也就是组件是可以切换的。比如下面这个案例，点击对应的按钮会显示对应的组件。 12345678910111213141516171819202122&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot; a=&apos;aaa&apos; &quot; value=&quot;aaa组件&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot; a=&apos;bbb&apos; &quot; value=&quot;bbb组件&quot;&gt; &lt;component :is=&quot;a&quot;&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;aaa&apos; &#125;, components: &#123; &apos;aaa&apos;: &#123; template: &apos;&lt;strong&gt;我是aaa组件&lt;/strong&gt;&apos; &#125;, &apos;bbb&apos;: &#123; template: &apos;&lt;strong&gt;我是bbb组件&lt;/strong&gt;&apos; &#125; &#125; &#125;);&lt;/script&gt; 上面这段代码中有一个需要注意的点就是&lt;component :is=&quot;a&quot;&gt;&lt;/component&gt;这种是使用方式。 &lt;component :is=&quot;组件名称&quot;&gt;&lt;/component&gt;就会调用对应的组件。 vue-devtools一般会用来捋清组件之间的关系。 vue默认情况下，父组件和子组件是不能互相访问彼此的数据的。 组件之间的通信（数据传递）子组件获取父组件的数据使用props来获取，具体案例如下。 123456789101112131415161718192021222324252627282930&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是组件aaa -&gt; &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;bbb :m=&quot;msg&quot; :my-msg=&quot;msg1&quot;&gt;&lt;/bbb&gt; // 这里因为是处于父组件的范围内，因此可以取到父组件中的数据&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; a: &apos;aaa&apos; &#125;, components: &#123; &apos;aaa&apos;:&#123; data()&#123; return &#123; msg: &apos;我是父组件aaa的数据&apos;, msg1=111 &#125; &#125;, template: &apos;#aaa&apos;, components:&#123; &apos;bbb&apos;: &#123; props: [&apos;m&apos;,&apos;myMsg&apos;], template: &apos;&lt;h3&gt;我是组件bbb -&gt; &#123;&#123;msg&#125;&#125; -&gt; &#123;&#123;myMsg&#125;&#125;&lt;/h3&gt;&apos; &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 上面代码中还有一点需要注意的是：如果在子组件上绑定属性时使用了类似my-props这样的命名方式，则在js中使用myProps来对应该属性。 props有另外一种书写方式。123456789101112131415161718192021222324252627282930313233&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是组件aaa -&gt; &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;bbb :m=&quot;msg&quot; :my-msg=&quot;msg1&quot;&gt;&lt;/bbb&gt; // 这里因为是处于父组件的范围内，因此可以取到父组件中的数据&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, data:&#123; a: &apos;aaa&apos; &#125;, components: &#123; &apos;aaa&apos;:&#123; data()&#123; return &#123; msg: &apos;我是父组件aaa的数据&apos;, msg1=111 &#125; &#125;, template: &apos;#aaa&apos;, components:&#123; &apos;bbb&apos;: &#123; props: &#123; &apos;m&apos;: String, &apos;myMsg&apos;: Number &#125;, template: &apos;&lt;h3&gt;我是组件bbb -&gt; &#123;&#123;msg&#125;&#125; -&gt; &#123;&#123;myMsg&#125;&#125;&lt;/h3&gt;&apos; &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 这种方法可以监测数据的类型。 父组件获取子组件的数据实际上就是子组件主动把自己的数据发送到父组件。 发送数据使用vm.$emit(事件名, 数据);。接收数据使用v-on:事件名或者写为@事件名。具体实现如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是父组件 -&gt; &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;bbb @child-msg=&quot;get&quot;&gt;&lt;/bbb&gt; &lt;/template&gt;&lt;template id=&quot;bbb&quot;&gt; &lt;h3&gt;我是子组件 -&gt; &#123;&#123;childData&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;send data&quot; @click=&quot;send&quot;&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, components: &#123; &apos;aaa&apos;:&#123; data()&#123; return &#123; msg: &apos;我是父组件aaa的数据&apos;, &#125; &#125;, template: &apos;#aaa&apos;, methods:&#123; get: function(msg)&#123; // 这里的msg就是子组件传递过来的值 this.msg = msg; &#125; &#125;, components:&#123; &apos;bbb&apos;: &#123; data()&#123; return &#123; childData: &apos;我是子组件的数据&apos; &#125; &#125;, template: &apos;#bbb&apos;, methods:&#123; send: function()&#123; this.$emit(&apos;child-msg&apos;,this.childData); &#125; &#125; &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 上面的代码实现了，当点击按钮的时候，msg的值从父组件中设置的值变为子组件的值。 数据传递的另外一种方式上面提到的两种方式都是比较推荐使用的。vue还提供了另外一种方式来进行数据传递。 vm.$dispatch(事件名, 数据) -&gt; 子组件向父组件发送数据 vm.$broadcast(事件名, 数据) -&gt; 父组件向子组件广播数据 这种方式需要配合event来使用。 这种方式不推荐使用因为在vue 2.0中已经被淘汰了。 slotslot翻译过来叫作位置、槽口。它的作用主要是结合组件模板使用，用于占位。 123456789101112131415161718192021222324252627282930&lt;div id=&quot;box&quot;&gt; &lt;aaa&gt; &lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt; &lt;/aaa&gt; // 上面这种情况会显示无序列表 &lt;hr&gt; &lt;aaa&gt;&lt;/aaa&gt; // 上面这种情况会显示一句文字：这是默认情况&lt;/div&gt;&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是组件aaa&lt;/h1&gt; &lt;slot&gt;这是默认情况&lt;/slot&gt; &lt;p&gt;welcome vue&lt;/p&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, components: &#123; &apos;aaa&apos;:&#123; template: &apos;#aaa&apos;, &#125; &#125; &#125;);&lt;/script&gt; 上面的代码中可以看到，slot的部分被替换为自定义标签中嵌套的部分。自定义标签中嵌套的部分会被看作一个整体。 因此如果出现下面这种情况，最后的输出会重复。 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;box&quot;&gt; &lt;aaa&gt; &lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ol&gt; &lt;/aaa&gt; // 上面这种情况会显示两遍无序列表和有序列表 &lt;hr&gt; &lt;aaa&gt;&lt;/aaa&gt; // 上面这种情况会显示：这是默认情况 这是默认情况2&lt;/div&gt;&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是组件aaa&lt;/h1&gt; &lt;slot&gt;这是默认情况&lt;/slot&gt; &lt;slot&gt;这是默认情况2&lt;/slot&gt; &lt;p&gt;welcome vue&lt;/p&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, components: &#123; &apos;aaa&apos;:&#123; template: &apos;#aaa&apos;, &#125; &#125; &#125;);&lt;/script&gt; 如果想要让两个slot分别对应无序列表和有序列表，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;box&quot;&gt; &lt;aaa&gt; &lt;ul slot=&quot;ul-slot&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt; &lt;ol slot=&quot;ol-slot&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ol&gt; &lt;/aaa&gt; // 上面这种情况会先显示有序列表再显示无序列表，只显示一遍 &lt;hr&gt; &lt;aaa&gt;&lt;/aaa&gt; // 上面这种情况会显示：这是默认情况 这是默认情况2&lt;/div&gt;&lt;template id=&quot;aaa&quot;&gt; &lt;h1&gt;我是组件aaa&lt;/h1&gt; &lt;slot name=&quot;ol-slot&quot;&gt;这是默认情况&lt;/slot&gt; &lt;slot name=&quot;ul-slot&quot;&gt;这是默认情况2&lt;/slot&gt; &lt;p&gt;welcome vue&lt;/p&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#box&apos;, components: &#123; &apos;aaa&apos;:&#123; template: &apos;#aaa&apos;, &#125; &#125; &#125;);&lt;/script&gt; vue-router擅长做SPA应用，也就是单页应用。 vue-router主要用于路由，它会根据不同的url地址，出现不同的效果。 使用bower install vue-router#0.7.13下载vue-router。这里使用的是1.0版本的vue-router，2.0版本会更精简。 基本实现实现路由总体上来讲分为两步，第一步是编写view，第二步是编写js。 view中也分为两步操作，首先使用&lt;a v-link=&quot;{path:&#39;/home&#39;}&quot;&gt;主页&lt;/a&gt;来指定跳转链接，也就是点击这个a标签会跳转到对应的组件。然后使用&lt;router-view&gt;&lt;/router-view&gt;来指定展示内容，即，对应组件的内容在这个标签的位置显示。 具体案例如下。1234567891011&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a v-link=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;主页&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/news&apos;&#125;&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 上面的代码就是路由的实现中view部分的编写。 然后是js部分的编写如下。 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; //1. 准备一个根组件 var App = Vue.extend(); //2. Home News组件都准备好 var Home = Vue.extend(&#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;); var News = Vue.extend(&#123; template:&apos;&lt;h3&gt;我是新闻&lt;/h3&gt;&apos; &#125;); //3. 准备路由 var router = new VueRouter(); // 这个类来自vue-router.js文件 //4. 关联 router.map(&#123; &apos;home&apos;: &#123; component: Home &#125;, &apos;news&apos;: &#123; component: News &#125; &#125;); //5. 启动路由 router.start(App,&apos;#box&apos;); //6. 跳转 router.redirect(&#123; &apos;/&apos;: &apos;home&apos; // 这里是设置访问跟组件的时候默认显示哪个组件 &#125;); &lt;/script&gt; 路由的嵌套路由的嵌套主要使用subRoutes。 现在假设我们有如下需求。12345主页 home 登录 home/login 注册 home/reg新闻页 news 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;style&gt;.v-link-active&#123; // 这里可以设置被点击的链接的样式&#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a v-link=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;主页&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/news&apos;&#125;&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=&quot;home&quot;&gt; &lt;h3&gt;我是主页&lt;/h3&gt; &lt;div&gt; &lt;a v-link=&quot;&#123;path:&apos;/home/login&apos;&#125;&quot;&gt;登录&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/home/reg&apos;&#125;&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;news&quot;&gt; &lt;h3&gt;我是新闻&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; //1. 准备一个根组件 var App = Vue.extend(); //2. Home News组件都准备好 var Home = Vue.extend(&#123; template: &apos;#home&apos; &#125;); var News = Vue.extend(&#123; template:&apos;#news&apos; &#125;); //3. 准备路由 var router = new VueRouter(); // 这个类来自vue-router.js文件 //4. 关联 router.map(&#123; &apos;home&apos;: &#123; component: Home, data:&#123;&#125;, methods:&#123;&#125;, subRoutes:&#123; &apos;/login&apos;:&#123; component:&#123; template:&apos;&lt;strong&gt;我是登录组件&lt;/strong&gt;&apos; &#125; &#125;, &apos;/reg&apos;:&#123; component:&#123; template:&apos;&lt;strong&gt;我是注册组件&lt;/strong&gt;&apos; &#125; &#125; &#125; &#125;, &apos;news&apos;: &#123; component: News &#125; &#125;); //5. 启动路由 router.start(App,&apos;#box&apos;); //6. 跳转 router.redirect(&#123; &apos;/&apos;: &apos;home&apos; // 这里是设置访问跟组件的时候默认显示哪个组件 &#125;); &lt;/script&gt; 获取路由的其他信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a v-link=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;主页&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/news&apos;&#125;&quot;&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=&quot;home&quot;&gt; &lt;h3&gt;我是主页&lt;/h3&gt; &lt;div&gt; &lt;a v-link=&quot;&#123;path:&apos;/home/login&apos;&#125;&quot;&gt;登录&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/home/reg&apos;&#125;&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;news&quot;&gt; &lt;h3&gt;我是新闻&lt;/h3&gt; &lt;div&gt; &lt;a v-link=&quot;&#123;path:&apos;/news/detail/001&apos;&#125;&quot;&gt;新闻001&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/news/detail/002&apos;&#125;&quot;&gt;新闻002&lt;/a&gt; &lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;template id=&quot;detail&quot;&gt; &lt;h3&gt;我是新闻&lt;/h3&gt; &#123;&#123;$route.params | json&#125;&#125; //这句代码可以获取当前所有参数（path中某个经常变化的值可以作为一个参数） &lt;br&gt; &#123;&#123;$route.path&#125;&#125; // 可以获取当前的路由 &lt;br&gt; &#123;&#123;$route.query | json&#125;&#125; // 获取当前所有参数（url拼接的参数）&lt;/template&gt;&lt;script&gt; //1. 准备一个根组件 var App = Vue.extend(); //2. Home News组件都准备好 var Home = Vue.extend(&#123; template: &apos;#home&apos; &#125;); var News = Vue.extend(&#123; template:&apos;#news&apos; &#125;); var Detail = Vue.extend(&#123; template:&apos;#detail&apos; &#125;); //3. 准备路由 var router = new VueRouter(); // 这个类来自vue-router.js文件 //4. 关联 router.map(&#123; &apos;home&apos;: &#123; component: Home, data:&#123;&#125;, methods:&#123;&#125;, subRoutes:&#123; &apos;/login&apos;:&#123; component:&#123; template:&apos;&lt;strong&gt;我是登录组件&lt;/strong&gt;&apos; &#125; &#125;, &apos;/reg&apos;:&#123; component:&#123; template:&apos;&lt;strong&gt;我是注册组件&lt;/strong&gt;&apos; &#125; &#125; &#125; &#125;, &apos;news&apos;: &#123; component: News, subRoutes:&#123; &apos;/detail/:id&apos;:&#123; component: Detail &#125; &#125; &#125; &#125;); //5. 启动路由 router.start(App,&apos;#box&apos;); //6. 跳转 router.redirect(&#123; &apos;/&apos;: &apos;home&apos; // 这里是设置访问跟组件的时候默认显示哪个组件 &#125;); &lt;/script&gt; 上面代码中值得注意的点是$route的几种其他用法。 vue-loader简介常见的loader比如css-loader、url-loader、html-loader等等。这个概念来自webpack等模块加载器，webpack中一切东西都是模块，最后会打包到一起。 vue-loader和其他loader都是一样的，它是基于webpack的。它可以将.vue文件编译成可以被识别的文件。 .vue文件中放置的是vue组件代码，包括如下三部分：1234567891011&lt;template&gt; html...&lt;/template&gt;&lt;style&gt; css...&lt;/style&gt;&lt;script&gt; js... (通常用ES6语法，通常用babel-loader将ES6编译成ES5代码)&lt;/script&gt; vue-loader所需的目录结构与基本配置因为vue-loader是基于webpack的，因此是需要一些文件的。下面介绍一下使用vue-loader所需的目录结构。 |-index.html |-main.js 入口文件 |-App.vue 唯一的vue文件，官方推荐命名第一个字母大写 |-package.json 工程文件，放一些项目依赖、名称、配置等。使用命令行窗口运行npm init --yes命令生成 |-webpack.config.js webpack配置文件 上面几个文件中除了package.json，其他文件都是自己创建就可以。 index.html文件中使用一个&lt;app&gt;&lt;/app&gt;来接收最后生成的组件。 main.js作为入口，在webpack.config.js中来配置这个入口，代码如下。1234567module.exports=&#123; entry:&apos;./main.js&apos;, // 这里指定了入口是main.js文件 output:&#123; path:__dirname, // __dirname获取当前路径，写不写都行，写了就是绝对路径 filename:&apos;bundle.js&apos; // 这里指定了出口文件，bundle是官方推荐命名 &#125;&#125; 因为在上面的文件中指定了出口文件bundle.js，也就是说最后会打包成bundle.js，因此要在index.html中使用&lt;script&gt;标签将这个文件引入。 webpack准备工作： npm install webpack --save-dev npm install webpack-dev-server--save-dev --save-dev的用处，不仅将模块下载到本地并且还会写入配置文件里面，这样的话如果有同事要安装，直接install就可以使用。 此时如果我想把项目跑起来，可能需要书写命令webpack-dev-server --inline --hot --port 8082，命令每次都这么写就太复杂了。因此就会用到我们的package.json文件。可以更改该文件的配置如下。12345......&quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --port 8082&quot;&#125;,...... 配置完毕之后在bash中使用npm run dev即可执行webpack-dev-server --inline --hot --port 8082命令。就可以达到简写命令的目的。 然后，main.js中就要开始编写这个app组件了。 这之前我们知道App.vue文件中是分为三块的。1234567891011&lt;template&gt; &lt;h3&gt;&lt;/h3&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 那么假设App.vue文件已经编写完毕，此时要在main.js文件中引入这个组件，按理说应当使用下面的代码。12import Vue from &apos;vue&apos; // 引入vueimport App from &apos;./App.vue&apos; 但这样我们使用npm run dev来运行这个项目之后，会发现报错说import找不到。而且App.vue文件中的几部分其实也无法解析，因此其实除了webpack之外我们其实还需要引入其他模块。 1. App.vue是一个特殊文件，我们要想将它变为正常文件，要使用vue-loader。 npm install vue-loader@8.5.4 --save-dev 2. App.vue中的template部分，也就是html部分也需要单独的模块对它进行解析。 npm install vue-html-loader --save-dev 3. App.vue中的style部分也需要单独的模块对它进行解析。 npm install vue-css-loader --save-dev npm install vue-style-loader --save-dev 4.App.vue中的js部分也需要单独的模块对它进行解析。 npm install vue-hot-reload-api@1.3.2 --save-dev 到这里为止，App.vue中的内容就完全可以被解析为正常的内容了。接下来我们要考虑的问题是，main.js文件中经常使用ES6的语法，但浏览器是不识别ES6语法的，因此我们还需要模块来对ES6的语法进行解析。 此时我们需要在webpack.config.js文件中增加相应的配置如下。123456789101112131415161718module.exports=&#123; entry:&apos;./main.js&apos;, // 这里指定了入口是main.js文件 output:&#123; path:__dirname, // __dirname获取当前路径，写不写都行，写了就是绝对路径 filename:&apos;bundle.js&apos; // 这里指定了出口文件，bundle是官方推荐命名 &#125;, module:&#123; loaders:[ &#123;test:/\.vue$/, loader: &apos;vue-loader&apos;&#125; //或者写为 &#123;test:/\.vue$/, loader: &apos;vue&apos;&#125; &#123;test:/\.js$/, loader: &apos;babel&apos;, exclude:/node_modules/&#125; //这个exclude表示除了node_module文件夹中的内容之外，其他js结尾的文件都使用babel进行解析 ] &#125;, babel:&#123; presets:[&apos;es2015&apos;], //这个指定了一个前缀 plugins:[&apos;transform-runtime&apos;] //这个插件用于项目运行的时候实时编译 &#125;&#125; 接下来就是babel相关的模块安装了，这些模块缺一不可。 1. babel-loader 2. babel-core // 核心 3. babel-plugin-transform-runtime 4. babel-preset-es2015 5. babel-runtime // 将这些babel运行起来 如果不用ES6语法的话babel相关的东西就不需要了，但其实使用这个就是为了使用ES6语法的。 配置到此时，main.js文件中的ES6语法也可以被解析了，更准确的说，除了node_modules文件夹内容之外的文件中的ES6语法都可以被解析为ES5了。 接下来剩下一步最为核心的，也就是vue的下载。 npm install vue@1.0.28 --save // 这里不加-dev，加-dev的一般是开发所用的框架，不加的一般是必需的框架 // 加了-dev的会放在package.json的devDependencies中 // 不加的会放在package.json的dependencies中 此时，main.js文件中使用import Vue from &#39;vue&#39;引入的这个Vue就和平时使用的Vue差不多了。 补充：ES6一大优势就是模块开发。导出模块使用export default{}，引入模块使用import 模块名 from 地址。 上面就是所有的配置了。 接下来我们来看一个最基本的案例。 index.html文件中代码如下：1234&lt;body&gt; &lt;app&gt;&lt;/app&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; main.js文件中代码如下：123456789import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;new Vue(&#123; el: &apos;body&apos;, components: &#123; app: App &#125;&#125;); App.vue文件中代码如下：12345678910111213141516171819202122232425&lt;template&gt; &lt;h1&gt;Welcome Vue&lt;/h1&gt; &lt;h2 @click=&quot;change&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; msg: &apos;welcome vue ^_^&apos; &#125; &#125;, methods:&#123; change()&#123; this.msg = &apos;test&apos; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; body&#123; background:#ccc; &#125;&lt;/style&gt; 编写完毕以上代码，使用npm run dev就能够正常运行项目，并且显示一句Welcome Vue。 这样部署的项目有一个好处，比如如果此时修改项目中style部分的代码，保存后该效果无需刷新页面就会直接反应到浏览器中，这是运行命令中--inline --hot这两个选项的功能。 引入项目中其他模块如果要引入其他模块，比方说项目根目录下有一个components文件夹，里面存放了一个menu模块，则在App.vue文件中使用import Menu from &#39;./components/Menu.vue&#39;来引入。 Menu.vue文件内容如下：12345678910&lt;template&gt; &lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt; App.vue文件内容如下：123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;h1&gt;Welcome Vue&lt;/h1&gt; &lt;h2 @click=&quot;change&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;my-menu&gt;&lt;/my-menu&gt;&lt;/template&gt;&lt;script&gt; import Menu from &apos;./components/Menu.vue&apos; export default&#123; data()&#123; return &#123; msg: &apos;welcome vue ^_^&apos; &#125; &#125;, methods:&#123; change()&#123; this.msg = &apos;test&apos; &#125; &#125;, components:&#123; &apos;my-menu&apos;: Menu &#125; &#125;&lt;/script&gt;&lt;style&gt; body&#123; background:#ccc; &#125;&lt;/style&gt; 这样编写完毕之后，就会在首页中显示出menu组件的内容。 手动搭建webpack+vue-loader注意下载模块的时候一定要使用npm install &lt;package-name&gt; --save-dev，这样才能把这些模块依赖写到package.json文件里。之后如果把项目拷给别人，就不需要带着node_modules文件夹了，对方拿到除了node_modules文件夹之外的项目文件，然后在根目录下运行npm_install命令，就能够根据package.json文件中的依赖将所有需要的模块下载好。 一些项目必需的模块（如vue，vue-router等）下载的时候使用--save即可，它们会进入package.json文件中的dependencies里，意思是项目必需的模块。而一些项目开发过程中使用的模块使用--save-dev即可，它们会进入package.json文件中的devDependencies部分，意思是项目开发必需的模块。当然这不是硬性规定，只是一种习惯。 如果运行报错EADDRINUSE，意思是端口被占用。 vue-loader与vue-router结合使用路由使用版本: 0.7.13。 vue-router配合vue-loader使用的步骤如下： 1. 下载vue-router模块 cnpm install vue-router@0.7.13 2. 在App.vue文件中导入vue-router import VueRouter from &apos;vue-router&apos; 3. 因为vue-router是基于vue的，所以要使用下面的语句声明让Vue去使用vue-router Vue.use(VueRouter) // 这句话必不可少 4. 配置路由 在App.vue文件中的template标签中配置链接和router-view。 12345&lt;template&gt; &lt;h3&gt;vue-router与vue-loader结合使用&lt;/h3&gt; &lt;a v-link=&quot;&#123;path:&apos;/home&apos;&#125;&quot;&gt;主页&lt;/a&gt; &lt;a v-link=&quot;&#123;path:&apos;/news&apos;&#125;&quot;&gt;新闻&lt;/a&gt;&lt;/template&gt; 在App.vue文件中继续配置路由。这之前要创建好./components/Home.vue文件和./components/News.vue文件。 ./components/Home.vue文件的内容： 123&lt;template&gt; &lt;h3&gt;我是主页&lt;/h3&gt;&lt;/template&gt; ./components/News.vue文件的内容： 123&lt;template&gt; &lt;h3&gt;我是新闻&lt;/h3&gt;&lt;/template&gt; App.vue文件中： 12345678910111213141516import Home from `./components/Home.vue`import News from `./components/News.vue`const router = new VueRouter();router.map(&#123; // 配置路由规则 &apos;/home&apos;:&#123; component: Home &#125;, &apos;/news&apos;:&#123; component: News &#125;&#125;)router.redirect(&#123; &apos;/&apos;:&apos;/home&apos;&#125;); 5. 在App.vue中开启路由 router.start(App,&apos;#app&apos;); 6. 在index.html文件中接受传递过来的组件 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 如果只是这样接收，运行项目可能会报错: [Vue warn]: Attribute &quot;id&quot; is ignored on component &lt;div&gt; because the component is a fragment instance。 解决这个警告的方法是：在App.vue文件的template标签中，为该内容添加一个父级元素&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;`。 需要注意的一点。之前在index.html文件中如果不使用路由那么只要使用&lt;app&gt;&lt;/app&gt;就可以接收组件。但使用路由之后需要使用&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;来接收组件。除此之外，只这样使用的话虽然可以正常使用但是还会报错，因此要在App.vue文件中，使用&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;作为根元素才行。 至于像是路由的嵌套和路由的其他数据获取和之前都是一模一样的。 推荐的编程习惯还有一个编程习惯可以注意一下。上面的案例中，路由的配置是写在App.vue文件中的，但其实可以创建一个router.config.js文件，里面专门配置路由规则。代码如下： 12345678910111213//引入模块import Home from `./components/Home.vue`import News from `./components/News.vue`//配置路由规则export default&#123; &apos;/home&apos;:&#123; component: Home &#125;, &apos;/news&apos;:&#123; component: News &#125;&#125; 此时的App.vue文件中，代码如下： 123import routerConfig from &apos;./router.config.js&apos; // 引入进来的就是一个jsonrouter.map(routerConfig) // 所以配置路由规则的时候直接使用即可 项目上线在package.json文件中的scripts标签里配置&quot;build&quot;:&quot;webpack -p&quot;，这个命令是打包的意思，它会将项目打包到webpack.config.js文件中output选项里配置的文件中。此时就将这个文件上线即可。 vue-clivue的脚手架vue-cli用来帮开发人员提供好基本的项目结构。它本身集成了很多项目模板。 simple webpack webpack-simple browserify browserify-simple vue-cli的使用 npm install vue-cli -g安装vue命令环境，使用vue --version验证是否安装成功。 vue init &lt;模板名称&gt; &lt;本地文件夹名称&gt;生成项目模板。如vue init simple#1.0 vue-simple-demo。simple模板就只包含一个index.html文件。 进入生成目录里面使用npm install安装所需要的模块。 npm run dev运行项目 下面介绍一些关于几个模板的知识。 simple模板就只包含一个index.html文件。这个模板不推荐使用，没什么用。 webpack模板在安装的过程中，会问一些类似是否需要ESLint、是否需要Karma单元测试等等问题，这些根据公司的要求来。注意如果选择了ESLint的话会检查代码规范，它会要求开发人员强制按照规则来书写代码（比如要求缩进是两个空格）。这个模板的运行端口号可以在config文件夹的index.js文件中修改。这个模板可以用于一些大型项目，如果是无需太规范的中小型项目可以不使用。 webpack-simple模板与webpack的区别在于webpack-simple不带有Eslint、单元测试等。一般来说vue不会用来做太大型的项目，因此推荐使用webpack-simple就可以了。这个模板的目录结构和之前讲的出入不大。当然如果要求高的话使用webpack也是可以的。这个模板修改端口在package.json文件中修改dev对应的命令即可（添加 --port 8081）。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之Vue2.0]]></title>
    <url>%2F2018%2F06%2F08%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BVue2.0%2F</url>
    <content type="text"><![CDATA[Vue2.0的使用首先去官网中下载2.0版本的vue.js文件。下载知乎可以通过bower info查看vue的版本。 Vue2.0中的变化组件模板代码写法的变化在每个组件模板中，不再支持片段代码。 在Vue1.0版本中，组件的定义可以使用下面的写法：1234567891011121314151617181920212223&lt;script&gt; var Aaa = Vue.extend(&apos;aaa&apos;,&#123; template: &apos;&lt;h4&gt;这是组件&lt;/h4&gt;&apos; &#125;); Vue.component(&apos;my-aaa&apos;,Aaa); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 上面的这种写法，其实就算能用也不经常被使用。通常会用下面的这种写法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script&gt; Vue.component(&apos;my-aaa&apos;,&#123; template: &apos;&lt;h4&gt;这是组件&lt;/h4&gt;&lt;strong&gt;这是加粗标签&lt;/strong&gt;&apos; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt;//或者另一种将模板提取出来的写法&lt;script&gt; Vue.component(&apos;my-aaa&apos;,&#123; template: &apos;#aaa&apos; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;aaa&quot;&gt; &lt;h4&gt;这是组件&lt;/h4&gt;&lt;strong&gt;这是加粗标签&lt;/strong&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 上面的代码如果是vue1.0版本是不会出现问题的，但如果是2.0版本，template中只写一个标签也是没有问题的，但写了两个并列的标签就会报错。 关于组件中的模板，Vue2.0中必须有一个根元素包裹住所有的代码。 代码如下：12345678910111213141516171819202122232425262728&lt;script&gt; Vue.component(&apos;my-aaa&apos;,&#123; template: &apos;#aaa&apos; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;aaa&quot;&gt; &lt;div&gt; &lt;h4&gt;这是组件&lt;/h4&gt; &lt;strong&gt;这是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 关于组件的定义Vue.extend这种方式在2.0中有，但是有一些改动，但是这里不做赘述，因为这种写法即使能用也不推荐使用。 无论1.0还是2.0，推荐组件定义的方法如下：12345Vue.component(组件名称,&#123; data()&#123;&#125;, methods:&#123;&#125;, template:&#123;&#125;&#125;) 除此之外，2.0还提供了一种更为简洁的全局组件定义的方式： 123456789101112131415161718192021222324252627282930&lt;script&gt; var Home = &#123; // 这是2.0组件 template: &apos;#aaa&apos; &#125; // 类似之前的Vue.extend() Vue.component(&apos;my-aaa&apos;, Home); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;aaa&quot;&gt; &lt;div&gt; &lt;h4&gt;这是组件&lt;/h4&gt; &lt;strong&gt;这是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 2.0中局部组件的定义：123456789101112131415161718192021222324252627&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125;, components: &#123; &apos;aaa&apos;: Home &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;aaa&quot;&gt; &lt;div&gt; &lt;h4&gt;这是组件&lt;/h4&gt; &lt;strong&gt;这是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; &lt;aaa&gt;&lt;/aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 生命周期的变化vue中的生命周期又被叫做钩子函数。 1.0中的生命周期： init created beforeCompile cmpiled ready beforeDestroy destroyed 2.0中的生命周期：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: &apos;welcome vue2.0&apos; &#125;, methods:&#123; update()&#123; this.msg = &apos;change the msg&apos; &#125;, destroy()&#123; this.$destroy(); &#125; &#125;, beforeCreate()&#123; // 组件实例刚刚被创建，属性等都没有。相当于1.0中的init &#125;, created()&#123; // 实例已经创建完成，属性已经绑定，和1.0中的created相同 &#125;, beforeMount()&#123; // 模板编译之前，相当于1.0中的beforeCompiled &#125;, mounted()&#123; // 模板已经编译完成，相当于1.0中的cmpiled和ready // 之前ready用对的较多，现在mounted用的比较多 &#125;, //下面是2.0中新增的生命周期，是与更新组件相关的两个方法 //本案例中点击按钮更新msg数据的时候就会调用这两个方法 //这两个新增的方法会很有用处 beforeUpdate()&#123; // 组件更新之前 &#125;, updated()&#123; // 组件更新完毕 &#125;, //然后是和1.0中相同的组件销毁的两个生命周期 beforeDestroy()&#123; // 组件销毁之前 &#125;, destroyed()&#123; // 组件销毁之后 &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;更新数据&quot; @click=&quot;update&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;销毁组件&quot; @click=&quot;destroy&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt; 2.0钩子函数总结： beforeCreate 组件实例刚刚被创建，属性等都没有，相当于之前的init created 实例已经创建完成，属性已经绑定，相当于之前的created beforeMount 模板编译之前，相当于之前的beforeCompile mounted 模板编译之后，相当于之前的cmpiled和ready beforeUpdate 组件更新之前，2.0新增 updated 组件更新完毕之后，2.0新增 beforeDestroy 组件销毁之前，相当于之前的beforeDestroy destroyed 组件销毁之后，相当于之前的destroyed 其中mounted和updated两个钩子函数会经常使用。 2.0中的循环关于循环中的重复值首先来看1.0中的循环。1234567891011121314151617181920212223242526&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; list:[&apos;width&apos;,&apos;height&apos;,&apos;border&apos;] &#125;, methods:&#123; add()&#123; this.list.push(&apos;background&apos;); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;val in list&quot; track-by=&quot;$index&quot;&gt; &#123;&#123;val&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 上面的代码中，如果点击按钮，会一直添加相同的值。如果循环的地方不加track-by=&quot;$index&quot;语句，则无法添加多个相同的值，也就是说，1.0中的v-for不可以添加重复值，需要添加重复值则要添加track-by=&quot;$index&quot;语句。 而在2.0中，v-for循环默认就可以添加重复的数据了，不需要track-by。 关于隐式变量另外还有一点比较重要的是，vue 2.0中去掉了一些隐式变量，比如用于获取数组元素索引值的$index和用于获取键值的$key。 那么vue 2.0中如何获取当前元素的索引值呢？代码如下： 1234567891011121314151617181920212223242526&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; list:[&apos;width&apos;,&apos;height&apos;,&apos;border&apos;] &#125;, methods:&#123; add()&#123; this.list.push(&apos;background&apos;); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(val,index) in list&quot;&gt; &#123;&#123;val&#125;&#125; &#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 上面的这种写法其实vue 1.0中也有，但是需要注意的是：vue 1.0中值和索引的顺序是(index,val)，而vue2.0中值和索引的顺序是(val,index)。这样做会更贴近原生js的语法，原生js中arr.forEach(function(item,index)){}就是这样的顺序。 索引值的问题解决了，那么vue 2.0中如何获取当前元素的键值呢？代码如下： 123456789101112131415161718192021222324&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; list:&#123; a: &apos;apple&apos;, b: &apos;banana&apos;, c: &apos;cell&apos; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(val,key) in list&quot;&gt; &#123;&#123;val&#125;&#125; &#123;&#123;key&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 这里补充一点关于track-by的小知识。track-by的作用其实是提高循环性能，传入的值是元素的索引值。vue 2.0去掉了track-by之后，提高循环性能使用:key=&quot;index&quot;，index是元素的索引值，在v-for=&quot;(val,index) in list&quot;语句中声明。 自定义键盘指令的变化vue 1.0中自定义键盘指令使用Vue.directive(&#39;on&#39;),keyCodes.ctrl = 17;。123456789101112131415161718192021&lt;script&gt; Vue.directive(&apos;on&apos;),keyCodes.ctrl = 17; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; &#125;, methods:&#123; change()&#123; alert(&apos;changed!&apos;); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; @keyup.ctrl=&quot;change&quot;&gt; &lt;/div&gt;&lt;/body&gt; vue 2.0中的写法是Vue.config.keyCodes.ctrl=17; 123456789101112131415161718192021&lt;script&gt; Vue.config.keyCodes.ctrl=17; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; &#125;, methods:&#123; change()&#123; alert(&apos;changed!&apos;); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; @keyup.ctrl=&quot;change&quot;&gt; &lt;/div&gt;&lt;/body&gt; 过滤器的变化vue 1.0中自带了很多使用的过滤器，比如json、currency等等。而vue 2.0中，作者把所有内置过滤器全部删除了，使用过滤器需要自己通过js实现。也是因为这样vue 2.0是目前性能最高的一个框架。 作者推荐使用lodash这个工具库。这个工具库中有很多_.开头的函数，比如debounce延迟执行过滤器在2.0中被废弃了之后，可以使用lodash中的_.debounce(fn,时间)。感兴趣可以自己研究一下。 需要注意一点的是，vue 1.0中输出json数据会显示[Object Object]，因此需要使用json过滤器。但是vue 2.0中输出json数据会直接显示，和1.0中使用json过滤器的效果相同，因此2.0不需要json过滤器。 vue2.0中要自定义普通过滤器，和1.0中没有什么不同。 12345678910111213141516171819&lt;script&gt; Vue.filter(&apos;toDou&apos;,function(input)&#123; return input&lt;10?&apos;0&apos;+input:&apos;&apos;+input; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: 9 &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &#123;&#123;msg | toDou&#125;&#125; &lt;/div&gt;&lt;/body&gt; 但如果在vue 2.0 中要给自定义的过滤器传参，就有些小小的变化了。 vue1.0中自定义过滤器传参的时候使用空格隔开，代码如下。1234567891011121314151617181920&lt;script&gt; Vue.filter(&apos;toDou&apos;,function(input, a, b)&#123; alert(a + &apos;,&apos; + b); return input&lt;10?&apos;0&apos;+input:&apos;&apos;+input; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: 9 &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &#123;&#123;msg | toDou &apos;18&apos; &apos;6&apos;&#125;&#125; &lt;/div&gt;&lt;/body&gt; 而vue2.0中自定义过滤器传参的时候使用函数的写法，也就是使用括号，代码如下。1234567891011121314151617181920&lt;script&gt; Vue.filter(&apos;toDou&apos;,function(input, a, b)&#123; alert(a + &apos;,&apos; + b); return input&lt;10?&apos;0&apos;+input:&apos;&apos;+input; &#125;); window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; msg: 9 &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &#123;&#123;msg | toDou(&apos;18&apos;,&apos;6&apos;)&#125;&#125; &lt;/div&gt;&lt;/body&gt; Vue2.0中的组件通信子组件与父组件之间的通信父组件获取子组件的数据仍然使用vm.$emit()和vm.$on()。 子组件想要拿到父组件的数据，仍然通过props获取。12345678910111213141516171819202122232425262728&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;我是父组件的数据&apos; &#125;, components:&#123; &apos;child-com&apos;: &#123; props:[&apos;msg&apos;], template: &apos;#child&apos; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;h4&gt;我是子组件&lt;/h4&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; &lt;child-com :msg=&quot;a&quot;&gt;&lt;/child-com&gt; &lt;/div&gt;&lt;/body&gt; 上面的代码到这为止在vue2.0中都能够正常运行。 但下面的代码就有一些差别了。1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;我是父组件的数据&apos; &#125;, components:&#123; &apos;child-com&apos;: &#123; props:[&apos;msg&apos;], template: &apos;#child&apos;, methods:&#123; change()&#123; this.msg = &apos;changed!&apos; &#125; &#125; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;h4&gt;我是子组件&lt;/h4&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;change&quot;&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; 父级： -&gt; &#123;&#123;a&#125;&#125; &lt;child-com :msg=&quot;a&quot;&gt;&lt;/child-com&gt; &lt;/div&gt;&lt;/body&gt; 上面的代码在vue 1.0 中运行时没有任何问题的，并且会产生一个现象，当用户点击按钮时会更改子组件中的数据，但父组件中的数据不会被更改。 那么在vue1.0中，如果想要在更改子组件数据的同时更改父组件中对应的数据，要在传参给子组件的地方使用sync，意思是同步。代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;我是父组件的数据&apos; &#125;, components:&#123; &apos;child-com&apos;: &#123; props:[&apos;msg&apos;], template: &apos;#child&apos;, methods:&#123; change()&#123; this.msg = &apos;changed!&apos; &#125; &#125; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;h4&gt;我是子组件&lt;/h4&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;change&quot;&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; 父级： -&gt; &#123;&#123;a&#125;&#125; &lt;child-com :msg.sync=&quot;a&quot;&gt;&lt;/child-com&gt; &lt;/div&gt;&lt;/body&gt; 从上面的示例中我们可以知道，vue 1.0中子组件可以更改父组件传过来的数据，甚至可以将改变同步到父组件中对应的数据上。而在vue2.0中，不允许子组件直接给父组件的数据赋值。 那么vue2.0中该如何实现子组件更改父组件数据这个功能呢。 实现这个功能有以下几点： 父组件每次要传一个对象给子组件。 这是因为原生js中对象是一种引用数据类型，对象之间互相赋值，赋的是对象的引用。并且父组件传一个对象给子组件，子组件改变这个对象中的某个数据，这个操作实际上是在更改父组件传过来的数据中的一个属性，不属于子组件直接给父组件的数据复制，并且因为传递的是对象的引用，所以子组件中对数据的改变会自动反映到父组件的数据身上。 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; giveData:&#123; a: &apos;我是父组件的数据&apos; &#125; &#125;, components:&#123; &apos;child-com&apos;: &#123; props:[&apos;msg&apos;], template: &apos;#child&apos;, methods:&#123; change()&#123; this.msg.a = &apos;changed!&apos; &#125; &#125; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;h4&gt;我是子组件&lt;/h4&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;change&quot;&gt; &lt;h4&gt;&#123;&#123;msg.a&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; 父级： -&gt; &#123;&#123;giveData.a&#125;&#125; &lt;child-com :msg=&quot;giveData.a&quot;&gt;&lt;/child-com&gt; &lt;/div&gt;&lt;/body&gt; 上面的代码最终实现的效果是，点击按钮后，子组件和父组件中的数据同步被改变。 如果不需要同步，只是为了修改子组件中的值不报错，那么可以使用mounted方法进行中转。在mounted方法中将父组件的数据赋值给子组件的数据。具体如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;我是父组件的数据&apos; &#125;, components:&#123; &apos;child-com&apos;: &#123; data()&#123; return &#123; b: &apos;&apos; &#125; &#125;, props:[&apos;msg&apos;], template: &apos;#child&apos;, mounted()&#123; this.b = this.msg; &#125; methods:&#123; change()&#123; this.b = &apos;changed!&apos;; &#125; &#125; &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt; &lt;h4&gt;我是子组件&lt;/h4&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;change&quot;&gt; &lt;h4&gt;&#123;&#123;b&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;box&quot;&gt; 父级： -&gt; &#123;&#123;a&#125;&#125; &lt;child-com :msg=&quot;a&quot;&gt;&lt;/child-com&gt; &lt;/div&gt;&lt;/body&gt; 上面这种实现方法是在子组件中使用一个属于子组件自己的数据去接收父组件的值，接收值的时候使用mounted方法中转一下，也就是在mounted方法中给子组件的数据赋予父组件数据的值。这样在子组件中对这个数据想做什么操作都可以。但可想而知，这种实现方法，子组件对数据的更改是不会同步到父组件身上的。 如果想要同步，不能使用sync，sync在vue 2.0 中已经被废除了。非要同步的话可以使用第一种解决方法。 单一事件中心管理组件通信在vue 2.0 中可以使用单一事件中心管理组件通信。这也是vuex的前身。需要注意的是这里可能会涉及到函数内部this指向改变的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;script&gt; window.onload = function()&#123; //准备一个空的实例对象 var Event = new Vue(); var A = &#123; template: &apos; &lt;div&gt; &lt;span&gt;我是A组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=&quot;button&quot; value=&quot;把A数据给C&quot; @click=&quot;send&quot;&gt; &lt;/div&gt; &apos;, data()&#123; return &#123; a: &apos;我是a数据&apos; &#125; &#125;, methods:&#123; send()&#123; Event.$emit(&apos;a-msg&apos;,this.a); &#125; &#125; &#125;; var B = &#123; template: &apos; &lt;div&gt; &lt;span&gt;我是B组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=&quot;button&quot; value=&quot;把B数据给C&quot;&gt; &lt;/div&gt; &apos;, data()&#123; return &#123; a: &apos;我是b数据&apos; &#125; &#125;, methods:&#123; send()&#123; Event.$emit(&apos;b-msg&apos;,this.a); &#125; &#125; &#125;; var C = &#123; template: &apos; &lt;div&gt; &lt;h3&gt;我是C组件&lt;/h3&gt; &lt;span&gt;接收到A的数据为 -&gt; &#123;&#123;a&#125;&#125;&lt;/span&gt; &lt;span&gt;接收到B的数据为 -&gt; &#123;&#123;b&#125;&#125;&lt;/span&gt; &lt;/div&gt; &apos;, data()&#123; return &#123; a: &apos;&apos;, b: &apos;&apos; &#125; &#125;, mounted()&#123; //alert(&apos;c组件加载完毕&apos;); //接收A的数据 var _this = this; // 这里一定要保存一下this的值，因为this的指向会在运行中改变 Event.$on(&apos;a-msg&apos;,function(a)&#123; _this.a = a; &#125;); //绑定this的指向还有一种方法 Event.$on(&apos;a-msg&apos;,function(a)&#123; this.a = a; &#125;.bind(this)); //接收B的数据 Event.$on(&apos;b-msg&apos;,function(b)&#123; this.b = b; &#125;.bind(this)); &#125; &#125;; new Vue(&#123; el: &apos;#box&apos;, data: &#123; a: &apos;我是父组件的数据&apos; &#125;, components:&#123; &apos;com-a&apos;: A, &apos;com-b&apos;: B, &apos;com-c&apos;: C &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;com-b&gt;&lt;/com-b&gt; &lt;com-c&gt;&lt;/com-c&gt; &lt;/div&gt;&lt;/body&gt; 下面总结一下单一事件管理组件通信。这个其实并不是2.0中新加的，只是补充的一种实现方法。 新建一个空的实例对象var Event = new Vue(); 发送数据的一方使用Event.$emit(事件名称, 数据); 接收数据的一方使用下面的代码： 123Event.$on(事件名称, function(data)&#123; // 操作data&#125;.bind(this)); Vue中的过滤（动画）动画使用的是transition，只不过之前的vue1.0中transition使用的是属性的方式，而vue2.0中transition使用的是组件的形式了。 vue1.0中的定义方式大概如下：1234567&lt;p transition=&quot;fade&quot;&gt;&lt;/p&gt;// 然后去定义对应的class即可// 需要定义的class基本有以下几个// .fade-transition&#123;&#125;// .fade-enter&#123;&#125;// .fade-leave&#123;&#125; vue2.0中的定义方式大概如下：12345678910&lt;transition&gt; //运动的东西（元素、属性、路由）&lt;/transition&gt;// 然后也需要定义相应的class，但这个class相比1.0中有所变化// 需要定义的class基本有以下几个// .fade-enter&#123;&#125; 定义元素的初始状态// .fade-enter-active&#123;&#125; 定义元素显示时要变化成什么样子// .fade-leave&#123;&#125; 这个状态其实和fade-enter差不多// .fade-leave-active&#123;&#125; 定义元素消失/离开时要变化成什么样子 下面来看一个案例。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; p&#123; width: 100px; height: 100px; background: red; opacity: 0; &#125; .fade-enter-active, .fade-leave-active&#123; transition: 1s all ease; // 这里只是规定了一个运动时间 // 但这个是必须要定义的，不能够缺少 &#125; .fade-enter-active&#123; //定义元素显示时要变化成什么样子 opacity: 1; width: 300px; height: 300px; &#125; .fade-leave-active&#123; opacity: 0; width: 100px; height: 100px; &#125; .fade-enter,.fade-leave&#123; opacity: 0; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; show:false &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击显示隐藏&quot; @click=&quot;show=!show&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-show=&quot;show&quot;&gt;&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt; 下面详细解释一下这四种状态。 一个元素的显示隐藏动画，可以分为两部分。第一部分是从无到有的显示过程也就是enter，第二部分是从有到无的隐藏过程也就是leave。这两部分分别又可以分为两部分。在enter的过程中，元素的初始状态就是fade-enter，而元素最终显示出来的状态就是fade-enter-active；在leave的过程中，元素最终消失时的状态就是fade-leave-active，至于fade-leave其实有没有都不会对效果产生影响，但按官方推荐，fade-leave应该和fade-enter写在一起。 transition相关函数transition有一系列很方便的函数如下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;style&gt; p&#123; width: 100px; height: 100px; background: red; opacity: 0; &#125; .fade-enter-active, .fade-leave-active&#123; transition: 1s all ease; // 这里只是规定了一个运动时间 // 但这个是必须要定义的，不能够缺少 &#125; .fade-enter-active&#123; //定义元素显示时要变化成什么样子 opacity: 1; width: 300px; height: 300px; &#125; .fade-leave-active&#123; opacity: 0; width: 100px; height: 100px; &#125; .fade-enter,.fade-leave&#123; opacity: 0; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; show:false &#125;, methods:&#123; beforeEnter(el)&#123; // 这里的这个el就是执行动画的元素 console.log(&apos;动画enter之前&apos;); &#125;, enter(el)&#123; console.log(&apos;动画enter&apos;); &#125;, afterEnter(el)&#123; console.log(&apos;动画enter之后&apos;); el.style.background = &apos;blue&apos;; &#125;, beforeLeave(el)&#123; console.log(&apos;动画leave之前&apos;); &#125;, leave(el)&#123; console.log(&apos;动画leave&apos;); &#125;, afterLeave(el)&#123; console.log(&apos;动画leave之后&apos;); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击显示隐藏&quot; @click=&quot;show=!show&quot;&gt; &lt;transition name=&quot;fade&quot; @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterLeave&quot; @before-leave=&quot;beforeLeave&quot; @enter=&quot;leave&quot; @after-leave=&quot;afterLeave&quot; &gt; &lt;p v-show=&quot;show&quot;&gt;&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt; transition如何与animate.css配合使用使用方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; p&#123; width: 100px; height: 100px; background: red; opacity: 0; margin: auto; &#125;&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.css文件的地址&quot;&gt;&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; show:false &#125;, methods:&#123; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击显示隐藏&quot; @click=&quot;show=!show&quot;&gt; &lt;transition enter-active-class=&quot;bounceInLeft&quot; leave-active-class=&quot;bounceOutRight&quot;&gt; &lt;p v-show=&quot;show&quot; class=&quot;animated&quot;&gt;&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;// 或者&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击显示隐藏&quot; @click=&quot;show=!show&quot;&gt; &lt;transition enter-active-class=&quot;bounceInLeft animated&quot; leave-active-class=&quot;bounceOutRight animated&quot;&gt; &lt;p v-show=&quot;show&quot;&gt;&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt; 上面代码中的bounceInLeft等都是animate.css中提供的class。 transition用于多个元素transition只能用于一个元素，如果要用于多个元素要使用transition-group，并且元素身上必须绑定:key，这个key一般是循环出来的，自己写也可以。 12345678910111213141516171819202122232425262728293031&lt;style&gt; p&#123; width: 100px; height: 100px; background: red; opacity: 0; margin: auto; &#125;&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.css文件的地址&quot;&gt;&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; show:false &#125;, methods:&#123; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击显示隐藏&quot; @click=&quot;show=!show&quot;&gt; &lt;transition-group enter-active-class=&quot;bounceInLeft animated&quot; leave-active-class=&quot;bounceOutRight animated&quot;&gt; &lt;p v-show=&quot;show&quot; :key=&quot;1&quot;&gt;&lt;/p&gt; &lt;p v-show=&quot;show&quot; :key=&quot;2&quot;&gt;&lt;/p&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/body&gt; key使用循环的值的一个案例。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; p&#123; width: 100px; height: 100px; background: red; opacity: 0; margin: auto; &#125;&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.css文件的地址&quot;&gt;&lt;script&gt; window.onload = function()&#123; new Vue(&#123; el: &apos;#box&apos;, data: &#123; show:&apos;&apos;, list:[&apos;apple&apos;,&apos;banana&apos;,&apos;orange&apos;,&apos;pear&apos;] &#125;, computed:&#123; lists:function()&#123; var arr = []; this.list.forEach(function(val)&#123; if(val.indexOf(this.show)!=-1)&#123; arr.push(val); &#125; &#125;.bind(this)); return arr; &#125; &#125; methods:&#123; &#125; &#125;); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;show&quot;&gt; &lt;transition-group enter-active-class=&quot;bounceInLeft&quot; leave-active-class=&quot;bounceOutRight&quot;&gt; &lt;p v-show=&quot;show&quot; class=&quot;animated&quot; v-for=&quot;(val,index) in list&quot; :key=&quot;index&quot;&gt; &#123;&#123;val&#125;&#125; &lt;/p&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/body&gt; 上面的代码实现了输入框中输入什么，就会以动画形式显示出带有什么字母的p元素。 Vue2.0中的路由vue2.0路由学习推荐网址：http://router.vuejs.org/zh-cn/index.html 基本用法可以使用bower install vue-router进行安装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var News = &#123; template: &apos;&lt;h3&gt;我是新闻&lt;/h3&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123;path: &apos;/news&apos;,component:News&#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 ]; // 生成路由实例 var router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router &#125;);&lt;/script&gt;&lt;/body&gt; 上面的代码使用了router-link，而在vue 1.0 中使用的是带有v-link的a标签。 上面代码的写法就是vue2.0中路由的写法，除了定义时写法的变化之外要注意之前的重定向是使用router.redirect，现在在vue2.0中已经废弃了。 路由的嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var User = &#123; template: &apos; &lt;div&gt; // 这里一定要注意有个根元素，vue2.0要求组件必须有一个根元素 &lt;h3&gt;我是用户&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/user/username&quot;&gt;某个用户&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &apos; &#125;; var UserDetail = &#123; template: &apos;&lt;div&gt;我是XX用户&lt;/div&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123; path: &apos;/user&apos;, component:User, //配置子路由，children的配置和routes的配置方法一样 children:[ &#123;path:&apos;username&apos;, component: UserDetail&#125; ] &#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 // 这个*的选项的作用是vue找不到路径是就访问*后边的路径‘ // 有点类似case分支中的default ]; // 生成路由实例 var router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router &#125;);&lt;/script&gt;&lt;/body&gt; 路由中的参数路由中的参数和vue1.0中相比没有什么太大的变化，比如路径为/user/strive/age/10。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var User = &#123; template: &apos; &lt;div&gt; // 这里一定要注意有个根元素，vue2.0要求组件必须有一个根元素 &lt;h3&gt;我是用户&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/user/strive/age/10&quot;&gt;Strive&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/blue/age/80&quot;&gt;Blue&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/eric/age/50&quot;&gt;Eric&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &apos; &#125;; var UserDetail = &#123; template: &apos;&lt;div&gt;&#123;&#123;$route.params&#125;&#125;&lt;/div&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123; path: &apos;/user&apos;, component:User, //配置子路由，children的配置和routes的配置方法一样 children:[ &#123;path:&apos;:username/age/:age&apos;, component: UserDetail&#125; ] &#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 // 这个*的选项的作用是vue找不到路径是就访问*后边的路径‘ // 有点类似case分支中的default ]; // 生成路由实例 const router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router &#125;);&lt;/script&gt;&lt;/body&gt; 路由中新增的几个实例方法vue2.0中路由实例身上添加了几个新的方法如下。 push方法router.push({path:&#39;home&#39;});意思是直接添加一个路由，表现为切换路由，本质是往历史记录里面添加一条记录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加一个路由&quot; @click=&quot;push&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var User = &#123; template: &apos; &lt;div&gt; // 这里一定要注意有个根元素，vue2.0要求组件必须有一个根元素 &lt;h3&gt;我是用户&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/user/strive/age/10&quot;&gt;Strive&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/blue/age/80&quot;&gt;Blue&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/eric/age/50&quot;&gt;Eric&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &apos; &#125;; var UserDetail = &#123; template: &apos;&lt;div&gt;&#123;&#123;$route.params&#125;&#125;&lt;/div&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123; path: &apos;/user&apos;, component:User, //配置子路由，children的配置和routes的配置方法一样 children:[ &#123;path:&apos;:username/age/:age&apos;, component: UserDetail&#125; ] &#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 // 这个*的选项的作用是vue找不到路径是就访问*后边的路径‘ // 有点类似case分支中的default ]; // 生成路由实例 const router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router, methods:&#123; push()&#123; router.push(&#123;path:&apos;home&apos;&#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 上面的代码实现的效果是点击按钮会跳到主页面，点击浏览器返回按钮会回到点击按钮之前的页面。 replacerouter.replace({path:&#39;home&#39;});是替换路由，表现也是切换路由的效果，但是不会向浏览器历史访问记录中添加记录，也不会刷新页面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加一个路由&quot; @click=&quot;push&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;替换一个路由&quot; @click=&quot;replace&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var User = &#123; template: &apos; &lt;div&gt; // 这里一定要注意有个根元素，vue2.0要求组件必须有一个根元素 &lt;h3&gt;我是用户&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/user/strive/age/10&quot;&gt;Strive&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/blue/age/80&quot;&gt;Blue&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/eric/age/50&quot;&gt;Eric&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &apos; &#125;; var UserDetail = &#123; template: &apos;&lt;div&gt;&#123;&#123;$route.params&#125;&#125;&lt;/div&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123; path: &apos;/user&apos;, component:User, //配置子路由，children的配置和routes的配置方法一样 children:[ &#123;path:&apos;:username/age/:age&apos;, component: UserDetail&#125; ] &#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 // 这个*的选项的作用是vue找不到路径是就访问*后边的路径‘ // 有点类似case分支中的default ]; // 生成路由实例 const router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router, methods:&#123; push()&#123; router.push(&#123;path:&apos;home&apos;&#125;); &#125;, replace()&#123; router.replace(&#123;path:&apos;user&apos;&#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 上面的代码实现的效果是点击按钮后切换到用户信息页面，但是浏览器中无法返回点击之前的页面，后退按钮不会生效。 路由配合运动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;style&gt; .router-link-active&#123; //设置被选中的路由按键的样式 &#125;&lt;/style&gt;&lt;link 导入animate.css&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加一个路由&quot; @click=&quot;push&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;替换一个路由&quot; @click=&quot;replace&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 组件 var Home = &#123; template: &apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; var User = &#123; template: &apos; &lt;div&gt; // 这里一定要注意有个根元素，vue2.0要求组件必须有一个根元素 &lt;h3&gt;我是用户&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/user/strive/age/10&quot;&gt;Strive&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/blue/age/80&quot;&gt;Blue&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/user/eric/age/50&quot;&gt;Eric&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &apos; &#125;; var UserDetail = &#123; template: &apos;&lt;div&gt;&#123;&#123;$route.params&#125;&#125;&lt;/div&gt;&apos; &#125;; // 配置路由 var routes=[ &#123;path: &apos;/home&apos;,component:Home&#125;, &#123; path: &apos;/user&apos;, component:User, //配置子路由，children的配置和routes的配置方法一样 children:[ &#123;path:&apos;:username/age/:age&apos;, component: UserDetail&#125; ] &#125;, &#123;path: &apos;*&apos;,redirect:&apos;/home&apos;&#125; //重定向也在这里实现 // 这个*的选项的作用是vue找不到路径是就访问*后边的路径‘ // 有点类似case分支中的default ]; // 生成路由实例 const router = new VueRouter(&#123; routes; &#125;); //最后将路由挂到Vue实例上 new Vue(&#123; el: &apos;#box&apos;, router, methods:&#123; push()&#123; router.push(&#123;path:&apos;home&apos;&#125;); &#125;, replace()&#123; router.replace(&#123;path:&apos;user&apos;&#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 上面的代码实现了路由切换的时候具有动画效果，使用了animate.css。 Vue2.0中的脚手架基本使用 使用vue init webpack-simple vue-demo来初始化一个vue目录，无需指定版本号了。 跳入目录，运行cnpm install。 运行npm run dev来运行项目。如果端口不正确就在package.json中修改dev的命令。 脚手架在2.0中的一些变化main.js文件中有一些变化如下。 1.0版本：1234new Vue(&#123; el:&apos;#app&apos;, components: &#123;App&#125;&#125;) 2.0版本：1234new Vue(&#123; el:&apos;#app&apos;, render: h =&gt; h(App)&#125;) vue-loader和vue-router配合使用首先在项目目录中创建一个components文件夹，在里面创建Home.vue和News.vue组件。 新建router.config.js文件来书写路由规则：123456789import Home from &apos;./components/Home.vue&apos;import News from &apos;./components/News.vue&apos;export default&#123; routes: [ &#123;path: &apos;/home&apos;, component: Home&#125;, &#123;path: &apos;/news&apos;, component: News&#125; ]&#125; 在App.vue文件中的&lt;template&gt;标签中使用路由。1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 然后在main.js文件中使用路由。12345678910111213141516import Vue from &apos;vue&apos;import VueRouter fro &apos;vue-router&apos; // 引入vue-router import App fron &apos;./App.vue&apos;import routerConfig from &apos;./router.config.js&apos;Vue.use(VueRouter); // Vue去使用vue-routerconst router = new VueRouter(&#123; routerConfig&#125;)new Vue(&#123; el:&apos;#app&apos;, router, render: h =&gt; h(App)&#125;) 路由结合animate.css动画使用animete.css应该在main.js文件中使用import &#39;./assets/css/animate.css&#39;来导入，然后如果报错就下载css-loader和style-loader，因为按照webpack的打包原则css文件的打包需要这两个loader，然后在webpack.config.js文件中module中的rules中进行配置如下。1234&#123; test: /\.css$/, //这里代表所有以css结尾的文件 loader: &apos;style!css&apos; //这里的顺序一定不能反过来否则会报错，`!`是连接符&#125; 还有另外一种使用方式。 可以在index.html文件中使用&lt;link rel=&quot;stylesheet&quot; href=&quot;src/assets/css/animate.css&quot;&gt;将animate文件导入。 然后在App.vue中编写使用动画的代码。 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; //解析完毕时会变成a标签 &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;transition enter-active-class=&quot;animated zoomInLeft&quot; leave-active-class=&quot;animated zoomOutRight&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/div&gt; 这样就可以在脚手架搭建的项目中结合路由和动画来使用。 vue中使用lessvue项目中还可以使用less。 安装less依赖，npm install less less-loader --save 修改webpack.config.js文件，配置loader加载依赖，让其支持外部的less,在原来的代码上添加下面代码。 1234567&#123;test: /\.less$/,loader: &quot;less&quot;,&#125; 然后在使用的时候在style标签里加上lang=”less”里面就可以写less的代码了(style标签里加上 scoped 为只在此作用域有效)。 或者@import &#39;./index.less&#39;;来引入全局less文件。 或者在html中直接引入：12&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;文件路径/styles.less&quot;&gt;&lt;script src=&quot;文件路径/less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 关于Vue2.0中的交互Vue更新到2.0版本之后，作者宣告不再对vue-resource更新，推荐使用axios。但其实使用原生和jQuery都可以。下面看一下axios的使用。 使用cnpm i axios -D安装axios。 在组件或元素身上绑定一个事件。 注意，如果是element-ui组件库中这些封装好的组件，可以直接绑定事件。而如果是自己自定义的组件想要添加事件，要使用`@click.native`才能够生效。 引入axios。 使用import axios from &#39;axios&#39;引入axios。 在刚才绑定的事件中使用axios，使用方法和vue-resource大体相同。 1234567axios.get(&apos;a.txt&apos;).then(function(res)&#123; console.log(res); this.msg = res.data;&#125;.bind(this)).catch(function(err)&#123; console.log(err);&#125;); 自定义Vue全局组件vue作者推荐使用的axios是不支持Vue.use()方法的，会报错。原因在于axios没有实现install方法。install方法会在使用use方法的时候自动调用，接收一个参数就是use方法的调用者。 那么应该如何写一个自定义组件给别人使用，并且支持Vue.use()方法呢？ 步骤如下。 在项目的App.vue文件中使用自定义的组件，比如&lt;Loading&gt;&lt;/Loading&gt;。 新建一个components文件夹，在该文件夹中新建一个loading文件夹，在该文件夹中新建Loading.vue文件和index.js文件。其中index.js文件是必要的，命名也是推荐命名。 Loading.vue文件中编写组件具体内容。 编写index.js文件，这个文件中必须导出组件，并且实现install方法。如果报错提示plugin一般是index.js文件出问题。 123456789import LoadingComponent from &apos;./Loading.vue&apos;const Loading = &#123; install: function(Vue) &#123; Vue.component(&apos;Loading&apos;, LoadingComponent); &#125;&#125;export default Loading 在main.js文件中使用import Loading from &#39;./components/loading&#39;导入，也可以写为import Loading from &#39;./components/loading/index.js&#39;，这也是为什么要起名为index.js的原因，因为默认会去搜索index.js文件。如果这个文件命名为a.js，这里引入就要改变为import Loading from &#39;./components/loading/a.js&#39;。 vuexvuex负责集中式数据管理。官网http://vuex.vuejs.org/。 正常情况下vue如果数据不是很多不使用vuex也行。 vuex的使用vuex提供了两个方法： mapActions，用于管理所有的事件。 mapGetters，专门用于获取数据。 vuex使用的具体步骤如下： 使用cnpm install vuex -D安装vuex。 在和App.vue同级的目录下创建一个store.js用于统一管理。 在main.js中使用import store from &#39;./store.js&#39;引入store.js。并将store挂在Vue实例的身上，从而将它暴露出去。 在App.vue文件中使用import {mapGetters, mapActions} from &#39;vuex&#39;引入vuex的两个模块。 在App.vue中编写template，在其中添加一个“增加”按钮，并为按钮添加increment事件。此时事件绑定的代码写法如下。 12345export default&#123; methods: mapActions([ &apos;increment&apos; // 如果有多个事件用逗号隔开 ])&#125; 现在就可以在store.js文件中写事件处理方法increment 123456789101112131415161718192021222324252627282930313233343536import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);var state = &#123; count: 10&#125;;const mutations = &#123; // 只要用于处理状态/数据变化 increment(state)&#123; state.count++; &#125;&#125;const actions = &#123; increment:(&#123; // 处理用户要做的事情，异步请求，判断，流程控制等 commit &#125;) =&gt; &#123; commit(&apos;increment&apos;) &#125;&#125;;const getters = &#123; count(state)&#123; return state.count; &#125;&#125;// 需要导出store对象export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;); 在App.vue中获取count的值如下。 第一种方式，因为state被暴露在store对象里，因此可以在template标签中使用下面的代码直接获取。123&lt;div&gt; 现在数字为：&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt; 但是一般不会这样用。 第二种方式，使用mapGetters()获取count的值。使用这种方式，需要在store.js中添加一个getters。关于getters上面的代码中已经定义过了。具体的获取使用下面的代码。12345678export default&#123; computed:mapGetters([ &apos;count&apos; ]), methods: mapActions([ &apos;increment&apos; // 如果有多个事件用逗号隔开 ])&#125; 需要注意的是，actions中提供了两个对象，一个是commit，另一个是state，state就是用户定义的state，可以用于进行一些判断，在满足条件的时候才使用commit去提交到mutations中的某个具体方法。 vuex官方推荐的目录结构在项目根目录src下新建一个store文件夹，专门用于管理数据。 store文件夹下有index.js、mutation.js、actions.js、getters.js、types.js等文件。 其中，index.js是入口，它负责导入所需的模块并导出需要暴露的数据等。12345678910111213import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);import actions from &apos;./actions&apos;import mutations from &apos;./mutations&apos;export default new Vuex.Store(&#123; modules:&#123; mutations &#125; actions&#125;); 在actions.js文件中。123456import * as types from &apos;./types.js&apos;export default &#123; increment: (&#123;commit&#125;) -&gt; &#123; commit(&apos;types.INCREMENT&apos;); &#125;&#125; 在types.js文件中，一般情况下约定俗成这个文件不能够修改，因此用常良。1export const INCREMENT &apos;INCREMENT&apos; 在mutations.js文件中。1234567891011121314151617181920import &#123; INCREMENT&#125; from &apos;./types&apos;import getters from &apos;./getters&apos;const state = &#123; count: 20&#125;const mutations = &#123; [INCREMENT]()&#123; state.count++; &#125;&#125;export default &#123; state, mutations, getters&#125; 在getters文件中12345export default &#123; const: (state) =&gt; &#123; return state.count; &#125;&#125; vue项目实战开发项目基本流程： 规划组件结构 编写对应的路由，用到vue-router 具体写每个组件的功能 一些建议：一些公共的文件，比如jquery等，一般都在index.html文件中直接引入就行。 注意一点，webpack2在引入css-loader的时候，不能再使用简写了，具体如下：1234&#123; text:/\.css$/, loader:&apos;style-loader!css-loader&apos;&#125; vue项目的搭建： webpack-simple模板生成的vue项目中，assets目录用于存放一些静态资源。 需要一个components目录存放组件。 如果想在js里面引入css模块，就需要style-loader和css-loader。 vue2.0之后使用自定义组件可以不用将驼峰式命名改为横线式命名，在模板中直接使用如&lt;NavView&gt;这样的自定义组件也是可以的。 一些补充 监听路由变化： 12345watch:&#123; //监听当路由发生变化时触发这个函数 $route(to,from)&#123; // to.path可以获取要跳转到的路由 alert(1); &#125;&#125; webpack打包后文件过大的解决办法 (a) webpack代码拆分：code-spliting (b) 提取公共（css、js） (c) 预渲染：prerender-spa-plugin (d) 后台开启压缩，gz (e) 异步加载组件require.ensure 注意使用webpack2.0时的一些变化： (a) 端口号会自动向后排列，如果8080被占用会自动使用8081等 (b) module中的配置从原来的loaders变成rules，具体如下： 12345678910111213module:&#123; loaders:[ &#123;test:/\.css$/, loader:&apos;style!css&apos;&#125; ]&#125;// 变成module:&#123; rules:[ &#123;test:/\.css$/, loader:&apos;style-loader!css-loader&apos;&#125; ]&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript标准参考教程》阅读笔记之 《DOM模型》]]></title>
    <url>%2F2018%2F05%2F21%2FJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B-%E3%80%8ADOM%E6%A8%A1%E5%9E%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址 DOM 模型概述基本概念DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。 DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种。 Document：整个文档树的顶层节点DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;）Element：网页的各种HTML标签（比如、等）Attribute：网页元素的属性（比如class=”right”）Text：标签之间或标签包含的文本Comment：注释DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。 浏览器原生提供document节点，代表整个文档。 12document// 整个文档树 文档的第一层只有一个节点，就是 HTML 网页的第一个标签&lt;html&gt;，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。 除了根节点，其他节点都有三种层级关系。 父节点关系（parentNode）：直接的那个上级节点子节点关系（childNodes）：直接的下级节点同级节点关系（sibling）：拥有同一个父节点的节点 DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括firstChild（第一个子节点）和lastChild（最后一个子节点）等属性，同级节点接口包括nextSibling（紧邻在后的那个同级节点）和previousSibling（紧邻在前的那个同级节点）属性。 Node 接口的属性所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。 Node.nodeTypenodeType属性返回一个整数值，表示节点的类型。 1document.nodeType // 9 上面代码中，文档节点的类型值为9。 Node 对象定义了几个常量，对应这些类型值。 1document.nodeType === Node.DOCUMENT_NODE // true 上面代码中，文档节点的nodeType属性等于常量Node.DOCUMENT_NODE。 不同节点的nodeType属性值和对应的常量如下。 文档节点（document）：9，对应常量Node.DOCUMENT_NODE元素节点（element）：1，对应常量Node.ELEMENT_NODE属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE文本节点（text）：3，对应常量Node.TEXT_NODE文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE注释节点（Comment）：8，对应常量Node.COMMENT_NODE 确定节点类型时，使用nodeType属性是常用方法。 1234var node = document.documentElement.firstChild;if (node.nodeType === Node.ELEMENT_NODE) &#123; console.log(&apos;该节点是元素节点&apos;);&#125; Node.nodeNamenodeName属性返回节点的名称。 12345// HTML 代码如下// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;var div = document.getElementById(&apos;d1&apos;);div.nodeName // &quot;DIV&quot; 上面代码中，元素节点&lt;div&gt;的nodeName属性就是大写的标签名DIV。 不同节点的nodeName属性值如下。 文档节点（document）：#document元素节点（element）：大写的标签名属性节点（attr）：属性的名称文本节点（text）：#text（这里就是#text，text不用于替换）文档片断节点（DocumentFragment）：#document-fragment文档类型节点（DocumentType）：文档的类型注释节点（Comment）：#comment Node.nodeValue（可读写）nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。 只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这两类节点可以设置nodeValue属性的值，其他类型的节点设置无效。 12345678var p = document.getElementsByTagName(&quot;p&quot;)[0];p.nodeValue; // null// HTML 代码如下// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;var div = document.getElementById(&apos;d1&apos;);div.nodeValue // nulldiv.firstChild.nodeValue // &quot;hello world&quot; 上面代码中，div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。 Node.textContent（可读写）textContent属性返回当前节点和它的所有后代节点的文本内容。 12345// HTML 代码为// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;document.getElementById(&apos;divA&apos;).textContent// This is some text textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。 该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。 1document.getElementById(&apos;foo&apos;).textContent = &apos;&lt;p&gt;GoodBye!&lt;/p&gt;&apos;; 上面代码在插入文本时，会将&lt;p&gt;标签解释为文本，而不会当作标签处理。 对于文本节点（text）和注释节点（comment），textContent属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。 文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。 Node.baseURIbaseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。 123456789// 当前网页的网址为// http://www.example.com/index.htmldocument.baseURI// &quot;http://www.example.com/index.html&quot;// 当前网页的网址为// http://javascript.ruanyifeng.com/dom/node.html#toc0document.baseURI// &quot;http://javascript.ruanyifeng.com/dom/node.html#toc0&quot; 如果无法读到网页的 URL，baseURI属性返回null。 该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的&lt;base&gt;标签，改变该属性的值。 12345// 在HTML代码中任意位置插入下面的代码// &lt;base href=&quot;http://www.baidu.com&quot;&gt;document.baseURI;// &quot;https://www.baidu.com/&quot; 设置了以后，baseURI属性就返回&lt;base&gt;标签设置的值。 Node.ownerDocumentNode.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。 12var d = p.ownerDocument;d === document // true document对象本身的ownerDocument属性，返回null。 Node.nextSiblingNode.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。 1234567// HTML 代码如下// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;var div1 = document.getElementById(&apos;d1&apos;);var div2 = document.getElementById(&apos;d2&apos;);d1.nextSibling === d2 // true 上面代码中，d1.nextSibling就是紧跟在d1后面的同级节点d2。 注意，该属性还包括文本节点和评论节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。 nextSibling属性可以用来遍历所有子节点。 123456var el = document.getElementById(&apos;div1&apos;).firstChild;while (el !== null) &#123; console.log(el.nodeName); el = el.nextSibling;&#125; 上面代码遍历div1节点的所有子节点。 Node.previousSiblingpreviousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。 123456// HTML 代码如下// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;var div1 = document.getElementById(&apos;d1&apos;);var div2 = document.getElementById(&apos;d2&apos;);d2.previousSibling === d1 // true 上面代码中，d2.previousSibling就是d2前面的同级节点d1。 注意，该属性还包括文本节点和评论节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。 Node.parentNodeparentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。 123if (node.parentNode) &#123; node.parentNode.removeChild(node);&#125; 上面代码中，通过node.parentNode属性将node节点从文档里面移除。 文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。 Node.parentElementparentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。 123if (node.parentElement) &#123; node.parentElement.style.color = &apos;red&apos;;&#125; 上面代码中，父元素节点的样式设定了红色。 由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。 Node.firstChild，Node.lastChildfirstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。 1234// HTML 代码如下// &lt;p id=&quot;p1&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;var p1 = document.getElementById(&apos;p1&apos;);p1.firstChild.nodeName // &quot;SPAN&quot; 上面代码中，p元素的第一个子节点是span元素。 注意，firstChild返回的除了元素节点，还可能是文本节点或评论节点。 1234567// HTML 代码如下// &lt;p id=&quot;p1&quot;&gt;// &lt;span&gt;First span&lt;/span&gt;// &lt;/p&gt;var p1 = document.getElementById(&apos;p1&apos;);p1.firstChild.nodeName // &quot;#text&quot; 上面代码中，p元素与span元素之间有空白字符，这导致firstChild返回的是文本节点。 lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。 Node.childNodeschildNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。成员可以为空。 1var children = document.querySelector(&apos;ul&apos;).childNodes; 上面代码中，children就是ul元素的所有子节点。 使用该属性，可以遍历某个节点的所有子节点。 123456var div = document.getElementById(&apos;div1&apos;);var children = div.childNodes;for (var i = 0; i &lt; children.length; i++) &#123; // ...&#125; 上面代码中可以使用children的length属性是因为children是一个类似数组的对象，是具备length属性的。 文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。 123456var children = document.childNodes;for (var i = 0; i &lt; children.length; i++) &#123; console.log(children[i].nodeType);&#125;// 10// 1 上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。 注意，除了元素节点，childNodes属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。 由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。 Node.isConnectedisConnected属性返回一个布尔值，表示当前节点是否在文档之中。 12345var test = document.createElement(&apos;p&apos;);test.isConnected // falsedocument.body.appendChild(test);test.isConnected // true 上面代码中，test节点是脚本生成的节点，没有插入文档之前，isConnected属性返回false，插入之后返回true。 Node 接口的方法Node.appendChild()appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。 12var p = document.createElement(&apos;p&apos;);document.body.appendChild(p); 上面代码新建一个&lt;p&gt;节点，将其插入document.body的尾部。 如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。 123var element = document .createElement(&apos;div&apos;) .appendChild(document.createElement(&apos;b&apos;)); 上面代码的返回值是&lt;b&gt;&lt;/b&gt;，而不是&lt;div&gt;&lt;/div&gt;。 如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。 关于DocumentFragment节点：我们经常使用Javascript来操作DOM元素，比如使用appendChild()方法。每次调用该方法时，浏览器都会重新渲染页面。如果大量的更新DOM节点，则会非常消耗性能，影响用户体验。JavaScript提供了一个文档片段DocumentFragment的机制。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点。把所有要构造的节点都放在文档片段中执行，这样可以不影响文档树，也就不会造成页面渲染。当节点都构造完成后，再将文档片段对象添加到页面中，这时所有的节点都会一次性渲染出来，这样就能减少浏览器负担，提高页面渲染速度。 1234567891011121314151617// 使用DocumentFragmentvar list1 = document.getElementById(&apos;list1&apos;);console.time(&quot;time&quot;);var fragment = document.createDocumentFragment();for(var i = 0; i &lt; 500000; i++)&#123; fragment.appendChild(document.createElement(&apos;li&apos;));&#125;list1.appendChild(fragment);console.timeEnd(&apos;time&apos;);// 不使用DocumentFragmentvar list = document.getElementById(&apos;list&apos;);console.time(&quot;time&quot;);for(var i = 0; i &lt; 500000; i++)&#123; list.appendChild(document.createElement(&apos;li&apos;));&#125;console.timeEnd(&apos;time&apos;); 循环50万次的各浏览器结果如下：123 使用文档片段 不使用文档片段firefox 402.04ms 469.31mschrome 429.800ms 729.634ms 循环10万次的各浏览器结果如下：123456 使用文档片段 不使用文档片段IE11 2382.15ms 2204.47msIE10 2404.239ms 2225.721msIE9 2373ms 2255msIE8 4464ms 4210msIE7 5887ms 5394ms 从以上结果可以看出，如果使用IE浏览器，则使用文档片段DocumentFragment的性能并不会更好，反而变差；若使用chrome和firefox浏览器，使用文档片段DocumentFragment可以提升性能。 Node.hasChildNodes()hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。 12345var foo = document.getElementById(&apos;foo&apos;);if (foo.hasChildNodes()) &#123; foo.removeChild(foo.childNodes[0]);&#125; 上面代码表示，如果foo节点有子节点，就移除第一个子节点。 注意，子节点包括所有节点，哪怕节点只包含一个空格，hasChildNodes方法也会返回true。 判断一个节点有没有子节点，有许多种方法，下面是其中的三种。 node.hasChildNodes()node.firstChild !== nullnode.childNodes &amp;&amp; node.childNodes.length &gt; 0 hasChildNodes方法结合firstChild属性和nextSibling属性，可以遍历当前节点的所有后代节点。 1234567891011function DOMComb(parent, callback) &#123; if (parent.hasChildNodes()) &#123; for (var node = parent.firstChild; node; node = node.nextSibling) &#123; DOMComb(node, callback); &#125; &#125; callback(parent);&#125;// 用法DOMComb(document.body, console.log) 上面代码中，DOMComb函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。 Node.cloneNode()cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。 1var cloneUL = document.querySelector(&apos;ul&apos;).cloneNode(true); 该方法有一些使用注意点。 克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn）添加在这个节点上的事件回调函数。 该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。 克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id=&quot;xxx&quot;）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。 Node.insertBefore()insertBefore方法用于将某个节点插入父节点内部的指定位置。 1var insertedNode = parentNode.insertBefore(newNode, referenceNode); insertBefore方法接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。 12var p = document.createElement(&apos;p&apos;);document.body.insertBefore(p, document.body.firstChild); 上面代码中，新建一个&lt;p&gt;节点，插在document.body.firstChild的前面，也就是成为document.body的第一个子节点。 如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。 12var p = document.createElement(&apos;p&apos;);document.body.insertBefore(p, null); 上面代码中，p将成为document.body的最后一个子节点。这也说明insertBefore的第二个参数不能省略。 注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。 由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。 1parent.insertBefore(s1, s2.nextSibling); 上面代码中，parent是父节点，s1是一个全新的节点，s2是可以将s1节点，插在s2节点的后面。如果s2是当前节点的最后一个子节点，则s2.nextSibling返回null，这时s1节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在s2的后面。 如果要插入的节点是DocumentFragment类型，那么插入的将是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值将是一个空的DocumentFragment节点。 Node.removeChild()removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。 12var divA = document.getElementById(&apos;A&apos;);divA.parentNode.removeChild(divA); 上面代码移除了divA节点。注意，这个方法是在divA的父节点上调用的，不是在divA上调用的。 下面是如何移除当前节点的所有子节点。1234var element = document.getElementById(&apos;top&apos;);while (element.firstChild) &#123; element.removeChild(element.firstChild);&#125; 被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。 如果参数节点不是当前节点的子节点，removeChild方法将报错。 Node.replaceChild()replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。 1var replacedNode = parentNode.replaceChild(newChild, oldChild); 上面代码中，replaceChil方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。 1234var divA = document.getElementById(&apos;divA&apos;);var newSpan = document.createElement(&apos;span&apos;);newSpan.textContent = &apos;Hello World!&apos;;divA.parentNode.replaceChild(newSpan, divA); 上面代码是如何将指定节点divA替换走。 Node.contains()contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。 参数节点为当前节点。参数节点为当前节点的子节点。参数节点为当前节点的后代节点。 1document.body.contains(node) 上面代码检查参数节点node，是否包含在当前文档之中。 注意，当前节点传入contains方法，返回true。 1nodeA.contains(nodeA) // true Node.compareDocumentPosition()compareDocumentPosition方法的用法，与contains方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。 二进制值 十进制值 含义 000000 0 两个节点相同 000001 1 两个节点不在同一个文档（即有一个节点不在当前文档） 000010 2 参数节点在当前节点的前面 000100 4 参数节点在当前节点的后面 001000 8 参数节点包含当前节点 010000 16 当前节点包含参数节点 100000 32 浏览器内部使用 注意，表格中的这些值是可以叠加的，如果某两个节点同时满足上面两种情况，则等于两个二进制值相加。 12345678910// HTML 代码如下// &lt;div id=&quot;mydiv&quot;&gt;// &lt;form&gt;&lt;input id=&quot;test&quot; /&gt;&lt;/form&gt;// &lt;/div&gt;var div = document.getElementById(&apos;mydiv&apos;);var input = document.getElementById(&apos;test&apos;);div.compareDocumentPosition(input) // 20input.compareDocumentPosition(div) // 10 上面代码中，节点div包含节点input（二进制010000），而且节点input在节点div的后面（二进制000100），所以第一个compareDocumentPosition方法返回20（二进制010100，即010000 + 000100），第二个compareDocumentPosition方法返回10（二进制001010）。 由于·compareDocumentPosition·返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。 1234567var head = document.head;var body = document.body;if (head.compareDocumentPosition(body) &amp; 4) &#123; console.log(&apos;文档结构正确&apos;);&#125; else &#123; console.log(&apos;&lt;body&gt; 不能在 &lt;head&gt; 前面&apos;);&#125; 上面代码中，compareDocumentPosition的返回值与4（又称掩码）进行与运算（&amp;），得到一个布尔值，表示&lt;head&gt;是否在&lt;body&gt;前面。采用与运算其实也就是检查compareDocumentPosition的返回值中值为4的那一个二进制位是否为1，因为与4相与，4即000100，如果返回值中值为4的那一位等于1返回值就不为0，否则就为0。 Node.isEqualNode()，Node.isSameNode()isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 1234var p1 = document.createElement(&apos;p&apos;);var p2 = document.createElement(&apos;p&apos;);p1.isEqualNode(p2) // true isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点。 12345var p1 = document.createElement(&apos;p&apos;);var p2 = document.createElement(&apos;p&apos;);p1.isSameNode(p2) // falsep1.isSameNode(p1) // true Node.normalize()normailize方法用于整理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。 12345678var wrapper = document.createElement(&apos;div&apos;);wrapper.appendChild(document.createTextNode(&apos;Part 1 &apos;));wrapper.appendChild(document.createTextNode(&apos;Part 2 &apos;));wrapper.childNodes.length // 2wrapper.normalize();wrapper.childNodes.length // 1 上面代码使用normalize方法之前，wrapper节点有两个毗邻的文本子节点。使用normalize方法之后，两个文本子节点被合并成一个。 该方法是Text.splitText的逆方法，可以查看《Text 节点对象》一章，了解更多内容。 Node.getRootNode()getRootNode方法返回当前节点所在文档的根节点。 1document.body.firstChild.getRootNode() === document // true NodeList 接口节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。 这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。 概述NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。 Node.childNodesdocument.querySelectorAll()、document.getElementsByTagName()等节点搜索方法 1document.body.childNodes instanceof NodeList // true NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。 123456var children = document.body.childNodes;Array.isArray(children) // falsechildren.length // 34children.forEach(console.log) 上面代码中，NodeList实例children不是数组，但是具有length属性和forEach方法。 如果NodeList实例要使用数组方法，可以将其转为真正的数组。 12var children = document.body.childNodes;var nodeArr = Array.prototype.slice.call(children); 除了使用forEach方法遍历NodeList实例，还可以使用for循环。 12345var children = document.body.childNodes;for (var i = 0; i &lt; children.length; i++) &#123; var item = children[i];&#125; 注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。 1234var children = document.body.childNodes;children.length // 18document.body.appendChild(document.createElement(&apos;p&apos;));children.length // 19 上面代码中，文档增加一个子节点，NodeList 实例children的length属性就增加了1。 NodeList.prototype.lengthlength属性返回 NodeList 实例包含的节点数量*。 12document.getElementsByTagName(&apos;xxx&apos;).length// 0 上面代码中，document.getElementsByTagName返回一个 NodeList 集合。对于那些不存在的 HTML 标签，length属性返回0。 NodeList.prototype.forEach()forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。 1234var children = document.body.childNodes;children.forEach(function f(item, i, list) &#123; // ...&#125;, this); 上面代码中，回调函数f的三个参数依次是当前成员、位置和当前 NodeList 实例。 forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。 NodeList.prototype.item()item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 1document.body.childNodes.item(0) 上面代码中，item(0)返回第一个成员。 如果参数值大于实际长度，或者索引不合法（比如负数），item方法返回null。如果省略参数，item方法会报错。 注意，如果传入奇怪的值，则相当于传入0。 所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用item方法。 1document.body.childNodes[0] NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()这三个方法都返回一个 ES6 的遍历器对象，可以通过for...of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。 1234567891011121314151617181920212223var children = document.body.childNodes;for (var key of children.keys()) &#123; console.log(key);&#125;// 0// 1// 2// ...for (var value of children.values()) &#123; console.log(value);&#125;// #text// &lt;script&gt;// ...for (var entry of children.entries()) &#123; console.log(entry);&#125;// Array [ 0, #text ]// Array [ 1, &lt;script&gt; ]// ... HTMLCollection 接口概述HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。 返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如document.links、docuement.forms、document.images等。 1document.links instanceof HTMLCollection // true HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。 如果元素节点有id或name属性，那么HTMLCollection实例上面，可以使用id属性或name属性引用该节点元素。如果没有对应的节点，则返回null。 12345// HTML 代码如下// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;var pic = document.getElementById(&apos;pic&apos;);document.images.pic === pic // true 上面代码中，document.images是一个HTMLCollection实例，可以通过&lt;img&gt;元素的id属性值，从HTMLCollection实例上取到这个元素。 HTMLCollection.prototype.lengthlength属性返回HTMLCollection实例包含的成员数量。 1document.links.length // 18 HTMLCollection.prototype.item()item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 12var c = document.images;var img0 = c.item(0); 上面代码中，item(0)表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。 如果参数值超出成员数量或者不合法（比如小于0），那么item方法返回null。如果不传入参数，则item方法报错。 HTMLCollection.prototype.namedItem()namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。 12345// HTML 代码如下// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;var pic = document.getElementById(&apos;pic&apos;);document.images.namedItem(&apos;pic&apos;) === pic // true ParentNode 接口节点对象除了继承 Node 接口以外，还会继承其他接口。ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。 如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口。 ParentNode.childrenchildren属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。 下面是遍历某个节点的所有元素子节点的示例。 123for (var i = 0; i &lt; el.children.length; i++) &#123; // ...&#125; 注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。 另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化。 ParentNode.firstElementChildfirstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。 12document.firstElementChild.nodeName// &quot;HTML&quot; 上面代码中，document节点的第一个元素子节点是&lt;HTML&gt;。 ParentNode.lastElementChildlastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。 12document.lastElementChild.nodeName// &quot;HTML&quot; 上面代码中，document节点的最后一个元素子节点是&lt;HTML&gt;（因为document只包含这一个元素子节点）。 ParentNode.childElementCountchildElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。 1document.body.childElementCount // 13 ParentNode.append()，ParentNode.prepend()append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。 该方法不仅可以添加元素子节点，还可以添加文本子节点。 1234567891011121314151617var parent = document.body;// 添加元素子节点var p = document.createElement(&apos;p&apos;);parent.append(p);// 添加文本子节点parent.append(&apos;Hello&apos;);// 添加多个元素子节点var p1 = document.createElement(&apos;p&apos;);var p2 = document.createElement(&apos;p&apos;);parent.append(p1, p2);// 添加元素子节点和文本子节点var p = document.createElement(&apos;p&apos;);parent.append(&apos;Hello&apos;, p); 注意，该方法没有返回值。 prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。 ChildNode 接口如果一个节点有父节点，那么该节点就继承了ChildNode接口。 ChildNode.remove()remove方法用于从父节点移除当前节点。 1el.remove() 上面代码在 DOM 里面移除了el节点。 ChildNode.before()，ChildNode.after()before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。 注意，该方法不仅可以插入元素节点，还可以插入文本节点。 1234567891011121314var p = document.createElement(&apos;p&apos;);var p1 = document.createElement(&apos;p&apos;);// 插入元素节点el.before(p);// 插入文本节点el.before(&apos;Hello&apos;);// 插入多个元素节点el.before(p, p1);// 插入元素节点和文本节点el.before(p, &apos;Hello&apos;); after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。 ChildNode.replaceWith()replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。 12var span = document.createElement(&apos;span&apos;);el.replaceWith(span); 上面代码中，el节点将被span节点替换。 document 对象概述document对象是文档的根节点，每张网页都有自己的document对象。window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。 document对象有不同的办法可以获取。 正常的网页，直接使用document或window.document。iframe框架里面的网页，使用iframe节点的contentDocument属性。Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。内部节点的ownerDocument属性。 补充，想在iframe中获取父窗口的document可以使用window.parent.document。 document对象继承了EventTarget接口、Node接口、ParentNode接口。这意味着，这些接口的方法都可以在document对象上调用。除此之外，document对象还有很多自己的属性和方法。 属性快捷方式属性以下属性是指向文档内部的某个节点的快捷方式。 document.defaultViewdocument.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 1document.defaultView === window // true document.doctype对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 123var doctype = document.doctype;doctype // &quot;&lt;!DOCTYPE html&gt;&quot;doctype.name // &quot;html&quot; document.firstChild通常就返回这个节点。 document.documentElementdocument.documentElement属性返回当前文档的根节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是&lt;html&gt;节点。 document.body，document.headdocument.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。 这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 document.scrollingElementdocument.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。 标准模式下，这个属性返回的文档的根元素document.documentElement（即&lt;html&gt;）。兼容（quirk）模式下，返回的是&lt;body&gt;元素，如果该元素不存在，返回null。 12// 页面滚动到浏览器顶部document.scrollingElement.scrollTop = 0; document.activeElementdocument.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。 document.fullscreenElementdocument.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 123if (document.fullscreenElement.nodeName == &apos;VIDEO&apos;) &#123; console.log(&apos;全屏播放视频&apos;);&#125; 上面代码中，通过document.fullscreenElement可以知道&lt;video&gt;元素有没有处在全屏状态，从而判断用户行为。 节点集合属性以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。 document.linksdocument.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。 12345// 打印文档所有的链接var links = document.links;for(var i = 0; i &lt; links.length; i++) &#123; console.log(links[i]);&#125; document.formsdocument.forms属性返回所有&lt;form&gt;表单节点。 1var selectForm = document.forms[0]; 上面代码获取文档第一个表单。 document.imagesdocument.images属性返回页面所有&lt;img&gt;图片节点。 1234567var imglist = document.images;for(var i = 0; i &lt; imglist.length; i++) &#123; if (imglist[i].src === &apos;banner.gif&apos;) &#123; // ... &#125;&#125; 上面代码在所有img标签中，寻找某张图片。 document.embeds，document.pluginsdocument.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。 document.scriptsdocument.scripts属性返回所有&lt;script&gt;节点。 1234var scripts = document.scripts;if (scripts.length !== 0 ) &#123; console.log(&apos;当前网页有脚本&apos;);&#125; document.styleSheetsdocument.styleSheets属性返回文档内嵌或引入的样式表集合，详细介绍请看《CSS 对象模型》一章。 小结除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。 123456document.links instanceof HTMLCollection // truedocument.images instanceof HTMLCollection // truedocument.forms instanceof HTMLCollection // truedocument.embeds instanceof HTMLCollection // truedocument.scripts instanceof HTMLCollection // truedocument.styleSheets instanceof HTMLCollection // false HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 123// HTML 代码如下// &lt;form name=&quot;myForm&quot;&gt;document.myForm === document.forms.myForm // true 文档静态信息属性以下属性返回文档信息。 document.documentURI，document.URLdocument.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 12345document.URL// http://www.example.com/aboutdocument.documentURI === document.URL// true 如果文档的锚点（#anchor）变化，这两个属性都会跟着变化。 document.domaindocument.domain属性返回当前文档的域名，不包含协议和接口。比如，网页的网址是http://www.example.com:80/hello.html，那么domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。 另外，设置document.domain会导致端口被改成null。因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。 document.locationLocation对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。 document.lastModifieddocument.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 12document.lastModified// &quot;03/07/2018 11:18:27&quot; 注意，document.lastModified属性的值是字符串，所以不能直接用来比较。Date.parse方法将其转为Date实例，才能比较两个网页。 1234var lastVisitedDate = Date.parse(&apos;01/01/2018&apos;);if (Date.parse(document.lastModified) &gt; lastVisitedDate) &#123; console.log(&apos;网页已经变更&apos;);&#125; 如果页面上有 JavaScript 生成的内容，document.lastModified属性返回的总是当前时间。 document.titledocument.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 12document.title = &apos;新标题&apos;;document.title // &quot;新标题&quot; document.characterSetdocument.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 document.referrerdocument.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 12document.referrer// &quot;https://example.com/path&quot; 如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。 document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r。 document.dirdocument.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 document.compatModecompatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如&lt;!doctype html&gt;），document.compatMode的值都为CSS1Compat。 文档状态属性document.hiddendocument.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。 document.visibilityStatedocument.visibilityState返回文档的可见状态。 它的值有四种可能。 visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。hidden： 页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。prerender：页面处于正在渲染状态，对于用于来说，该页面不可见。unloaded：页面从内存里面卸载了。 这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。 document.readyStatedocument.readyState属性返回当前文档的状态，共有三种可能的值。 loading：加载 HTML 代码阶段（尚未完成解析）interactive：加载外部资源阶段complete：加载完成 这个属性变化的过程如下。 浏览器开始解析 HTML 文档，document.readyState属性等于loading。 浏览器遇到 HTML 文档中的&lt;script&gt;元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。 HTML 文档解析完成，document.readyState属性变成interactive。 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。 下面的代码用来检查网页是否加载成功。 123456789101112// 基本检查if (document.readyState === &apos;complete&apos;) &#123; // ...&#125;// 轮询检查var interval = setInterval(function() &#123; if (document.readyState === &apos;complete&apos;) &#123; clearInterval(interval); // ... &#125;&#125;, 100); 另外，每次状态变化都会触发一个readystatechange事件。 document.cookiedocument.cookie属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。 document.designModedocument.designMode属性控制当前文档是否可编辑，通常用在所见即所得编辑器。该属性只有两个值on和off，默认值为off。 下面代码打开iframe元素内部文档的designMode属性，就能将其变为一个所见即所得的编辑器。 1234// HTML 代码如下// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;var editor = document.getElementById(&apos;editor&apos;);editor.contentDocument.designMode = &apos;on&apos;; 上面代码会使一个空白的iframe变为一个文本框一般的编辑器。 document.implementationdocument.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 DOMImplementation.createDocument()：创建一个 XML 文档。DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。 下面是创建 HTML 文档的例子。 123456789var doc = document.implementation.createHTMLDocument(&apos;Title&apos;);var p = doc.createElement(&apos;p&apos;);p.innerHTML = &apos;hello world&apos;;doc.body.appendChild(p);document.replaceChild( doc.documentElement, document.documentElement); 上面代码中，第一步生成一个新的 HTML 文档doc，然后用它的根元素document.documentElement替换掉document.documentElement。这会使得当前文档的内容全部消失，变成hello world。 方法document.open()，document.close()document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 document.close方法用来关闭document.open()打开的文档。 document.write()，document.writeln()document.write方法用于向当前文档写入内容。 在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 12345// 页面显示“helloworld”document.open();document.write(&apos;hello&apos;);document.write(&apos;world&apos;);document.close(); 注意，document.write会当作 HTML 代码解析，不会转义。 1document.write(&apos;&lt;p&gt;hello world&lt;/p&gt;&apos;); 上面代码中，document.write会将&lt;p&gt;当作 HTML 标签解释。 如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 12345678910document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;);&#125;);// 等同于document.addEventListener(&apos;DOMContentLoaded&apos;, function (event) &#123; document.open(); document.write(&apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;); document.close();&#125;); 如果在页面渲染过程中调用write方法，并不会自动调用open方法。（可以理解成，open方法已调用，但close方法还未调用。） 12345678&lt;html&gt;&lt;body&gt;hello&lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;world&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器打开上面网页，将会显示hello world。 document.write是JavaScript语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对innerHTML属性赋值）。所以，除了某些特殊情况，应该尽量避免使用document.write这个方法。 document.writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。 123456789document.write(1);document.write(2);// 12document.writeln(1);document.writeln(2);// 1// 2// 注意，writeln方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入&lt;br&gt;。 document.querySelector()，document.querySelectorAll()document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 12var el1 = document.querySelector(&apos;.myclass&apos;);var el2 = document.querySelector(&apos;#myParent &gt; [ng-click]&apos;); document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。 1elementList = document.querySelectorAll(&apos;.myclass&apos;); 这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。 1var matches = document.querySelectorAll(&apos;div.note, div.alert&apos;); 上面代码返回class属性是note或alert的div元素。 这两个方法都支持复杂的 CSS 选择器。 1234567891011// 选中 data-foo-bar 属性等于 someval 的元素document.querySelectorAll(&apos;[data-foo-bar=&quot;someval&quot;]&apos;);// 选中 myForm 表单中所有不通过验证的元素document.querySelectorAll(&apos;#myForm :invalid&apos;);// 选中div元素，那些 class 含 ignore 的除外document.querySelectorAll(&apos;DIV:not(.ignore)&apos;);// 同时选中 div，a，script 三类元素document.querySelectorAll(&apos;DIV, A, SCRIPT&apos;); 但是，它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。 如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。 最后，这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。 关于伪元素和伪类的补充伪元素：（pseudo-element）是HTML 中并不存在的元素。用于将特殊的效果添加到某些选择器。 W3C： 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 2 以下是CSS3中对伪元素的描述： 伪元素的由两个冒号::开头，然后是伪元素的名称 。 使用两个冒号::是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是CSS3中新增的伪元素必须使用两个冒号:: 例如：12345// 选择每个 &lt;p&gt; 元素的首字母，并为其设置样式：p:first-letter&#123; font-size:200%; color:#8A2BE2;&#125; :after与:before的一个用处在于，可以减少html代码里的节点个数及内容，优化代码阅读。 :after还有一个妙用，那就是清除浮动，给父元素追加:after之后，设置content：&quot;&quot;;clear:both;就可以清除浮动。 下面看看伪类： 伪类：(pseudo-class）则应用于一组HTML元素。用于向某些选择器添加特殊的效果。 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 css3中定义： 伪类存在的意义是为了通过选择器找到那些不存在于DOM树中的信息以及不能被常规CSS选择器获取到的信息。 伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。 任何常规选择器可以在任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。 并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。 从定义得知，伪类的作用是获取页面中不存在的信息。比如&lt;a&gt;&lt;/a&gt; 标签中的:linked `:visited`,这些内容不存在页面当中，只能通过css选择器来获取。 且一个元素可以同时设置多个伪类效果。其中，运用伪类最多的是&lt;a&gt;&lt;/a&gt;添加链接样式。 12345678a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 这里要注意的是，这几个伪类如果同时出现在一个元素的操作上，顺序不能改变，否则很大程度上会产生紊乱，效果不生效。 伪类与伪元素的区别：伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。 document.getElementsByTagName()document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 12var paras = document.getElementsByTagName(&apos;p&apos;);paras instanceof HTMLCollection // true 上面代码返回当前文档的所有p元素节点。 HTML 标签名是大小写不敏感的，因此getElementsByTagName方法的参数也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。 如果传入*，就可以返回文档中所有 HTML 元素。 1var allElements = document.getElementsByTagName(&apos;*&apos;); 注意，元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。 12var firstPara = document.getElementsByTagName(&apos;p&apos;)[0];var spans = firstPara.getElementsByTagName(&apos;span&apos;); 上面代码选中第一个p元素内部的所有span元素。 document.getElementsByClassName()document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。 1var elements = document.getElementsByClassName(names); 由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。 参数可以是多个class，它们之间使用空格分隔。 1var elements = document.getElementsByClassName(&apos;foo bar&apos;); 上面代码返回同时具有foo和bar两个class的元素，foo和bar的顺序不重要。 注意，正常模式下，CSS 的class是大小写敏感的。（quirks mode下，大小写不敏感。） 与getElementsByTagName方法一样，getElementsByClassName方法不仅可以在document对象上调用，也可以在任何元素节点上调用。 12// 非document对象上调用var elements = rootElement.getElementsByClassName(names); document.getElementsByName()document.getElementsByName方法用于选择拥有name属性的 HTML 元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等），返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。 123// 表单为 &lt;form name=&quot;x&quot;&gt;&lt;/form&gt;var forms = document.getElementsByName(&apos;x&apos;);forms[0].tagName // &quot;FORM&quot; document.getElementById()document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。 1var elem = document.getElementById(&apos;para1&apos;); 注意，该方法的参数是大小写敏感的。比如，如果某个节点的id属性是main，那么document.getElementById(&#39;Main&#39;)将返回null。 document.getElementById方法与document.querySelector方法都能获取元素节点，不同之处是document.querySelector方法的参数使用 CSS 选择器语法，document.getElementById方法的参数是元素的id属性。 12document.getElementById(&apos;myElement&apos;)document.querySelector(&apos;#myElement&apos;) 上面代码中，两个方法都能选中id为myElement的元素，但是document.getElementById()比document.querySelector()效率高得多。 另外，这个方法只能在document对象上使用，不能在其他元素节点上使用。 document.elementFromPoint()，document.elementsFromPoint()document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。 1var element = document.elementFromPoint(50, 50); 上面代码选中在(50, 50)这个坐标位置的最上层的那个 HTML 元素。 elementFromPoint方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回null。 document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 1var elements = document.elementsFromPoint(x, y); document.caretPositionFromPoint()document.caretPositionFromPoint()返回一个 CaretPosition 对象，包含了指定坐标点在节点对象内部的位置信息。CaretPosition 对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。 1var range = document.caretPositionFromPoint(clientX, clientY); 上面代码中，range是指定坐标点的 CaretPosition 对象。该对象有两个属性。 CaretPosition.offsetNode：该位置的节点对象CaretPosition.offset：该位置在offsetNode对象内部，与起始位置相距的字符数。 document.createElement()document.createElement方法用来生成元素节点，并返回该节点。 1var newDiv = document.createElement(&apos;div&apos;); createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感，即参数为div或DIV返回的是同一种节点。如果参数里面包含尖括号（即&lt;和&gt;）会报错。 12document.createElement(&apos;&lt;div&gt;&apos;);// DOMException: The tag name provided (&apos;&lt;div&gt;&apos;) is not a valid name 注意，document.createElement的参数可以是自定义的标签名。 1document.createElement(&apos;foo&apos;); document.createTextNode()document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。 123var newDiv = document.createElement(&apos;div&apos;);var newContent = document.createTextNode(&apos;Hello&apos;);newDiv.appendChild(newContent); 上面代码新建一个div节点和一个文本节点，然后将文本节点插入div节点。 这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。 1234var div = document.createElement(&apos;div&apos;);div.appendChild(document.createTextNode(&apos;&lt;span&gt;Foo &amp; bar&lt;/span&gt;&apos;));console.log(div.innerHTML)// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt; 上面代码中，createTextNode方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。 需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。 1234567891011function escapeHtml(str) &#123; var div = document.createElement(&apos;div&apos;); div.appendChild(document.createTextNode(str)); return div.innerHTML;&#125;;var userWebsite = &apos;&quot; onmouseover=&quot;alert(\&apos;derp\&apos;)&quot; &quot;&apos;;var profileLink = &apos;&lt;a href=&quot;&apos; + escapeHtml(userWebsite) + &apos;&quot;&gt;Bob&lt;/a&gt;&apos;;var div = document.getElementById(&apos;target&apos;);div.innerHTML = profileLink;// &lt;a href=&quot;&quot; onmouseover=&quot;alert(&apos;derp&apos;)&quot; &quot;&quot;&gt;Bob&lt;/a&gt; 上面代码中，由于createTextNode方法不转义双引号，导致onmouseover方法被注入了代码。 document.createAttribute()document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。 1var attribute = document.createAttribute(name); document.createAttribute方法的参数name，是属性的名称。 12345678var node = document.getElementById(&apos;div1&apos;);var a = document.createAttribute(&apos;my_attrib&apos;);a.value = &apos;newVal&apos;;node.setAttributeNode(a);// 或者node.setAttribute(&apos;my_attrib&apos;, &apos;newVal&apos;); 上面代码为div1节点，插入一个值为newVal的my_attrib属性。 document.createComment()document.createComment方法生成一个新的注释节点，并返回该节点。 1var CommentNode = document.createComment(data); document.createComment方法的参数是一个字符串，会成为注释节点的内容。 document.createDocumentFragment()document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。 1var docFragment = document.createDocumentFragment(); DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。 12345678910var docfrag = document.createDocumentFragment();[1, 2, 3, 4].forEach(function (e) &#123; var li = document.createElement(&apos;li&apos;); li.textContent = e; docfrag.appendChild(li);&#125;);var element = document.getElementById(&apos;ul&apos;);element.appendChild(docfrag); 上面代码中，文档片断docfrag包含四个&lt;li&gt;节点，这些子节点被一次性插入了当前文档。 document.createEvent()document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。 1var event = document.createEvent(type); document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。 123456var event = document.createEvent(&apos;Event&apos;);event.initEvent(&apos;build&apos;, true, true);document.addEventListener(&apos;build&apos;, function (e) &#123; console.log(e.type); // &quot;build&quot;&#125;, false);document.dispatchEvent(event); 上面代码新建了一个名为build的事件实例，然后触发该事件。 document.addEventListener()，document.removeEventListener()，document.dispatchEvent()这三个方法用于处理document节点的事件。它们都继承自EventTarget接口，详细介绍参见《EventTarget 接口》一章。 123456789// 添加事件监听函数document.addEventListener(&apos;click&apos;, listener, false);// 移除事件监听函数document.removeEventListener(&apos;click&apos;, listener, false);// 触发事件，相当于jQuery中的triggervar event = new Event(&apos;click&apos;);document.dispatchEvent(event); document.hasFocus()document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 1var focused = document.hasFocus(); 注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。 document.adoptNode()，document.importNode()document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。 12var node = document.adoptNode(externalNode);document.appendChild(node); 注意，document.adoptNode方法只是改变了节点的归属，并没有将这个节点插入新的文档树，也就是刚才说到的parentNode属性是null。所以，还要再用appendChild方法或insertBefore方法，将新节点插入当前文档树。 document.importNode方法则是从原来所在的文档或DocumentFragment里面，拷贝某个节点及其子节点，让它们归属当前document对象。拷贝的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。 也就是说，adoptNode()方法相当于剪切，importNode()方法相当于复制。 1var node = document.importNode(externalNode, deep); document.importNode方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为true。 注意，document.importNode方法只是拷贝外部节点，这时该节点的父节点是null。下一步还必须将这个节点插入当前文档树。 1234var iframe = document.getElementsByTagName(&apos;iframe&apos;)[0];var oldNode = iframe.contentWindow.document.getElementById(&apos;myNode&apos;);var newNode = document.importNode(oldNode, true);document.getElementById(&quot;container&quot;).appendChild(newNode); 上面代码从iframe窗口，拷贝一个指定节点myNode，插入当前文档。 扩展：关于浅拷贝和深拷贝 深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。 深复制在计算机中开辟了一块内存地址用于存放复制的对象。 而浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。 所谓的浅复制，只是拷贝了基本类型的数据，而引用类型数据，复制后会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”。 document.createNodeIterator()document.createNodeIterator方法返回一个子节点遍历器。 1234var nodeIterator = document.createNodeIterator( document.body, NodeFilter.SHOW_ELEMENT); 上面代码返回&lt;body&gt;元素子节点的遍历器。 document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型， 默认遍历所有节点，这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。 所有节点：NodeFilter.SHOW_ALL元素节点：NodeFilter.SHOW_ELEMENT文本节点：NodeFilter.SHOW_TEXT评论/注释节点：NodeFilter.SHOW_COMMENT document.createNodeIterator方法返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。 1234567var nodeIterator = document.createNodeIterator(document.body);var pars = [];var currentNode;while (currentNode = nodeIterator.nextNode()) &#123; pars.push(currentNode);&#125; 上面代码中，使用遍历器的nextNode方法，将根节点的所有子节点，依次读入一个数组。nextNode方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回null。previousNode方法则是先将指针移向上一个节点，然后返回该节点。 123456789var nodeIterator = document.createNodeIterator( document.body, NodeFilter.SHOW_ELEMENT);var currentNode = nodeIterator.nextNode();var previousNode = nodeIterator.previousNode();currentNode === previousNode // true 上面代码中，currentNode和previousNode都指向同一个的节点。 注意，遍历器返回的第一个节点，总是根节点。 1pars[0] === document.body // true document.createTreeWalker()document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。 document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。 12345678910var treeWalker = document.createTreeWalker( document.body, NodeFilter.SHOW_ELEMENT);var nodeList = [];while(treeWalker.nextNode()) &#123; nodeList.push(treeWalker.currentNode);&#125; 上面代码遍历&lt;body&gt;节点下属的所有元素节点，将它们插入nodeList数组。 document.getSelection()这个方法指向window.getSelection()，参见window对象一节的介绍。 Element对象Element对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。 元素节点的nodeType属性都是1。 123var p = document.querySelector(&apos;p&apos;);p.nodeName // &quot;P&quot;p.nodeType // 1 Element对象继承了Node接口，因此Node的属性和方法在Element对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如&lt;a&gt;元素的节点对象由HTMLAnchorElement构造函数生成，&lt;button&gt;元素的节点对象由HTMLButtonElement构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承Element的属性和方法，还有各自构造函数的属性和方法。 实例属性元素特性的相关属性Element.id（可读写）Element.id属性返回指定元素的id属性，该属性可读写。 123// HTML 代码为 &lt;p id=&quot;foo&quot;&gt;var p = document.querySelector(&apos;p&apos;);p.id // &quot;foo&quot; 注意，id属性的值是大小写敏感，即浏览器能正确识别&lt;p id=&quot;foo&quot;&gt;和&lt;p id=&quot;FOO&quot;&gt;这两个元素的id属性，但是最好不要这样命名。 Element.tagNameElement.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。 12345// HTML代码为// &lt;span id=&quot;myspan&quot;&gt;Hello&lt;/span&gt;var span = document.getElementById(&apos;myspan&apos;);span.id // &quot;myspan&quot;span.tagName // &quot;SPAN&quot; Element.dirElement.dir属性用于读写当前元素的文字方向，可能是从左到右（&quot;ltr&quot;），也可能是从右到左（&quot;rtl&quot;）。 Element.accessKeyElement.accessKey属性用于读写分配给当前元素的快捷键。 1234// HTML 代码如下// &lt;button accesskey=&quot;h&quot; id=&quot;btn&quot;&gt;点击&lt;/button&gt;var btn = document.getElementById(&apos;btn&apos;);btn.accessKey // &quot;h&quot; 上面代码中，btn元素的快捷键是h，按下Alt + h就能将焦点转移到它上面。 为元素指定快捷键，以下元素支持 accesskey 属性：&lt;a&gt;,&lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;label&gt;, &lt;legend&gt; 以及 &lt;textarea&gt;，使用Alt + accessKey (或者 Shift + Alt + accessKey) 来访问带有指定快捷键的元素。 Element.draggable（可读写）Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。 Element.lang（可读写）Element.lang属性返回当前元素的语言设置。该属性可读写。 123// HTML 代码如下// &lt;html lang=&quot;en&quot;&gt;document.documentElement.lang // &quot;en&quot; Element.tabIndexElement.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。 tabIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，顺序为它们在网页中出现的顺序。 Element.titleElement.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。 元素状态的相关属性Element.hidden（可读写）Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。 123456var btn = document.getElementById(&apos;btn&apos;);var mydiv = document.getElementById(&apos;mydiv&apos;);btn.addEventListener(&apos;click&apos;, function () &#123; mydiv.hidden = !mydiv.hidden;&#125;, false); 注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。也就是说，这个属性并不难用来判断当前元素的实际可见性。 CSS 的设置高于Element.hidden。如果 CSS 指定了该元素不可见（display: none）或可见（display: hidden），那么Element.hidden并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。 Element.contentEditable（可读写），Element.isContentEditableHTML 元素可以设置contentEditable属性，使得元素的内容可以编辑。 1&lt;div contenteditable&gt;123&lt;/div&gt; 上面代码中，&lt;div&gt;元素有contenteditable属性，因此用户可以在网页上编辑这个区块的内容。 Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可读写。 &quot;true&quot;：元素内容可编辑&quot;false&quot;：元素内容不可编辑&quot;inherit&quot;：元素是否可编辑，继承了父元素的设置 Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。 Element.attributesElement.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点，详见《Attr 对象》一章。 123456var p = document.querySelector(&apos;p&apos;);var attrs = p.attributes;for (var i = attrs.length - 1; i &gt;= 0; i--) &#123; console.log(attrs[i].name + &apos;-&gt;&apos; + attrs[i].value);&#125; 上面代码遍历p元素的所有属性。]]></content>
      <categories>
        <category>JavaScript标准教程笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript标准参考教程》阅读笔记之《语法专题》]]></title>
    <url>%2F2018%2F05%2F21%2FJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98%E3%80%8B%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址 异步操作概述单线程模型单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。 JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。 如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。 单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 同步任务和异步任务程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。 举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。 任务队列和事件循环JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。） 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。 异步操作的模式回调函数回调函数是异步操作最基本的方法。 下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。 12345678910function f1() &#123; // ...&#125;function f2() &#123; // ...&#125;f1();f2(); 上面代码的问题在于，如果f1是异步操作，f2会立即执行，不会等到f1结束再执行。 这时，可以考虑改写f1，把f2写成f1的回调函数。 12345678910function f1(callback) &#123; // ... callback();&#125;function f2() &#123; // ...&#125;f1(f2); 回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。 事件监听另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。 1f1.on(&apos;done&apos;, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写： 123456function f1() &#123; setTimeout(function () &#123; // ... f1.trigger(&apos;done&apos;); &#125;, 1000);&#125; 上面代码中，f1.trigger(&#39;done&#39;)表示，执行完成后，立即触发done事件，从而开始执行f2。 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 发布/订阅事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。 这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub/Sub，这是 jQuery 的一个插件。 首先，f2向信号中心jQuery订阅done信号。 1jQuery.subscribe(&apos;done&apos;, f2); 然后，f1进行如下改写。 123456function f1() &#123; setTimeout(function () &#123; // ... jQuery.publish(&apos;done&apos;); &#125;, 1000);&#125; 上面代码中，jQuery.publish(&#39;done&#39;)的意思是，f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。 f2完成执行后，可以取消订阅（unsubscribe）。 1jQuery.unsubscribe(&apos;done&apos;, f2); 这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 异步操作的流程控制如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。 1234function async(arg, callback) &#123; console.log(&apos;参数为 &apos; + arg +&apos; , 1秒后返回结果&apos;); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125; 上面代码的async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。 如果有六个这样的异步任务，需要全部完成后，才能执行最后的final函数。请问应该如何安排操作流程？ 123456789101112131415function final(value) &#123; console.log(&apos;完成: &apos;, value);&#125;async(1, function(value)&#123; async(value, function(value)&#123; async(value, function(value)&#123; async(value, function(value)&#123; async(value, function(value)&#123; async(value, final); &#125;); &#125;); &#125;); &#125;);&#125;); 上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。 串行执行我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。 123456789101112131415161718192021222324var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];function async(arg, callback) &#123; console.log(&apos;参数为 &apos; + arg +&apos; , 1秒后返回结果&apos;); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log(&apos;完成: &apos;, value);&#125;function series(item) &#123; if(item) &#123; async( item, function(result) &#123; results.push(result); return series(items.shift()); &#125;); &#125; else &#123; return final(results[results.length - 1]); &#125;&#125;series(items.shift()); 上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。 上面代码中的return series(items.shift());语句是用来保证在第一次运行完毕之后可以递归调用series函数。如果去掉这句，则只返回一个参数为 1 , 1秒后返回结果，也就是该函数只执行了一次，即上面代码中最后一句调用的那一次。加上return后，在调用callback的地方会再次调用series函数，保证了能将所有参数运行一遍。 并且return series(items.shift());语句保证了这些异步函数是串行执行的。 注意，上面的写法需要六秒，才能完成整个脚本。 并行执行流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。 1234567891011121314151617181920var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];function async(arg, callback) &#123; console.log(&apos;参数为 &apos; + arg +&apos; , 1秒后返回结果&apos;); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log(&apos;完成: &apos;, value);&#125;items.forEach(function(item) &#123; async(item, function(result)&#123; results.push(result); if(results.length === items.length) &#123; final(results[results.length - 1]); &#125; &#125;)&#125;); 上面代码中，forEach方法会同时发起六个异步任务，等到它们全部完成以后，才会执行final函数。 相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。 并行与串行的结合所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。 12345678910111213141516171819202122232425262728293031var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];var running = 0;var limit = 2;function async(arg, callback) &#123; console.log(&apos;参数为 &apos; + arg +&apos; , 1秒后返回结果&apos;); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log(&apos;完成: &apos;, value);&#125;function launcher() &#123; while(running &lt; limit &amp;&amp; items.length &gt; 0) &#123; var item = items.shift(); async(item, function(result) &#123; results.push(result); running--; if(items.length &gt; 0) &#123; launcher(); &#125; else if(running == 0) &#123; final(results); &#125; &#125;); running++; &#125;&#125;launcher(); 上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。 上面代码的执行过程是，调用launcher()后首先进入while循环，因为限制了limit等于2，所以一次性只能执行两次循环，这两次循环相差的时间十分小，两次循环都调用了async函数，但因为该函数中有一秒后才可以执行的代码，所以第一次调用async函数后程序会挂起在那，先去执行下一个async函数，而同理下一个async函数也被挂起，程序会再进入下一次while循环，此时发现running大于limit，因此while循环停止了。等待async函数执行完毕之后才继续执行下面的代码。因为向async函数中传入的回调函数是在一秒后执行的，所以当执行完async函数后，传入的回调函数中的running--也被调用了。这样如果items中仍有值，就继续调用launcher()函数，就可以顺利进入下一轮while循环。 这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。 定时器JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。 setTimeout()setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。 1var timerId = setTimeout(func|code, delay); 上面代码中，setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。 123456console.log(1);setTimeout(&apos;console.log(2)&apos;,1000);console.log(3);// 1// 3// 2 上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，console.log(2)必须以字符串的形式，作为setTimeout的参数。 也就是说，如果推迟执行的是一段代码，则代码必须以字符串的形式作为setTimeout的参数。 如果推迟执行的是函数，就直接将函数名，作为setTimeout的参数。 12345function f() &#123; console.log(2);&#125;setTimeout(f, 1000); setTimeout的第二个参数如果省略，则默认为0。 123setTimeout(f)// 等同于setTimeout(f, 0) 除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。 123setTimeout(function (a,b) &#123; console.log(a + b);&#125;, 1000, 1, 1); 上面代码中，setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。 还有一个需要注意的地方，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。 12345678910var x = 1;var obj = &#123; x: 2, y: function () &#123; console.log(this.x); &#125;&#125;;setTimeout(obj.y, 1000) // 1 上面代码输出的是1，而不是2。因为当obj.y在1000毫秒后运行时，this所指向的已经不是obj了，而是全局环境。 为了防止出现这个问题，一种解决方法是将obj.y放入一个函数。 12345678910111213var x = 1;var obj = &#123; x: 2, y: function () &#123; console.log(this.x); &#125;&#125;;setTimeout(function () &#123; obj.y();&#125;, 1000);// 2 上面代码中，obj.y放在一个匿名函数之中，这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。 另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。 1234567891011var x = 1;var obj = &#123; x: 2, y: function () &#123; console.log(this.x); &#125;&#125;;setTimeout(obj.y.bind(obj), 1000)// 2 setInterval()setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。 1234var i = 1var timer = setInterval(function() &#123; console.log(2);&#125;, 1000) 上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。 与setTimeout一样，除了前两个参数，setInterval方法还可以接受更多的参数，它们会传入回调函数。 下面是一个通过setInterval方法实现网页动画的例子。 12345678910var div = document.getElementById(&apos;someDiv&apos;);var opacity = 1;var fader = setInterval(function() &#123; opacity -= 0.1; if (opacity &gt;= 0) &#123; div.style.opacity = opacity; &#125; else &#123; clearInterval(fader); &#125;&#125;, 100); 上面代码每隔100毫秒，设置一次div元素的透明度，直至其完全透明为止。 setInterval的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。 123456var hash = window.location.hash;var hashWatcher = setInterval(function() &#123; if (window.location.hash != hash) &#123; updatePage(); &#125;&#125;, 1000); setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。 12345var i = 1;var timer = setTimeout(function f() &#123; // ... timer = setTimeout(f, 2000);&#125;, 2000); 上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。 clearTimeout()，clearInterval()setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。 12345var id1 = setTimeout(f, 1000);var id2 = setInterval(f, 1000);clearTimeout(id1);clearInterval(id2); 上面代码中，回调函数f不会再执行了，因为两个定时器都被取消了。 setTimeout和setInterval返回的整数值是连续的，也就是说，第二个setTimeout方法返回的整数值，将比第一个的整数值大1。 1234function f() &#123;&#125;setTimeout(f, 1000) // 10setTimeout(f, 1000) // 11setTimeout(f, 1000) // 12 上面代码中，连续调用三次setTimeout，返回值都比上一次大了1。 利用这一点，可以写一个函数，取消当前所有的setTimeout定时器。 12345678910111213(function() &#123; var gid = setInterval(clearAllTimeouts, 0); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123;&#125;, 0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 上面代码中，先调用setTimeout，得到一个计算器编号，然后把编号比它小的计数器全部取消。 实例：debounce 函数有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。 1$(&apos;textarea&apos;).on(&apos;keydown&apos;, ajaxAction); 这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发keydown事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的keydown事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，再将数据发送出去。 这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。 12345678910111213$(&apos;textarea&apos;).on(&apos;keydown&apos;, debounce(ajaxAction, 2500));function debounce(fn, delay)&#123; var timer = null; // 声明计时器 return function() &#123; var context = this; var args = arguments; clearTimeout(timer); timer = setTimeout(function () &#123; fn.apply(context, args); &#125;, delay); &#125;;&#125; 上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。 运行机制setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。 这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。 12setTimeout(someTask, 100);veryLongTask(); 上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面的veryLongTask函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到veryLongTask运行结束，才轮到它执行。 再看一个setInterval的例子。 12345setInterval(function () &#123; console.log(2);&#125;, 1000);sleep(3000); 上面代码中，setInterval要求每隔1000毫秒，就输出一个2。但是，紧接着的sleep语句需要3000毫秒才能完成，那么setInterval就必须推迟到3000毫秒之后才开始生效。注意，生效后setInterval不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。 setTimeout(f, 0)含义setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f, 0)，那么会立刻执行吗？ 答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。 123456setTimeout(function () &#123; console.log(1);&#125;, 0);console.log(2);// 2// 1 上面代码先输出2，再输出1。因为2是同步任务，在本轮事件循环执行，而1是下一轮事件循环执行。 总之，setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。 应用setTimeout(f, 0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。 1234567891011121314// HTML 代码如下// &lt;input type=&quot;button&quot; id=&quot;myButton&quot; value=&quot;click&quot;&gt;var input = document.getElementById(&apos;myButton&apos;);input.onclick = function A() &#123; setTimeout(function B() &#123; input.value +=&apos; input&apos;; &#125;, 0)&#125;;document.body.onclick = function C() &#123; input.value += &apos; body&apos;&#125;; 上面代码在点击按钮后，先触发回调函数A，然后触发函数C。函数A中，setTimeout将函数B推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数C的目的了。 另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。 这也就是说，在用户按下键盘按键的那一刻，后面的自定义回调函数就已经调用了。然而此时浏览器还没有执行默认动作，也就是说，此时在回调函数中取input框的value值，取到的是键盘上的按键被按下之前input框中的值，触发了这个回调函数之后，浏览器才真正接收到刚才那一下按键后input框中实际的值。 因此，下面的回调函数是达不到目的的。 123456// HTML 代码如下// &lt;input type=&quot;text&quot; id=&quot;input-box&quot;&gt;document.getElementById(&apos;input-box&apos;).onkeypress = function (event) &#123; this.value = this.value.toUpperCase();&#125; 上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。 123456document.getElementById(&apos;input-box&apos;).onkeypress = function() &#123; var self = this; setTimeout(function() &#123; self.value = self.value.toUpperCase(); &#125;, 0);&#125; 上面代码将代码放入setTimeout之中，就能使得它在浏览器接收到文本之后触发。 由于setTimeout(f, 0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f, 0)里面执行。 123456789101112131415161718var div = document.getElementsByTagName(&apos;div&apos;)[0];// 写法一for (var i = 0xA00000; i &lt; 0xFFFFFF; i++) &#123; div.style.backgroundColor = &apos;#&apos; + i.toString(16);&#125;// 写法二var timer;var i=0x100000;function func() &#123; timer = setTimeout(func, 0); div.style.backgroundColor = &apos;#&apos; + i.toString(16); if (i++ == 0xFFFFFF) clearTimeout(timer);&#125;timer = setTimeout(func, 0); 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，因为要执行下一次DOM操作之前，必须先保证上一次DOM操作结束，只有上一次DOM操作执行完毕，浏览器得到空闲后，才会执行setTimeout(func, 0)，这就是setTimeout(f, 0)的好处。 上面代码中的i++ == 0xFFFFFF语句，实际上是判断i与0xFFFFFF进行比较，判断过后才对i执行自增操作。验证如下。1234567var i = 1;i++ == 2;// falsevar i = 1;++i == 2// true 另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成setTimeout(highlightNext, 50)的样子，性能压力就会减轻。 Promise 对象概述Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。 本章只对Promise对象进行简短的介绍，更详细的等后续学习ES6时再继续。 首先，Promise 是一个对象，也是一个构造函数。 12345function f1(resolve, reject) &#123; // 异步代码...&#125;var p1 = new Promise(f1); 上面代码中，Promise构造函数接受一个回调函数f1作为参数，f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 实例。 Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。 12var p1 = new Promise(f1);p1.then(f2); 上面代码中，f1的异步操作执行完成，就会执行f2。 传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。 Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。 Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 异步操作未完成（pending）异步操作成功（fulfilled）异步操作失败（rejected） 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。 这三种的状态的变化途径只有两种。 从“未完成”到“成功”从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 Promise 构造函数JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。 123456789var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); 上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。 resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 下面是一个例子。 1234567function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &apos;done&apos;); &#125;);&#125;timeout(100) 上面代码中，timeout(100)返回一个 Promise 实例。100毫秒以后，该实例的状态会变为fulfilled。 Promise.prototype.then()Promise 实例的then方法，用来添加回调函数。 then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。 1234567891011var p1 = new Promise(function (resolve, reject) &#123; resolve(&apos;成功&apos;);&#125;);p1.then(console.log, console.error);// &quot;成功&quot;var p2 = new Promise(function (resolve, reject) &#123; reject(new Error(&apos;失败&apos;));&#125;);p2.then(console.log, console.error);// Error: 失败 上面代码中，p1和p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。 then方法可以链式使用。 12345678p1 .then(step1) .then(step2) .then(step3) .then( console.log, console.error ); 上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。 最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。 then() 用法辨析Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？ 123456789101112131415// 写法一f1().then(function () &#123; return f2();&#125;);// 写法二f1().then(function () &#123; f2();&#125;);// 写法三f1().then(f2());// 写法四f1().then(f2); 为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。 写法一的f3回调函数的参数，是f2函数的运行结果。123f1().then(function () &#123; return f2();&#125;).then(f3); 写法二的f3回调函数的参数是undefined。1234f1().then(function () &#123; f2(); return;&#125;).then(f3); 写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。12f1().then(f2()) .then(f3); 写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。 12f1().then(f2) .then(f3); Promise 的实例加载图片我们可以把图片的加载写成一个Promise对象。 12345678var preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Ajax 操作Ajax 操作是典型的异步操作，传统上往往写成下面这样。 123456789101112131415161718192021function search(term, onload, onerror) &#123; var xhr, results, url; url = &apos;http://example.com/search?q=&apos; + term; xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, url, true); xhr.onload = function (e) &#123; if (this.status === 200) &#123; results = JSON.parse(this.responseText); onload(results); &#125; &#125;; xhr.onerror = function (e) &#123; onerror(e); &#125;; xhr.send();&#125;search(&apos;Hello World&apos;, console.log, console.error); 如果使用 Promise 对象，就可以写成下面这样。 1234567891011121314151617181920212223function search(term) &#123; var url = &apos;http://example.com/search?q=&apos; + term; var xhr = new XMLHttpRequest(); var result; var p = new Promise(function (resolve, reject) &#123; xhr.open(&apos;GET&apos;, url, true); xhr.onload = function (e) &#123; if (this.status === 200) &#123; result = JSON.parse(this.responseText); resolve(result); &#125; &#125;; xhr.onerror = function (e) &#123; reject(e); &#125;; xhr.send(); &#125;); return p;&#125;search(&apos;Hello World&apos;).then(console.log, console.error); 加载图片的例子，也可以用 Ajax 操作完成。 123456789101112131415161718function imgLoad(url) &#123; return new Promise(function (resolve, reject) &#123; var request = new XMLHttpRequest(); request.open(&apos;GET&apos;, url); request.responseType = &apos;blob&apos;; request.onload = function () &#123; if (request.status === 200) &#123; resolve(request.response); &#125; else &#123; reject(new Error(&apos;图片加载失败：&apos; + request.statusText)); &#125; &#125;; request.onerror = function () &#123; reject(new Error(&apos;发生网络错误&apos;)); &#125;; request.send(); &#125;);&#125; 小结Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。 而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。 Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。 微任务Promise 的回调函数属于异步任务，会在同步任务之后执行。 1234567new Promise(function (resolve, reject) &#123; resolve(1);&#125;).then(console.log);console.log(2);// 2// 1 上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。 但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。 123456789101112setTimeout(function() &#123; console.log(1);&#125;, 0);new Promise(function (resolve, reject) &#123; resolve(2);&#125;).then(console.log);console.log(3);// 3// 2// 1 上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。 严格模式除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。 同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。 设计目的早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。 严格模式是从 ES5 进入标准的，主要目的有以下几个。 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。提高编译器效率，增加运行速度。为未来新版本的 JavaScript 语法做好铺垫。 总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。 启用方法进入严格模式的标志，是一行字符串use strict。 1&apos;use strict&apos;; 老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。 严格模式可以用于整个脚本，也可以只用于单个函数。 用于整个脚本文件use strict放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。) 12345678&lt;script&gt; &apos;use strict&apos;; console.log(&apos;这是严格模式&apos;);&lt;/script&gt;&lt;script&gt; console.log(&apos;这是正常模式&apos;);&lt;/script&gt; 上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个&lt;script&gt;标签是严格模式，后一个不是。 如果use strict写成下面这样，则不起作用，严格模式必须从代码一开始就生效。 1234&lt;script&gt; console.log(&apos;这是正常模式&apos;); &apos;use strict&apos;;&lt;/script&gt; 但如果use strict跟在一个空的分号或者注释后面，就是严格模式。12345678910&lt;script&gt; ;&apos;use strict&apos;; console.log(&apos;这是严格模式&apos;);&lt;/script&gt;&lt;script&gt; //前面是注释这里也是严格模式 &apos;use strict&apos;; console.log(&apos;这是严格模式&apos;);&lt;/script&gt; 用于单个函数use strict放在函数体的第一行，则整个函数以严格模式运行。 12345678910111213141516function strict() &#123; &apos;use strict&apos;; return &apos;这是严格模式&apos;;&#125;function strict2() &#123; &apos;use strict&apos;; function f() &#123; return &apos;这也是严格模式&apos;; &#125; return f();&#125;function notStrict() &#123; return &apos;这是正常模式&apos;;&#125; 有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。 1234(function () &#123; &apos;use strict&apos;; // some code here&#125;)(); 显式报错严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。 只读属性不可写，不可配置的属性不可删除严格模式下，设置字符串的length属性，会报错。 123&apos;use strict&apos;;&apos;abc&apos;.length = 5;// TypeError: Cannot assign to read only property &apos;length&apos; of string &apos;abc&apos; 上面代码报错，因为length是只读属性，严格模式下不可写。正常模式下，改变length属性是无效的，但不会报错。 严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。 1234567891011121314151617// 对只读属性赋值会报错&apos;use strict&apos;;Object.defineProperty(&#123;&#125;, &apos;a&apos;, &#123; value: 37, writable: false&#125;);obj.a = 123;// TypeError: Cannot assign to read only property &apos;a&apos; of object #&lt;Object&gt;// 删除不可配置的属性会报错&apos;use strict&apos;;var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, configurable: false&#125;);delete obj.p// TypeError: Cannot delete property &apos;p&apos; of #&lt;Object&gt; 只设置了取值器的属性不可写严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。 123456&apos;use strict&apos;;var obj = &#123; get v() &#123; return 1; &#125;&#125;;obj.v = 2;// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter 上面代码中，obj.v只有取值器，没有存值器，对它进行赋值就会报错。 禁止扩展的对象不可扩展严格模式下，对禁止扩展的对象添加新属性，会报错。 12345&apos;use strict&apos;;var obj = &#123;&#125;;Object.preventExtensions(obj);obj.v = 1;// Uncaught TypeError: Cannot add property v, object is not extensible 上面代码中，obj对象禁止扩展，添加属性就会报错。 eval、arguments 不可用作标识名严格模式下，使用eval或者arguments作为标识名，将会报错。下面的语句都会报错。 12345678910&apos;use strict&apos;;var eval = 17;var arguments = 17;var obj = &#123; set p(arguments) &#123; &#125; &#125;;try &#123; &#125; catch (arguments) &#123; &#125;function x(eval) &#123; &#125;function arguments() &#123; &#125;var y = function eval() &#123; &#125;;var f = new Function(&apos;arguments&apos;, &quot;&apos;use strict&apos;; return 17;&quot;);// SyntaxError: Unexpected eval or arguments in strict mode 函数不能有重名的参数正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 12345function f(a, a, b) &#123; &apos;use strict&apos;; return a + b;&#125;// Uncaught SyntaxError: Duplicate parameter name not allowed in this context 禁止八进制的前缀0表示法正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 123&apos;use strict&apos;;var n = 0100;// Uncaught SyntaxError: Octal literals are not allowed in strict mode. 增强的安全措施严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。 全局变量显式声明正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 123456789101112&apos;use strict&apos;;v = 1; // 报错，v未声明for (i = 0; i &lt; 2; i++) &#123; // 报错，i 未声明 // ...&#125;function f() &#123; x = 123;&#125;f() // 报错，未声明就创建一个全局变量 因此，严格模式下，变量都必须先声明，然后再使用。 禁止 this 关键字指向全局对象正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。 123456789101112// 正常模式function f() &#123; console.log(this === window);&#125;f() // true// 严格模式function f() &#123; &apos;use strict&apos;; console.log(this === undefined);&#125;f() // true 上面代码中，严格模式的函数体内部this是undefined。 这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。 123456function f() &#123; &apos;use strict&apos;; this.a = 1;&#125;;f();// 报错，this 未定义 严格模式下，函数直接调用时（不使用new调用），函数内部的this表示undefined（未定义），因此可以用call、apply和bind方法，将任意值绑定在this上面。 正常模式下，this指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而null和undefined这两个无法转成对象的值，将被忽略。 12345678910111213141516171819202122// 正常模式function fun() &#123; return this;&#125;fun() // windowfun.call(2) // Number &#123;2&#125;fun.call(true) // Boolean &#123;true&#125;fun.call(null) // windowfun.call(undefined) // window// 严格模式&apos;use strict&apos;;function fun() &#123; return this;&#125;fun() //undefinedfun.call(2) // 2fun.call(true) // truefun.call(null) // nullfun.call(undefined) // undefined 上面代码中，可以把任意类型的值，绑定在this上面。 禁止使用 fn.callee、fn.caller函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。 1234567function f1() &#123; &apos;use strict&apos;; f1.caller; // 报错 f1.arguments; // 报错&#125;f1(); 禁止使用 arguments.callee、arguments.callerarguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错。 123456&apos;use strict&apos;;var f = function () &#123; return arguments.callee;&#125;;f(); // 报错 禁止删除变量严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。 1234567891011&apos;use strict&apos;;var x;delete x; // 语法错误var obj = Object.create(null, &#123; x: &#123; value: 1, configurable: true &#125;&#125;);delete obj.x; // 删除成功 静态绑定JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 禁止使用 with 语句严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。 12345678&apos;use strict&apos;;var v = 1;var obj = &#123;&#125;;with (obj) &#123; v = 2;&#125;// Uncaught SyntaxError: Strict mode code may not include a with statement 创设 eval 作用域正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。 123456(function () &#123; &apos;use strict&apos;; var x = 2; console.log(eval(&apos;var x = 5; x&apos;)) // 5 console.log(x) // 2&#125;)() 上面代码中，由于eval语句内部是一个独立作用域，所以内部的变量x不会泄露到外部。 注意，如果希望eval语句也使用严格模式，有两种方式。 123456789101112// 方式一function f1(str)&#123; &apos;use strict&apos;; return eval(str);&#125;f1(&apos;undeclared_variable = 1&apos;); // 报错// 方式二function f2(str)&#123; return eval(str);&#125;f2(&apos;&quot;use strict&quot;;undeclared_variable = 1&apos;) // 报错 上面两种写法，eval内部使用的都是严格模式。 arguments 不再追踪参数的变化变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。 123456789101112function f(a) &#123; a = 2; return [a, arguments[0]];&#125;f(1); // 正常模式为[2, 2]function f(a) &#123; &apos;use strict&apos;; a = 2; return [a, arguments[0]];&#125;f(1); // 严格模式为[2, 1] 上面代码中，改变函数的参数，不会反应到arguments对象上来。 向下一个版本的 JavaScript 过渡JavaScript语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。 非函数代码块不得声明函数ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。 12345678&apos;use strict&apos;;if (true) &#123; function f1() &#123; &#125; // 语法错误&#125;for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123; &#125; // 语法错误&#125; 上面代码在if代码块和for代码块中声明了函数，ES5 环境会报错。 注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。 保留字为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。 1234function package(protected) &#123; // 语法错误 &apos;use strict&apos;; var implements; // 语法错误&#125;]]></content>
      <categories>
        <category>JavaScript标准教程笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript标准参考教程》阅读笔记之《面向对象编程》]]></title>
    <url>%2F2018%2F05%2F18%2F%E3%80%8AJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址 构造函数与 new 命令对象是什么（1）对象是单个实物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 （2）对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 构造函数面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓“构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。 构造函数就是一个普通的函数，但是有自己的特征和用法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。生成对象的时候，必须使用new命令。 new 命令基本用法new命令的作用，就是执行构造函数，返回一个实例对象。 123456var Vehicle = function () &#123; this.price = 1000;&#125;;var v = new Vehicle();v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。 使用new命令时，根据需要，构造函数也可以接受参数。 12345var Vehicle = function (p) &#123; this.price = p;&#125;;var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。 1234// 推荐的写法var v = new Vehicle();// 不推荐的写法var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？ 如果不使用new命令，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，变量v变成了undefined，而price属性变成了全局变量。因此，应该非常小心，避免不使用new命令、直接调用构造函数。 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。 12345678function Fubar(foo, bar)&#123; &apos;use strict&apos;; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property &apos;_foo&apos; of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。因为语句中的this._foo此时就相当于undefined._foo，是违反规则的。 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。 还有一种方法，通过判断new.target属性的值来判断是否使用new命令。具体见下文。12345678function f() &#123; if (!new.target) &#123; throw new Error(&apos;请使用 new 命令调用！&apos;); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。 1234567var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000// false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。 但是，如果return语句返回的是一个跟this无关的新对象，new令会返回这个新对象，而不是this对象。这一点需要特别引起注意。 1234567var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price// 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。 12345678function getMessage() &#123; return &apos;this is a message&apos;;&#125;var msg = new getMessage();msg // &#123;&#125;typeof msg // &quot;object&quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。 new命令简化的内部流程，可以用下面的代码表示。 123456789101112131415function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === &apos;object&apos; &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, &apos;张三&apos;, 28); new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 123456function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true 使用这个属性，可以判断函数调用的时候，是否使用new命令。 上面代码中，构造函数f调用时，没有使用new命令，就抛出一个错误。 Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 123456789101112var person1 = &#123; name: &apos;张三&apos;, age: 38, greeting: function() &#123; console.log(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I&apos;m 张三. 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 Object.create()的详细介绍，请看下文的相关章节。 this 关键字涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 前一章已经提到，this可以用在构造函数之中，表示实例对象。除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。 简单说，this就是属性或方法“当前”所在的对象。 1this.property 上面代码中，this就代表property属性当前所在的对象。 下面是一个实际的例子。123456789var person = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;person.describe()// &quot;姓名：张三&quot; 上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。 1234567891011121314var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;B.describe = A.describe;B.describe()// &quot;姓名：李四&quot; 上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。 稍稍重构这个例子，this的动态指向就能看得更清楚。 12345678910111213141516function f() &#123; return &apos;姓名：&apos;+ this.name;&#125;var A = &#123; name: &apos;张三&apos;, describe: f&#125;;var B = &#123; name: &apos;李四&apos;, describe: f&#125;;A.describe() // &quot;姓名：张三&quot;B.describe() // &quot;姓名：李四&quot; 上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。 12345678910var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var name = &apos;李四&apos;;var f = A.describe;f() // &quot;姓名：李四&quot; 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 再看一个网页编程的例子。 12345678&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;&lt;script&gt;function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log(&apos;Invalid Value!&apos;);&#125;&lt;/script&gt; 上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此this就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。 总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 使用场合this主要有以下几个使用场合。 ### 全局环境 全局环境使用this，它指的就是顶层对象window。 123456this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 构造函数构造函数中的this，指的是实例对象。 123var Obj = function (p) &#123; this.p = p;&#125;; 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。 12var o = new Obj(&apos;Hello World!&apos;);o.p // &quot;Hello World!&quot; 对象的方法如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 但是，这条规则很不容易把握。请看下面的代码。 1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，下面这几种用法，都会改变this的指向。123456// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。上面三种情况等同于下面的代码。 123456789101112131415161718// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 等同于(function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。 12345678910var a = &#123; p: &apos;Hello&apos;, b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。 123456789101112var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: &apos;Hello&apos;, b: b&#125;;(a.b).m() // 等同于 b.m() 如果要达到预期效果，只有写成下面这样。12345678var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;; 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。 1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。 12var hello = a.b;hello.m() // Hello 使用注意点避免多层 this由于this的指向是不确定的，所以切勿在函数中包含多层的this。 123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。 12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。 12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。 12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; &apos;use strict&apos;; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，inc方法通过&#39;use strict&#39;声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 避免数组处理方法中的 this数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，就是前面提到的，使用中间变量固定this。 1234567891011121314var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+&apos; &apos;+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。 12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 避免回调函数中的 this回调函数中的this往往会改变指向，最好避免使用。 1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, o.f); 上面代码中，点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的 DOM 对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 绑定 this 的方法this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。 Function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。 123456789101112var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法将this关键字指向obj对象，返回结果为456。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。 123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。 1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。 12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。 call方法的一个应用是调用对象的原生方法。 12345678910var obj = &#123;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // trueObject.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。也就是指定Object.prototype.hasOwnProperty方法在obj对象上执行。 Function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。 1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 123456function f(x, y)&#123; console.log(x + y);&#125;f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 2 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。 利用这一点，可以做一些有趣的应用。 找出数组最大元素JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 12var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15 将数组的空元素变为undefined通过apply方法，利用Array构造函数将数组的空元素变成undefined。 12Array.apply(null, [&apos;a&apos;, ,&apos;b&apos;])// [ &apos;a&apos;, undefined, &apos;b&apos; ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。 1234567891011121314var a = [&apos;a&apos;, , &apos;b&apos;];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b 转换类似数组的对象另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。 1234Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) // [1]Array.prototype.slice.apply(&#123;0: 1&#125;) // []Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined]Array.prototype.slice.apply(&#123;length: 1&#125;) // [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 绑定回调函数的对象前面的按钮点击事件的例子，可以改写如下。 12345678910111213var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;// jQuery 的写法$(&apos;#button&apos;).on(&apos;click&apos;, f); 上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。 Function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题。 12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。 12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。 this绑定到其他对象也是可以的。 12345678910111213var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind还可以接受更多的参数，将这些参数绑定原函数的参数。 1234567891011var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5) // 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。 123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 bind方法有一些使用注意点。 每一次返回一个新函数bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。 1element.addEventListener(&apos;click&apos;, o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。 1element.removeEventListener(&apos;click&apos;, o.m.bind(o)); 正确的方法是写成下面这样： 1234var listener = o.m.bind(o);element.addEventListener(&apos;click&apos;, listener);// ...element.removeEventListener(&apos;click&apos;, listener); 结合回调函数使用回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。解决方法就是使用bind方法，将counter.inc绑定counter。 1234567891011121314var counter = &#123; count: 0, inc: function () &#123; &apos;use strict&apos;; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc.bind(counter));counter.count // 1 上面代码中，callIt方法会调用回调函数。这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。 123456789101112var obj = &#123; name: &apos;张三&apos;, times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。 12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 结合call方法使用利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。 123[1, 2, 3].slice(0, 1) // [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1) // [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。 12var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 上面代码的含义就是，将Array.prototype.slice变成Function.prototype.call方法所在的对象，调用时就变成了Array.prototype.slice.call。类似的写法还可以用于其他数组方法。 123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。 1234567function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码的含义就是，将Function.prototype.bind方法绑定在Function.prototype.call上面，所以bind方法就可以直接使用，不需要在函数实例上使用。 prototype 对象大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的继承则是通过“原型对象”（prototype）。 原型对象概述构造函数的缺点JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。 123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);cat1.name // &apos;大毛&apos;cat1.color // &apos;白色&apos; 上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 12345678910111213function Cat(name, color) &#123; this.name = name; this.color = color; this.meow = function () &#123; console.log(&apos;喵喵&apos;); &#125;;&#125;var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);var cat2 = new Cat(&apos;二毛&apos;, &apos;黑色&apos;);cat1.meow === cat2.meow// false 上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。 这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。 prototype 属性的作用JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。 下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。 12function f() &#123;&#125;typeof f.prototype // &quot;object&quot; 上面代码中，函数f默认具有prototype属性，指向一个对象。 对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。 12345678910function Animal(name) &#123; this.name = name;&#125;Animal.prototype.color = &apos;white&apos;;var cat1 = new Animal(&apos;大毛&apos;);var cat2 = new Animal(&apos;二毛&apos;);cat1.color // &apos;white&apos;cat2.color // &apos;white&apos; 上面代码中，构造函数Animal的prototype属性，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都共享了该属性。 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。 1234Animal.prototype.color = &apos;yellow&apos;;cat1.color // &quot;yellow&quot;cat2.color // &quot;yellow&quot; 上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 12345cat1.color = &apos;black&apos;;cat1.color // &apos;black&apos;cat2.color // &apos;yellow&apos;Animal.prototype.color // &apos;yellow&apos;; 上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。 总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。 123Animal.prototype.walk = function () &#123; console.log(this.name + &apos; is walking&apos;);&#125;; 上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。 原型链JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。 12Object.getPrototypeOf(Object.prototype)// null 上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。Object.getPrototypeOf方法返回参数对象的原型，具体介绍请看后文。 读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。 注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 举例来说，如果让构造函数的prototype属性指向一个数组，就意味着实例对象可以调用数组方法。 123456789var MyArray = function () &#123;&#125;;MyArray.prototype = new Array();MyArray.prototype.constructor = MyArray;var mine = new MyArray();mine.push(1, 2, 3);mine.length // 3mine instanceof Array // true 上面代码中，mine是构造函数MyArray的实例对象，由于MyArray.prototype指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。最后那行instanceof表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明mine为Array的实例，instanceof运算符的详细解释详见后文。 上面代码还出现了原型对象的contructor属性，这个属性的含义下一节就来解释。 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 12function P() &#123;&#125;P.prototype.constructor === P // true 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。 123456function P() &#123;&#125;var p = new P();p.constructor === P // truep.constructor === P.prototype.constructor // truep.hasOwnProperty(&apos;constructor&apos;) // false 上面代码中，p是构造函数P的实例对象，但是p自身没有constructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。 constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。 12345function F() &#123;&#125;;var f = new F();f.constructor === F // truef.constructor === RegExp // false 上面代码中，constructor属性确定了实例对象f的构造函数是F，而不是RegExp。 另一方面，有了constructor属性，就可以从一个实例对象新建另一个实例。 12345function Constr() &#123;&#125;var x = new Constr();var y = new x.constructor();y instanceof Constr // true 上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。 123Constr.prototype.createCopy = function () &#123; return new this.constructor();&#125;; 上面代码中，createCopy方法调用构造函数，新建另一个实例。 constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype.constructor === Person // truePerson.prototype = &#123; method: function () &#123;&#125;&#125;;Person.prototype.constructor === Person // falsePerson.prototype.constructor === Object // true 上面代码中，构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的contructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。 所以，修改原型对象时，一般要同时修改constructor属性的指向。 123456789101112131415// 坏的写法C.prototype = &#123; method1: function (...) &#123; ... &#125;, // ...&#125;;// 好的写法C.prototype = &#123; constructor: C, method1: function (...) &#123; ... &#125;, // ...&#125;;// 更好的写法C.prototype.method1 = function (...) &#123; ... &#125;; 上面代码中，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。前两种方法都是向原型对象上添加method1属性，该属性的值为一个function函数，更推荐的写法是直接在原型对象上添加方法。 如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。 123function Foo() &#123;&#125;var f = new Foo();f.constructor.name // &quot;Foo&quot; instanceof 运算符instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 12var v = new Vehicle();v instanceof Vehicle // true 上面代码中，对象v是构造函数Vehicle的实例，所以返回true。 instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。 123v instanceof Vehicle// 等同于Vehicle.prototype.isPrototypeOf(v) 上面代码中，Object.prototype.isPrototypeOf的详细解释见后文。 由于instanceof检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回true。 123var d = new Date();d instanceof Date // trued instanceof Object // true 上面代码中，d同时是Date和Object的实例，因此对这两个构造函数都返回true。 instanceof的原理是检查右边构造函数的prototype属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。 123var obj = Object.create(null);typeof obj // &quot;object&quot;Object.create(null) instanceof Object // false 上面代码中，Object.create(null)返回一个新对象obj，它的原型是null（Object.create的详细介绍见后文）。右边的构造函数Object的prototype属性，不在左边的原型链上，因此instanceof就认为obj不是Object的实例。但是，只要一个对象的原型不是null，instanceof运算符的判断就不会失真。 instanceof运算符的一个用处，是判断值的类型。 1234var x = [1, 2, 3];var y = &#123;&#125;;x instanceof Array // truey instanceof Object // true 上面代码中，instanceof运算符判断，变量x是数组，变量y是对象。 注意，instanceof运算符只能用于对象，不适用原始类型的值。 12var s = &apos;hello&apos;;s instanceof String // false 上面代码中，字符串不是String对象的实例（因为字符串不是对象），所以返回false。 此外，对于undefined和null，instanceOf运算符总是返回false。 12undefined instanceof Object // falsenull instanceof Object // false 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。 12345678function Fubar (foo, bar) &#123; if (this instanceof Fubar) &#123; this._foo = foo; this._bar = bar; &#125; else &#123; return new Fubar(foo, bar); &#125;&#125; 上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。 Object 对象的相关方法Object.getPrototypeOf()Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。 123var F = function () &#123;&#125;;var f = new F();Object.getPrototypeOf(f) === F.prototype // true 上面代码中，实例对象f的原型是F.prototype。 下面是几种特殊对象的原型。 123456789// 空对象的原型是 Object.prototypeObject.getPrototypeOf(&#123;&#125;) === Object.prototype // true// Object.prototype 的原型是 nullObject.getPrototypeOf(Object.prototype) === null // true// 函数的原型是 Function.prototypefunction f() &#123;&#125;Object.getPrototypeOf(f) === Function.prototype // true Object.setPrototypeOf()Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。 123456var a = &#123;&#125;;var b = &#123;x: 1&#125;;Object.setPrototypeOf(a, b);Object.getPrototypeOf(a) === b // truea.x // 1 上面代码中，Object.setPrototypeOf方法将对象a的原型，设置为对象b，因此a可以共享b的属性。 new命令可以使用Object.setPrototypeOf方法模拟。 12345678var F = function () &#123; this.foo = &apos;bar&apos;;&#125;;var f = new F();// 等同于var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);F.call(f); 上面代码中，new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。 Object.create()生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？ JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。 12345678910111213// 原型对象var A = &#123; print: function () &#123; console.log(&apos;hello&apos;); &#125;&#125;;// 实例对象var B = Object.create(A);Object.getPrototypeOf(B) === A // trueB.print() // helloB.print === A.print // true 上面代码中，Object.create方法以A对象为原型，生成了B对象。B继承了A的所有属性和方法。 实际上，Object.create方法可以用下面的代码代替。 1234567if (typeof Object.create !== &apos;function&apos;) &#123; Object.create = function (obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F(); &#125;;&#125; 上面代码表明，Object.create方法的实质是新建一个空的构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。 下面三种方式生成的新对象是等价的。123var obj1 = Object.create(&#123;&#125;);var obj2 = Object.create(Object.prototype);var obj3 = new Object(); 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。 1234var obj = Object.create(null);obj.valueOf()// TypeError: Object [object Object] has no method &apos;valueOf&apos; 上面代码中，对象obj的原型是null，它就不具备一些定义在Object.prototype对象上面的属性，比如valueOf方法。 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。 1234Object.create()// TypeError: Object prototype may only be an Object or nullObject.create(123)// TypeError: Object prototype may only be an Object or null Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。 12345var obj1 = &#123; p: 1 &#125;;var obj2 = Object.create(obj1);obj1.p = 2;obj2.p // 2 上面代码中，修改对象原型obj1会影响到实例对象obj2。 除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。 12345678910111213141516171819var obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: &apos;abc&apos;, enumerable: true, configurable: true, writable: true, &#125;&#125;);// 等同于var obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = &apos;abc&apos;; Object.create方法生成的对象，继承了它的原型对象的构造函数。 123456function A() &#123;&#125;var a = new A();var b = Object.create(a);b.constructor === A // trueb instanceof A // true 上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。 Object.prototype.isPrototypeOf()实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。 123456var o1 = &#123;&#125;;var o2 = Object.create(o1);var o3 = Object.create(o2);o2.isPrototypeOf(o3) // trueo1.isPrototypeOf(o3) // true 上面代码中，o1和o2都是o3的原型。这表明只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。 1234Object.prototype.isPrototypeOf(&#123;&#125;) // trueObject.prototype.isPrototypeOf([]) // trueObject.prototype.isPrototypeOf(/xyz/) // trueObject.prototype.isPrototypeOf(Object.create(null)) // false 上面代码中，由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有直接继承自null的对象除外。 Object.prototype.proto实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。 12345var obj = &#123;&#125;;var p = &#123;&#125;;obj.__proto__ = p;Object.getPrototypeOf(obj) === p // true 上面代码通过__proto__属性，将p对象设为obj对象的原型。 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。 原型链可以用__proto__很直观地表示。 12345678910111213141516171819202122var A = &#123; name: &apos;张三&apos;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;var proto = &#123; print: function () &#123; console.log(this.name); &#125;&#125;;A.__proto__ = proto;B.__proto__ = proto;A.print() // 张三B.print() // 李四A.print === B.print // trueA.print === proto.print // trueB.print === proto.print // true 上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。 获取原型对象方法的比较如前所述，__proto__属性指向当前对象的原型对象，即构造函数的prototype属性。 123456var obj = new Object();obj.__proto__ === Object.prototype// trueobj.__proto__ === obj.constructor.prototype// true 上面代码首先新建了一个对象obj，它的__proto__属性，指向构造函数（Object或obj.constructor）的prototype属性。 因此，获取实例对象obj的原型对象，有三种方法。 obj.__proto__obj.constructor.prototypeObject.getPrototypeOf(obj) 上面三种方法之中，前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。 12345678var P = function () &#123;&#125;;var p = new P();var C = function () &#123;&#125;;C.prototype = p;var c = new C();c.constructor.prototype === p // false 上面代码中，构造函数C的原型对象被改成了p，但是实例对象的c.constructor.prototype却没有指向p。所以，在改变原型对象时，一般要同时设置constructor属性。 12345C.prototype = p;C.prototype.constructor = C;var c = new C();c.constructor.prototype === p // true 因此，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。 Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。 12Object.getOwnPropertyNames(Date)// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;] 上面代码中，Object.getOwnPropertyNames方法返回Date所有自身的属性名。 对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。Object.getOwnPropertyNames方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用Object.keys方法。 1Object.keys(Date) // [] 上面代码表明，Date对象所有自身的属性，都是不可以遍历的。 Object.prototype.hasOwnProperty()对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。 12Date.hasOwnProperty(&apos;length&apos;) // trueDate.hasOwnProperty(&apos;toString&apos;) // false 上面代码表明，Date.length（构造函数Date可以接受多少个参数）是Date自身的属性，Date.toString是继承的属性。 另外，hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。 in 运算符和 for…in 循环in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。 12&apos;length&apos; in Date // true&apos;toString&apos; in Date // true in运算符常用于检查一个属性是否存在。 获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for...in循环。 1234567891011var o1 = &#123; p1: 123 &#125;;var o2 = Object.create(o1, &#123; p2: &#123; value: &quot;abc&quot;, enumerable: true &#125;&#125;);for (p in o2) &#123; console.info(p);&#125;// p2// p1 上面对象中，对象o2的p2属性是自身的，p1性是继承的。这两个属性都会被for...in循环遍历。 为了在for...in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下。 12345for ( var name in object ) &#123; if ( object.hasOwnProperty(name) ) &#123; /* loop code */ &#125;&#125; 获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。 123456789101112function inheritedPropertyNames(obj) &#123; var props = &#123;&#125;; while(obj) &#123; Object.getOwnPropertyNames(obj).forEach(function(p) &#123; props[p] = true; // 这里是将传入的p，也就是obj自身所有属性名，作为props对象的键存入，后边的true只不过是形成一个键值对，传入一个字符串也可以。 &#125;); obj = Object.getPrototypeOf(obj); &#125; return Object.getOwnPropertyNames(props); // 最后取出props对象本身的属性，属性名也就分别是刚才存入的那些属性。&#125; 上面代码依次获取obj对象的每一级原型对象“自身”的属性，从而获取obj对象的“所有”属性，不管是否可遍历。 下面是一个例子，列出Date对象的所有属性。 12345678inheritedPropertyNames(Date)// [// &quot;caller&quot;,// &quot;constructor&quot;,// &quot;toString&quot;,// &quot;UTC&quot;,// ...// ] 对象的拷贝如果要拷贝一个对象，需要做到下面两件事情。 确保拷贝后的对象，与原对象具有同样的原型确保拷贝后的对象，与原对象具有同样的实例属性 下面就是根据上面两点，实现的对象拷贝函数。 123456789101112131415function copyObject(orig) &#123; var copy = Object.create(Object.getPrototypeOf(orig)); copyOwnPropertiesFrom(copy, orig); return copy;&#125;function copyOwnPropertiesFrom(target, source) &#123; Object .getOwnPropertyNames(source) .forEach(function (propKey) &#123; var desc = Object.getOwnPropertyDescriptor(source, propKey); Object.defineProperty(target, propKey, desc); &#125;); return target;&#125; 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。 123456function copyObject(orig) &#123; return Object.create( Object.getPrototypeOf(orig), Object.getOwnPropertyDescriptors(orig) );&#125; 面向对象编程的模式构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。 这可以分成两步实现。 第一步是在子类的构造函数中，调用父类的构造函数。 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。 1234function Sub(value) &#123; Super.call(this); this.prop = value;&#125; 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。 上面代码中的Super.call(this);这一句的作用是，将父类构造函数中的this指向子类构造函数这个环境并且执行父类构造函数，因为构造函数都有this关键字。父类中，比如有一句this.x = 0;，那么在调用了Super.call(this);之后，this的指向就变成了子类，也就是在子类中创建一个x属性并且值为0。其实也就相当于将父类中的带有this的语句照搬到子类中执行。 123Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;Sub.prototype.method = &apos;...&apos;; 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。 另外一种写法是Sub.prototype等于一个父类实例。 1Sub.prototype = new Super(); 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。 举例来说，下面是一个Shape构造函数。 12345678910function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function (x, y) &#123; this.x += x; this.y += y; console.info(&apos;Shape moved.&apos;);&#125;; 我们需要让Rectangle构造函数继承Shape。 12345678910111213// 第一步，子类继承父类的实例function Rectangle() &#123; Shape.call(this); // 调用父类构造函数&#125;// 另一种写法function Rectangle() &#123; this.base = Shape; this.base();&#125;// 第二步，子类继承父类的原型Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle; 采用这样的写法以后，instanceof运算符会对子类和父类的构造函数，都返回true。 12345var rect = new Rectangle();rect.move(1, 1) // &apos;Shape moved.&apos;rect instanceof Rectangle // truerect instanceof Shape // true 上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。 1234ClassB.prototype.print = function() &#123; ClassA.prototype.print.call(this); // some code&#125; 上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。 123456789101112131415161718192021222324function M1() &#123; this.hello = &apos;hello&apos;;&#125;function M2() &#123; this.world = &apos;world&apos;;&#125;function S() &#123; M1.call(this); M2.call(this);&#125;// 继承 M1S.prototype = Object.create(M1.prototype);// 继承链上加入 M2Object.assign(S.prototype, M2.prototype);// 指定构造函数S.prototype.constructor = S;var s = new S();s.hello // &apos;hello：&apos;s.world // &apos;world&apos; 上面代码中，子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。 Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。语法：Object.assign(target, ...sources)。 模块随着网站逐渐变成“互联网应用程序”，嵌入网页的JavaScript代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。 JavaScript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，JavaScript不是一种模块化编程语言，ES5不支持“类”（class），更遑论“模块”（module）了。ES6正式支持“类”和“模块”，但还没有成为主流。JavaScript社区做了很多努力，在现有的运行环境中，实现模块的效果。 基本的实现方法模块是实现特定功能的一组属性和方法的封装。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 1234567function m1() &#123; //...&#125;function m2() &#123; //...&#125; 上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。 这种做法的缺点很明显：“污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。 123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。 1module1.m1(); 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。1module1._count = 5; 封装私有变量：构造函数的写法我们可以利用构造函数，封装私有变量。 1234567891011function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(&apos;&apos;); &#125;;&#125; 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。 12345678910111213function StringBuilder() &#123; this._buffer = [];&#125;StringBuilder.prototype = &#123; constructor: StringBuilder, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(&apos;&apos;); &#125;&#125;; 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。 封装私有变量：立即执行函数的写法使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。 12345678910111213var module1 = (function () &#123; var _count = 0; var m1 = function () &#123; //... &#125;; var m2 = function () &#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 使用上面的写法，外部代码无法读取内部的_count变量。 1console.info(module1._count); //undefined 上面的module1就是JavaScript模块的基本写法。下面，再对这种写法进行加工。 模块的放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。 123456var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用“宽放大模式”（Loose augmentation）。 1234var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 与“放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。 输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 123var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。 123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCouraselDie &#125;&#125;)( jQuery, window, document ); 上面代码中，finalCarousel对象输出到全局，对外暴露init和destroy接口，内部方法go、handleEvents、initialize、dieCarouselDie都是外部无法调用的。 window.finalCarousel其实就是声明了一个全局变量，也就可以对外暴露接口。 声明全局变量有三种方法： 使用var（关键字）+变量名(标识符)的方式在function外部声明，即为全局变量，否则在function声明的是局部变量。 没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。 使用window全局对象来声明，全局对象的属性对应也是全局变量。用法：window.test，此时test为一个全局变量。]]></content>
      <categories>
        <category>JavaScript标准教程笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript标准参考教程》阅读笔记之《标准库》]]></title>
    <url>%2F2018%2F05%2F10%2F%E3%80%8AJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址 Object对象概述JavaScript原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。 JavaScript的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Object对象本身的方法所谓“本身的方法”就是直接定义在Object对象的方法。 1Object.print = function (o) &#123; console.log(o) &#125;; 上面代码中，print方法就是直接定义在Object对象上。 Object的实例方法所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。 123456Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // Object 上面代码中，Object.prototype定义了一个print方法，然后生成一个Object的实例obj。obj直接继承了Object.prototype的属性和方法，可以直接使用obj.print调用print方法。也就是说，obj对象的print方法实质上就是调用Object.prototype.print方法。 关于原型对象object.prototype的详细解释，参见《面向对象编程》章节。这里只要知道，凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享就可以了。 以下先介绍Object作为函数的用法，然后再介绍Object对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分。 Object()Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。 如果参数为空（或者为undefined和null），Object()返回一个空对象。 123456var obj = Object();// 等同于var obj = Object(undefined);var obj = Object(null);obj instanceof Object // true 上面代码的含义，是将undefined和null转为对象，结果得到了一个空对象obj。 instanceof运算符用来验证，一个对象是否为指定的构造函数的实例。obj instanceof Object返回true，就表示obj对象是Object的实例。 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例（参见《原始类型的包装对象》一章）。 1234567891011var obj = Object(1);obj instanceof Object // trueobj instanceof Number // truevar obj = Object(&apos;foo&apos;);obj instanceof Object // trueobj instanceof String // truevar obj = Object(true);obj instanceof Object // trueobj instanceof Boolean // true 上面代码中，Object函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。 1234567891011var arr = [];var obj = Object(arr); // 返回原数组obj === arr // truevar value = &#123;&#125;;var obj = Object(value) // 返回原对象obj === value // truevar fn = function () &#123;&#125;;var obj = Object(fn); // 返回原函数obj === fn // true 上面的代码中使用严格相等运算符对对象进行判断，我们知道严格相等运算符比较两个原始类型时比较的是它们的值，而比较两个对象时比较的是它们的引用地址，因此上面的代码中返回了true就可以说明，如果Object方法的参数是一个对象，则它总是返回原对象。 利用这一点，可以写一个判断变量是否为对象的函数。 123456function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false Object 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 Object构造函数的首要用途，是直接通过它来生成新对象。 注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。 Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。 123456var o1 = &#123;a: 1&#125;;var o2 = new Object(o1);o1 === o2 // truevar obj = new Object(123);obj instanceof Number // true 虽然用法相似，但是Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。 Object 的静态方法所谓“静态方法”，是指部署在Object对象自身的方法。 Object.keys()，Object.getOwnPropertyNames()Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。 Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。 123456var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;] Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 123456var obj = &#123; p1: 123, p2: 456&#125;;Object.getOwnPropertyNames(obj) // [&quot;p1&quot;, &quot;p2&quot;] 对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames方法还返回不可枚举的属性名。 1234var a = [&apos;Hello&apos;, &apos;World&apos;];Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;] 上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。 由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。 1234567var obj = &#123; p1: 123, p2: 456&#125;;Object.keys(obj).length // 2Object.getOwnPropertyNames(obj).length // 2 一般情况下，几乎总是使用Object.keys方法，遍历数组的属性。 其他方法除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。 对象属性模型的相关方法 Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。Object.defineProperty()：通过描述对象，定义某个属性。Object.defineProperties()：通过描述对象，定义多个属性。 控制对象状态的方法 Object.preventExtensions()：防止对象扩展。Object.isExtensible()：判断对象是否可扩展。Object.seal()：禁止对象配置。Object.isSealed()：判断一个对象是否可配置。Object.freeze()：冻结一个对象。Object.isFrozen()：判断一个对象是否被冻结。 原型链相关方法 Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object实例对象的方法，主要有以下六个。 Object.prototype.valueOf()：返回当前对象对应的值。Object.prototype.toString()：返回当前对象对应的字符串形式。Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 本节介绍前四个方法，另外两个方法将在后文相关章节介绍。 Object.prototype.valueOf()valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。 12var obj = new Object();obj.valueOf() === obj // true 上面代码比较obj.valueOf()与obj本身，两者是一样的。 valueOf方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法（详见《数据类型转换》一章）。 12var obj = new Object();1 + obj // &quot;1[object Object]&quot; 上面代码将对象obj与数字1相加，这时 JavaScript 就会默认调用valueOf()方法，求出obj的值再与1相加。所以，如果自定义valueOf方法，就可以得到想要的结果。 123456var obj = new Object();obj.valueOf = function () &#123; return 2;&#125;;1 + obj // 3 上面代码自定义了obj对象的valueOf方法，于是1 + obj就得到了3。这种方法就相当于用自定义的obj.valueOf，覆盖Object.prototype.valueOf。 Object.prototype.toString()toString方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。 12345var o1 = new Object();o1.toString() // &quot;[object Object]&quot;var o2 = &#123;a:1&#125;;o2.toString() // &quot;[object Object]&quot; 上面代码表示，对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型。 字符串[object Object]本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。 1234567var obj = new Object();obj.toString = function () &#123; return &apos;hello&apos;;&#125;;obj + &apos; &apos; + &apos;world&apos; // &quot;hello world&quot; 上面代码表示，当对象用于字符串加法时，会自动调用toString方法。由于自定义了toString方法，所以返回字符串hello world。 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。 12345678910111213[1, 2, 3].toString() // &quot;1,2,3&quot;&apos;123&apos;.toString() // &quot;123&quot;(function () &#123; return 123;&#125;).toString()// &quot;function () &#123;// return 123;// &#125;&quot;(new Date()).toString()// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot; 上面代码中，数组、字符串、函数、Date 对象调用toString方法，并不会返回[object Object]，因为它们都自定义了toString方法，覆盖原始方法。 toString() 的应用：判断数据类型Object.prototype.toString方法返回对象的类型字符串，因此可以用来判断一个值的类型。 12var obj = &#123;&#125;;obj.toString() // &quot;[object Object]&quot; 上面代码调用空对象的toString方法，结果返回一个字符串object Object，其中第二个Object表示该值的构造函数。这是一个十分有用的判断数据类型的方法。 由于实例对象可能会自定义toString方法，覆盖掉Object.prototype.toString方法，所以为了得到类型字符串，最好直接使用Object.prototype.toString方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。 1Object.prototype.toString.call(value) 上面代码表示对value这个值调用Object.prototype.toString方法。 不同数据类型的Object.prototype.toString方法返回值如下。 123456789101112数值：返回[object Number]。字符串：返回[object String]。布尔值：返回[object Boolean]。undefined：返回[object Undefined]。null：返回[object Null]。数组：返回[object Array]。arguments 对象：返回[object Arguments]。函数：返回[object Function]。Error 对象：返回[object Error]。Date 对象：返回[object Date]。RegExp 对象：返回[object RegExp]。其他对象：返回[object Object]。 这就是说，Object.prototype.toString可以看出一个值到底是什么类型。 12345678Object.prototype.toString.call(2) // &quot;[object Number]&quot;Object.prototype.toString.call(&apos;&apos;) // &quot;[object String]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(Math) // &quot;[object Math]&quot;Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([]) // &quot;[object Array]&quot; 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。 123456789101112var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;type(&#123;&#125;); // &quot;object&quot;type([]); // &quot;array&quot;type(5); // &quot;number&quot;type(null); // &quot;null&quot;type(); // &quot;undefined&quot;type(/abcd/); // &quot;regex&quot;type(new Date()); // &quot;date&quot; 在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。 1234567891011121314151617181920212223var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;[&apos;Null&apos;, &apos;Undefined&apos;, &apos;Object&apos;, &apos;Array&apos;, &apos;String&apos;, &apos;Number&apos;, &apos;Boolean&apos;, &apos;Function&apos;, &apos;RegExp&apos;].forEach(function (t) &#123; type[&apos;is&apos; + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isObject(&#123;&#125;) // truetype.isNumber(NaN) // truetype.isRegExp(/abc/) // true Object.prototype.toLocaleString()Object.prototype.toLocaleString方法与toString的返回结果相同，也是返回一个值的字符串形式。 123var obj = &#123;&#125;;obj.toString(obj) // &quot;[object Object]&quot;obj.toLocaleString(obj) // &quot;[object Object]&quot; 这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。 Array.prototype.toLocaleString()Number.prototype.toLocaleString()Date.prototype.toLocaleString() 举例来说，日期的实例对象的toString和toLocaleString返回值就不一样，而且toLocaleString的返回值跟用户设定的所在地域相关。 123var date = new Date();date.toString() // &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;date.toLocaleString() // &quot;1/01/2018, 12:01:33 PM&quot; Object.prototype.hasOwnProperty()Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。 123456var obj = &#123; p: 123&#125;;obj.hasOwnProperty(&apos;p&apos;) // trueobj.hasOwnProperty(&apos;toString&apos;) // false 上面代码中，对象obj自身具有p属性，所以返回true。toString属性是继承的，所以返回false。 Array 对象构造函数Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。 123var arr = new Array(2);arr.length // 2arr // [ empty x 2 ] // 这里是empty代表是空位，虽然浏览器控制台输出为undefined，但它与undefined是不同的 上面代码中，Array构造函数的参数2，表示生成一个两个成员的数组，每个位置都是空值。 如果没有使用new，运行结果也是一样的。 123var arr = new Array(2);// 等同于var arr = Array(2); Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。 12345678910111213141516171819// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(1) // [ empty ]new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，// 则该参数是返回的新数组的成员new Array(&apos;abc&apos;) // [&apos;abc&apos;]new Array([1]) // [Array[1]]，创建了一个包含了一个元素的数组，该元素是个数组包含了一个元素1// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 可以看到，Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。 12345// badvar arr = new Array(1, 2);// goodvar arr = [1, 2]; 注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。 1234567891011var a = new Array(3);var b = [undefined, undefined, undefined];a.length // 3b.length // 3a[0] // undefinedb[0] // undefined0 in a // false0 in b // true 上面代码中，a是一个长度为3的空数组，b是一个三个成员都是undefined的数组。读取键值的时候，a和b都返回undefined，但是a的键位都是空的，b的键位是有值的。 静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 1234var arr = [1, 2, 3];typeof arr // &quot;object&quot;Array.isArray(arr) // true 上面代码中，typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。 实例方法valueOf()，toString()valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 12var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3] toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 12345var arr = [1, 2, 3];arr.toString() // &quot;1,2,3&quot;var arr = [1, 2, 3, [4, 5, 6]];arr.toString() // &quot;1,2,3,4,5,6&quot; push()，pop()push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123456var arr = [];arr.push(1) // 1arr.push(&apos;a&apos;) // 2arr.push(true, &#123;&#125;) // 4arr // [1, &apos;a&apos;, true, &#123;&#125;] 上面代码使用push方法，往数组中添加了四个成员。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.pop() // &apos;c&apos;arr // [&apos;a&apos;, &apos;b&apos;] 对空数组使用pop方法，不会报错，而是返回undefined。 1[].pop() // undefined push和pop结合使用，就构成了“后进先出”的栈结构（stack）。 12345var arr = [];arr.push(1, 2);arr.push(3);arr.pop();arr // [1, 2] 上面代码中，3是最后进入数组的，但是最早离开数组。 shift()，unshift()shift方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 1234var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.shift() // &apos;a&apos;a // [&apos;b&apos;, &apos;c&apos;] shift方法可以遍历并清空一个数组。 12345678var list = [1, 2, 3, 4, 5, 6];var item;while (item = list.shift()) &#123; // 当list中没有元素的时候，使用list.shift()返回undefined console.log(item);&#125;list // [] push和shift结合使用，就构成了“先进先出”的队列结构（queue）。 12345var arr = [];arr.push(1, 2);arr.push(3);arr.shift();arr // [2, 3] 上面代码中，3是最后进入数组的，也是最后离开数组；1是最先进入数组的，也最先离开数组。 unshift方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 1234var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.unshift(&apos;x&apos;); // 4a // [&apos;x&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。 123var arr = [ &apos;c&apos;, &apos;d&apos; ];arr.unshift(&apos;a&apos;, &apos;b&apos;) // 4arr // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ] join()join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 12345var a = [1, 2, 3, 4];a.join(&apos; &apos;) // &apos;1 2 3 4&apos;a.join(&apos; | &apos;) // &quot;1 | 2 | 3 | 4&quot;a.join() // &quot;1,2,3,4&quot; 如果数组成员是undefined或null或空位，会被转成空字符串。 12345[undefined, null].join(&apos;#&apos;)// &apos;#&apos;[&apos;a&apos;,, &apos;b&apos;].join(&apos;-&apos;)// &apos;a--b&apos; 通过call方法，这个方法也可以用于字符串或类似数组的对象。 123456Array.prototype.join.call(&apos;hello&apos;, &apos;-&apos;)// &quot;h-e-l-l-o&quot;var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;;Array.prototype.join.call(obj, &apos;-&apos;)// &apos;a-b&apos; concat()concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 1234567891011[&apos;hello&apos;].concat([&apos;world&apos;])// [&quot;hello&quot;, &quot;world&quot;][&apos;hello&apos;].concat([&apos;world&apos;], [&apos;!&apos;])// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。 12[1, 2, 3].concat(4, 5, 6)// [1, 2, 3, 4, 5, 6] 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 1234567var obj = &#123; a: 1 &#125;;var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 上面代码中，原数组包含一个对象，concat方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。 reverse()reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 1234var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;] slice()slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 1arr.slice(start, end); 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。 1234567var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]a.slice(1) // [&quot;b&quot;, &quot;c&quot;]a.slice(1, 2) // [&quot;b&quot;]a.slice(2, 6) // [&quot;c&quot;]a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。 如果slice方法的参数是负数，则表示倒数计算的位置。 12345var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]a.slice(-2, -1) // [&quot;b&quot;]a.slice(-3, -1) // [&quot;a&quot;, &quot;b&quot;]a.slice(-1) // [&quot;c&quot;] 上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 123var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.slice(4) // []a.slice(2, 1) // [] slice方法的一个重要应用，是将类似数组的对象转为真正的数组。 12345Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)// [&apos;a&apos;, &apos;b&apos;]Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));Array.prototype.slice.call(arguments); 上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。 splice()splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 1arr.splice(start, count, addElement1, addElement2, ...); splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 123var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 上面代码从原数组4号位置，删除了两个数组成员。 123var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2] 上面代码除了删除成员，还插入了两个新成员。 起始位置如果是负数，就表示从倒数位置开始删除。 12345678var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]// 或a.splice(-4, 6) // [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]// 或a.splice(-4, 4) // [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 上面代码表示，从倒数第四个位置c开始删除两个成员。 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。 1234var a = [1, 1, 1];a.splice(1, 0, 2) // []a // [1, 2, 1, 1] 上面代码表示在数组a下标为1的位置插入一个新元素2。 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 123var a = [1, 2, 3, 4];a.splice(2) // [3, 4]a // [1, 2] 上面的代码表示从数组a下标为2的地方开始连带它之后的元素为一个数组，a中只剩余它之前的元素。 sort()sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 1234567891011[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;].sort()// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111] 上面代码的最后两个例子，需要特殊注意。sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 123456789101112[ &#123; name: &quot;张三&quot;, age: 30 &#125;, &#123; name: &quot;李四&quot;, age: 24 &#125;, &#123; name: &quot;王五&quot;, age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: &quot;李四&quot;, age: 24 &#125;,// &#123; name: &quot;王五&quot;, age: 28 &#125;,// &#123; name: &quot;张三&quot;, age: 30 &#125;// ] map()map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 123456789var numbers = [1, 2, 3];numbers.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]numbers// [1, 2, 3] 上面代码中，numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。 map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。 1234[1, 2, 3].map(function(elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] 上面代码中，map方法的回调函数有三个参数，elem为当前成员的值，index为当前成员的位置，arr为原数组（[1, 2, 3]）。 map方法还可以接受第二个参数，用来绑定回调函数内部的this变量（详见《this 变量》一章）。 123456var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// [&apos;b&apos;, &apos;c&apos;] 上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 12345var f = function (n) &#123; return &apos;a&apos; &#125;;[1, undefined, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;][1, null, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;][1, , 2].map(f) // [&quot;a&quot;, , &quot;a&quot;] 上面代码中，map方法不会跳过undefined和null，但是会跳过空位。 forEach()forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。 forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。 12345678function log(element, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9 上面代码中，forEach遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用map方法。 forEach方法也可以接受第二个参数，绑定参数函数的this变量。 1234567var out = [];[1, 2, 3].forEach(function(elem) &#123; this.push(elem * elem);&#125;, out);out // [1, 4, 9] 上面代码中，空数组out是forEach方法的第二个参数，结果，回调函数内部的this关键字就指向out。 注意，forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 1234567var arr = [1, 2, 3];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === 2) break; console.log(arr[i]);&#125;// 1 上面代码中，执行到数组的第二个成员时，就会中断执行。forEach方法做不到这一点。 forEach方法也会跳过数组的空位。 1234567891011121314151617var log = function (n) &#123; console.log(n + 1);&#125;;[1, undefined, 2].forEach(log)// 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3 上面代码中，forEach方法不会跳过undefined和null，但会跳过空位。 filter()filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] 上面代码将大于3的数组成员，作为一个新数组返回。 1234var arr = [0, 1, &apos;a&apos;, false];arr.filter(Boolean)// [1, &quot;a&quot;] 上面代码中，filter方法返回数组arr里面所有布尔值为true的成员。 filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。 1234[1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123; return index % 2 === 0;&#125;);// [1, 3, 5] 上面代码返回索引值为偶数，也就是奇数位置的成员组成的新数组。 filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 1234567var obj = &#123; MAX: 3 &#125;;var myFilter = function (item) &#123; if (item &gt; this.MAX) return true;&#125;;var arr = [2, 8, 3, 4, 1, 3, 2, 9];arr.filter(myFilter, obj) // [8, 4, 9] 上面代码中，过滤器myFilter内部有this变量，它可以被filter方法的第二个参数obj绑定，返回大于3的成员。 some()，every()这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。 它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 12345var arr = [1, 2, 3, 4, 5];arr.some(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// true 上面代码中，如果数组arr有一个成员大于等于3，some方法就返回true。 every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 12345var arr = [1, 2, 3, 4, 5];arr.every(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// false 上面代码中，数组arr并非所有成员大于等于3，所以返回false。 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 1234function isEven(x) &#123; alert(&quot;test!&quot;); return x % 2 === 0 &#125;[].some(isEven) // false[].every(isEven) // true 上面的代码中，那句alert不会执行，因此可以得知无论返回true还是false回调函数都不会执行。 some和every方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 reduce()，reduceRight()reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 123456789[1, 2, 3, 4, 5].reduce(function (a, b) &#123; console.log(a, b); return a + b;&#125;)// 1 2// 3 3// 6 4// 10 5//最后结果：15 上面代码中，reduce方法求出数组所有成员的和。第一次执行，a是数组的第一个成员1，b是数组的第二个成员2。第二次执行，a为上一轮的返回值3，b为第三个成员3。第三次执行，a为上一轮的返回值6，b为第四个成员4。第四次执行，a为上一轮返回值10，b为第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。 reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。 累积变量，默认为数组的第一个成员当前变量，默认为数组的第二个成员当前位置（从0开始）原数组 这四个参数之中，只有前两个是必须的，后两个则是可选的。 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。 1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10);// 25 上面代码指定参数a的初值为10，所以数组从10开始累加，最终结果为25。注意，这时b是从数组的第一个成员开始遍历。 上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。 12345678function add(prev, cur) &#123; return prev + cur;&#125;[].reduce(add)// TypeError: Reduce of empty array with no initial value[].reduce(add, 1)// 1 上面代码中，由于空数组取不到初始值，reduce方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。 下面是一个reduceRight方法的例子。 123456function substract(prev, cur) &#123; return prev - cur;&#125;[3, 2, 1].reduce(substract) // 0[3, 2, 1].reduceRight(substract) // -4 上面代码中，reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。 1234567function findLongest(entries) &#123; return entries.reduce(function (longest, entry) &#123; return entry.length &gt; longest.length ? entry : longest; &#125;, &apos;&apos;);&#125;findLongest([&apos;aaa&apos;, &apos;bb&apos;, &apos;c&apos;]) // &quot;aaa&quot; 上面代码中，reduce的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。 indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 1234var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.indexOf(&apos;b&apos;) // 1a.indexOf(&apos;y&apos;) // -1 indexOf方法还可以接受第二个参数，表示搜索的开始位置。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].indexOf(&apos;a&apos;, 1) // -1 上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 123var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。 12[NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1 这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。 链式使用上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。 1234567891011121314var users = [ &#123;name: &apos;tom&apos;, email: &apos;tom@example.com&apos;&#125;, &#123;name: &apos;peter&apos;, email: &apos;peter@example.com&apos;&#125;];users.map(function (user) &#123; return user.email;&#125;).filter(function (email) &#123; return /^t/.test(email);&#125;).forEach(console.log);// &quot;tom@example.com&quot; 上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以t开头的 Email 地址。 包装对象定义对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。 123var v1 = new Number(123);var v2 = new String(&apos;abc&apos;);var v3 = new Boolean(true); 上面代码中，基于原始类型的值，生成了三个对应的包装对象。 1234567typeof v1 // &quot;object&quot;typeof v2 // &quot;object&quot;typeof v3 // &quot;object&quot;v1 === 123 // falsev2 === &apos;abc&apos; // falsev3 === true // false 包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。 Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。 123Number(123) // 123String(&apos;abc&apos;) // &quot;abc&quot;Boolean(true) // true 上面这种数据类型的转换，详见《数据类型转换》一节。 总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。 实例方法包装对象的实例可以使用Object对象提供的原生方法，主要是valueOf方法和toString方法。 valueOf()valueOf方法返回包装对象实例对应的原始类型的值。 123new Number(123).valueOf() // 123new String(&apos;abc&apos;).valueOf() // &quot;abc&quot;new Boolean(true).valueOf() // true toString()toString方法返回对应的字符串形式。 123new Number(123).toString() // &quot;123&quot;new String(&apos;abc&apos;).toString() // &quot;abc&quot;new Boolean(true).toString() // &quot;true&quot; 原始类型与实例对象的自动转换原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。 比如，字符串可以调用length属性，返回字符串的长度。 1&apos;abc&apos;.length // 3 上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。 123456789var str = &apos;abc&apos;;str.length // 3// 等同于var strObj = new String(str)// String &#123;// 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;// &#125;strObj.length // 3 上面代码中，字符串abc的包装对象提供了多个属性。 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。 123var s = &apos;Hello World&apos;;s.x = 123;s.x // undefined 上面代码为字符串s添加了一个x属性，结果无效，总是返回undefined。 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义（参见《面向对象编程》章节）。 自定义方法三种包装对象除了提供很多原生的实例方法（详见后文的介绍），还可以在原型上添加自定义方法和属性，供原始类型的值直接调用。 比如，我们可以新增一个double方法，使得字符串和数字翻倍。 12345678910111213String.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;&apos;abc&apos;.double()// abcabcNumber.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;(123).double()// 246 上面代码在123外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。 但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。 1234var s = &apos;abc&apos;;s.p = 123;s.p // undefined 上面代码直接对字符串abc添加属性，结果无效。主要原因是上面说的，这里的包装对象是自动生成的，赋值后自动销毁，所以最后一行实际上调用的是一个新的包装对象。 Boolean 对象概述Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。 1234var b = new Boolean(true);typeof b // &quot;object&quot;b.valueOf() // true 上面代码的变量b是一个Boolean对象的实例，它的类型是对象，值为布尔值true。 注意，false对应的包装对象实例，布尔运算结果也是true。 1234567if (new Boolean(false)) &#123; console.log(&apos;true&apos;);&#125; // trueif (new Boolean(false).valueOf()) &#123; console.log(&apos;true&apos;);&#125; // 无输出 上面代码的第一个例子之所以得到true，是因为false对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值true（因为所有对象对应的布尔值都是true）。而实例的valueOf方法，则返回实例对应的原始值，本例为false。 Boolean 函数的类型转换作用Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。 123456789101112Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(&apos;&apos;) // falseBoolean(NaN) // falseBoolean(1) // trueBoolean(&apos;false&apos;) // trueBoolean([]) // trueBoolean(&#123;&#125;) // trueBoolean(function () &#123;&#125;) // trueBoolean(/foo/) // true 上面代码中几种得到true的情况，都值得认真记住。 顺便提一下，使用双重的否运算符（!）也可以将任意值转为对应的布尔值。 1234567891011!!undefined // false!!null // false!!0 // false!!&apos;&apos; // false!!NaN // false!!1 // true!!&apos;false&apos; // true!![] // true!!&#123;&#125; // true!!function()&#123;&#125; // true!!/foo/ // true 最后，对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心。 123456789101112131415if (Boolean(false)) &#123; console.log(&apos;true&apos;);&#125; // 无输出if (new Boolean(false)) &#123; console.log(&apos;true&apos;);&#125; // trueif (Boolean(null)) &#123; console.log(&apos;true&apos;);&#125; // 无输出if (new Boolean(null)) &#123; console.log(&apos;true&apos;);&#125; // true Number对象概述Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。 作为构造函数时，它用于生成值为数值的对象。 12var n = new Number(1);typeof n // &quot;object&quot; 上面代码中，Number对象作为构造函数使用，返回一个值为1的对象。 作为工具函数时，它可以将任何类型的值转为数值。 1Number(true) // 1 上面代码将布尔值true转为数值1。Number作为工具函数的用法，详见《数据类型转换》一章。 属性Number对象拥有以下一些属性。 Number.POSITIVE_INFINITY：正的无限，指向Infinity。Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。Number.NaN：表示非数值，指向NaN。Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 12345678910111213141516Number.POSITIVE_INFINITY // InfinityNumber.NEGATIVE_INFINITY // -InfinityNumber.NaN // NaNNumber.MAX_VALUE// 1.7976931348623157e+308Number.MAX_VALUE &lt; Infinity// trueNumber.MIN_VALUE// 5e-324Number.MIN_VALUE &gt; 0// trueNumber.MAX_SAFE_INTEGER // 9007199254740991Number.MIN_SAFE_INTEGER // -9007199254740991 实例方法Number对象有4个实例方法，都跟将数值转换成指定格式有关。 Number.prototype.toString()Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。 1(10).toString() // &quot;10&quot; toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 123(10).toString(2) // &quot;1010&quot;(10).toString(8) // &quot;12&quot;(10).toString(16) // &quot;a&quot; 上面代码中，10一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。 1210.toString(2)// SyntaxError: Unexpected token ILLEGAL 只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为10加上括号，还可以在10后面加两个点，JavaScript 会把第一个点理解成小数点（即10.0），把第二个点理解成调用对象属性，从而得到正确结果。 12345610..toString(2)// &quot;1010&quot;// 其他方法还包括10 .toString(2) // &quot;1010&quot;10.0.toString(2) // &quot;1010&quot; 这实际上意味着，可以直接对一个小数使用toString方法。 123410.5.toString() // &quot;10.5&quot;10.5.toString(2) // &quot;1010.1&quot;10.5.toString(8) // &quot;12.4&quot;10.5.toString(16) // &quot;a.8&quot; 通过方括号运算符也可以调用toString方法。110[&apos;toString&apos;](2) // &quot;1010&quot; toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。 Number.prototype.toFixed()toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。 12(10).toFixed(2) // &quot;10.00&quot;10.005.toFixed(2) // &quot;10.01&quot; 上面代码中，10和10.005转成2位小数，其中10必须放在括号里，否则后面的点会被处理成小数点。 toFixed方法的参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。 Number.prototype.toExponential()toExponential方法用于将一个数转为科学计数法形式。 1234567(10).toExponential() // &quot;1e+1&quot;(10).toExponential(1) // &quot;1.0e+1&quot;(10).toExponential(2) // &quot;1.00e+1&quot;(1234).toExponential() // &quot;1.234e+3&quot;(1234).toExponential(1) // &quot;1.2e+3&quot;(1234).toExponential(2) // &quot;1.23e+3&quot; toExponential方法的参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误。 Number.prototype.toPrecision()toPrecision方法用于将一个数转为指定位数的有效数字。 12345(12.34).toPrecision(1) // &quot;1e+1&quot;(12.34).toPrecision(2) // &quot;12&quot;(12.34).toPrecision(3) // &quot;12.3&quot;(12.34).toPrecision(4) // &quot;12.34&quot;(12.34).toPrecision(5) // &quot;12.340&quot; toPrecision方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出RangeError错误。 toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。 1234(12.35).toPrecision(3) // &quot;12.3&quot;(12.25).toPrecision(3) // &quot;12.3&quot;(12.15).toPrecision(3) // &quot;12.2&quot;(12.45).toPrecision(3) // &quot;12.4&quot; 自定义方法与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 12345Number.prototype.add = function (x) &#123; return this + x;&#125;;8[&apos;add&apos;](2) // 10 上面代码为Number对象实例定义了一个add方法。在数值上调用某个方法，数值会自动转为Number的实例对象，所以就可以调用add方法了。由于add方法返回的还是数值，所以可以链式运算。 123456Number.prototype.subtract = function (x) &#123; return this - x;&#125;;(8).add(2).subtract(4)// 6 上面代码在Number对象的实例上部署了subtract方法，它可以与add方法链式调用。 我们还可以部署更复杂的方法。 12345678910Number.prototype.iterate = function () &#123; var result = []; for (var i = 0; i &lt;= this; i++) &#123; result.push(i); &#125; return result;&#125;;(8).iterate()// [0, 1, 2, 3, 4, 5, 6, 7, 8] 上面代码在Number对象的原型上部署了iterate方法，将一个数值自动遍历为一个数组。 注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。 123var n = 1;n.x = 1;n.x // undefined 上面代码中，n是一个原始类型的数值。直接在它上面新增一个属性x，不会报错，但毫无作用，总是返回undefined。这是因为一旦被调用属性，n就自动转为Number的实例对象，调用结束后，该对象自动销毁。所以，下一次调用n的属性时，实际取到的是另一个对象，属性x当然就读不出来。 String对象概述String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。 1234567var s1 = &apos;abc&apos;;var s2 = new String(&apos;abc&apos;);typeof s1 // &quot;string&quot;typeof s2 // &quot;object&quot;s2.valueOf() // &quot;abc&quot; 上面代码中，变量s1是字符串，s2是对象。由于s2是字符串对象，s2.valueOf方法返回的就是它所对应的原始字符串。 字符串对象是一个类似数组的对象（很像数组，但不是数组）。 1234new String(&apos;abc&apos;)// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;(new String(&apos;abc&apos;))[1] // &quot;b&quot; 上面代码中，字符串abc对应的字符串对象，有数值键（0、1、2）和length属性，所以可以像数组那样取值。 除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。 12String(true) // &quot;true&quot;String(5) // &quot;5&quot; 上面代码将布尔值ture和数值5，分别转换为字符串。 静态方法String.fromCharCode()String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 1234String.fromCharCode() // &quot;&quot;String.fromCharCode(97) // &quot;a&quot;String.fromCharCode(104, 101, 108, 108, 111)// &quot;hello&quot; 上面代码中，String.fromCharCode方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。 注意，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。 1234String.fromCharCode(0x20BB7)// &quot;ஷ&quot;String.fromCharCode(0x20BB7) === String.fromCharCode(0x0BB7)// true 上面代码中，String.fromCharCode参数0x20BB7大于0xFFFF，导致返回结果出错。0x20BB7对应的字符是汉字𠮷，但是返回结果却是另一个字符（码点0x0BB7）。这是因为String.fromCharCode发现参数值大于0xFFFF，就会忽略多出的位（即忽略0x20BB7里面的2）。 这种现象的根本原因在于，码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把0x20BB7拆成两个字符表示。 12String.fromCharCode(0xD842, 0xDFB7)// &quot;𠮷&quot; 上面代码中，0x20BB7拆成两个字符0xD842和0xDFB7（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于0xFFFF的字符的四字节表示法，由 UTF-16 编码方法决定。 实例属性String.prototype.length字符串实例的length属性返回字符串的长度。 1&apos;abc&apos;.length // 3 实例方法String.prototype.charAt()charAt方法返回指定位置的字符，参数是从0开始编号的位置。 1234var s = new String(&apos;abc&apos;);s.charAt(1) // &quot;b&quot;s.charAt(s.length - 1) // &quot;c&quot; 这个方法完全可以用数组下标替代。 12&apos;abc&apos;.charAt(1) // &quot;b&quot;&apos;abc&apos;[1] // &quot;b&quot; 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。 12&apos;abc&apos;.charAt(-1) // &quot;&quot;&apos;abc&apos;.charAt(3) // &quot;&quot; String.prototype.charCodeAt()charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。 1&apos;abc&apos;.charCodeAt(1) // 98 上面代码中，abc的1号位置的字符是b，它的 Unicode 码点是98。 如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。 1&apos;abc&apos;.charCodeAt() // 97 如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。 12&apos;abc&apos;.charCodeAt(-1) // NaN&apos;abc&apos;.charCodeAt(4) // NaN 注意，charCodeAt方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536的字符（四个字节的字符），必需连续使用两次charCodeAt，不仅读入charCodeAt(i)，还要读入charCodeAt(i+1)，将两个值放在一起，才能得到准确的字符。 String.prototype.concat()concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。 12345var s1 = &apos;abc&apos;;var s2 = &apos;def&apos;;s1.concat(s2) // &quot;abcdef&quot;s1 // &quot;abc&quot; 该方法可以接受多个参数。 1&apos;a&apos;.concat(&apos;b&apos;, &apos;c&apos;) // &quot;abc&quot; 如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。 123456var one = 1;var two = 2;var three = &apos;3&apos;;&apos;&apos;.concat(one, two, three) // &quot;123&quot;one + two + three // &quot;33&quot; 上面代码中，concat方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串。 String.prototype.slice()slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 1&apos;JavaScript&apos;.slice(0, 4) // &quot;Java&quot; 如果省略第二个参数，则表示子字符串一直到原字符串结束。 1&apos;JavaScript&apos;.slice(4) // &quot;Script&quot; 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 123&apos;JavaScript&apos;.slice(-6) // &quot;Script&quot;&apos;JavaScript&apos;.slice(0, -6) // &quot;Java&quot;&apos;JavaScript&apos;.slice(-2, -1) // &quot;p&quot; 如果第一个参数大于第二个参数，slice方法返回一个空字符串。 1&apos;JavaScript&apos;.slice(2, 1) // &quot;&quot; String.prototype.substring()substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。 1&apos;JavaScript&apos;.substring(0, 4) // &quot;Java&quot; 如果省略第二个参数，则表示子字符串一直到原字符串的结束。 1&apos;JavaScript&apos;.substring(4) // &quot;Script&quot; 如果第二个参数大于第一个参数，substring方法会自动更换两个参数的位置。 123&apos;JavaScript&apos;.substring(10, 4) // &quot;Script&quot;// 等同于&apos;JavaScript&apos;.substring(4, 10) // &quot;Script&quot; 上面代码中，调换substring方法的两个参数，都得到同样的结果。 如果参数是负数，substring方法会自动将负数转为0。 12&apos;Javascript&apos;.substring(-3) // &quot;JavaScript&quot;&apos;JavaScript&apos;.substring(4, -3) // &quot;Java&quot; 上面代码中，第二个例子的参数-3会自动变成0，等同于&#39;JavaScript&#39;.substring(4, 0)。由于第二个参数小于第一个参数，会自动互换位置，所以返回Java。 由于这些规则违反直觉，因此不建议使用substring方法，应该优先使用slice。 String.prototype.substr()substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。 substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。 1&apos;JavaScript&apos;.substr(4, 6) // &quot;Script&quot; 如果省略第二个参数，则表示子字符串一直到原字符串的结束。 1&apos;JavaScript&apos;.substr(4) // &quot;Script&quot; 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 12&apos;JavaScript&apos;.substr(-6) // &quot;Script&quot;&apos;JavaScript&apos;.substr(4, -1) // &quot;&quot; 上面代码中，第二个例子的参数-1自动转为0，表示子字符串长度为0，所以返回空字符串。 String.prototype.indexOf()，String.prototype.lastIndexOf()indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。 12&apos;hello world&apos;.indexOf(&apos;o&apos;) // 4&apos;JavaScript&apos;.indexOf(&apos;script&apos;) // -1 indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。 1&apos;hello world&apos;.indexOf(&apos;o&apos;, 6) // 7 lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。 1&apos;hello world&apos;.lastIndexOf(&apos;o&apos;) // 7 另外，lastIndexOf的第二个参数表示从该位置起向前匹配。 1&apos;hello world&apos;.lastIndexOf(&apos;o&apos;, 6) // 4 String.prototype.trim()trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 12&apos; hello world &apos;.trim()// &quot;hello world&quot; 该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。 1&apos;\r\nabc \t&apos;.trim() // &apos;abc&apos; String.prototype.toLowerCase()，String.prototype.toUpperCase()toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。 12345&apos;Hello World&apos;.toLowerCase()// &quot;hello world&quot;&apos;Hello World&apos;.toUpperCase()// &quot;HELLO WORLD&quot; String.prototype.match()match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 12&apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;) // [&quot;at&quot;]&apos;cat, bat, sat, fat&apos;.match(&apos;xt&apos;) // null 返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。123var matches = &apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;);matches.index // 1matches.input // &quot;cat, bat, sat, fat&quot; 上面的代码中，如果match没有找到匹配，返回了null，则调用.index和.input会抛出TypeError错误。 match方法还可以使用正则表达式作为参数，详见《正则表达式》一章。 String.prototype.search()，String.prototype.replace()search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 1&apos;cat, bat, sat, fat&apos;.search(&apos;at&apos;) // 1 search方法还可以使用正则表达式作为参数，详见《正则表达式》一节。 replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 1&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot; replace方法还可以使用正则表达式作为参数，详见《正则表达式》一节。 String.prototype.split()split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 1&apos;a|b|c&apos;.split(&apos;|&apos;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。 1&apos;a|b|c&apos;.split(&apos;&apos;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;] 如果省略参数，则返回数组的唯一成员就是原字符串。 1&apos;a|b|c&apos;.split() // [&quot;a|b|c&quot;] 注意，分割规则为空字符串和省略参数是不一样的。 如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。 1&apos;a||c&apos;.split(&apos;|&apos;) // [&apos;a&apos;, &apos;&apos;, &apos;c&apos;] 如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。 12&apos;|b|c&apos;.split(&apos;|&apos;) // [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]&apos;a|b|&apos;.split(&apos;|&apos;) // [&quot;a&quot;, &quot;b&quot;, &quot;&quot;] split方法还可以接受第二个参数，限定返回数组的最大成员数。 12345&apos;a|b|c&apos;.split(&apos;|&apos;, 0) // []&apos;a|b|c&apos;.split(&apos;|&apos;, 1) // [&quot;a&quot;]&apos;a|b|c&apos;.split(&apos;|&apos;, 2) // [&quot;a&quot;, &quot;b&quot;]&apos;a|b|c&apos;.split(&apos;|&apos;, 3) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&apos;a|b|c&apos;.split(&apos;|&apos;, 4) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 上面代码中，split方法的第二个参数，决定了返回数组的成员数。 split方法还可以使用正则表达式作为参数，详见《正则表达式》一节。 String.prototype.localeCompare()localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 12&apos;apple&apos;.localeCompare(&apos;banana&apos;) // -1&apos;apple&apos;.localeCompare(&apos;apple&apos;) // 0 该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。 1&apos;B&apos; &gt; &apos;a&apos; // false 上面代码中，字母B小于字母a。因为 JavaScript 采用的是 Unicode 码点比较，B的码点是66，而a的码点是97。 但是，localeCompare方法会考虑自然语言的排序情况，将B排在a的前面。 1&apos;B&apos;.localeCompare(&apos;a&apos;) // 1 上面代码中，localeCompare方法返回整数1，表示B较大。 localeCompare还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。 12&apos;ä&apos;.localeCompare(&apos;z&apos;, &apos;de&apos;) // -1&apos;ä&apos;.localeCompare(&apos;z&apos;, &apos;sv&apos;) // 1 上面代码中，de表示德语，sv表示瑞典语。德语中，ä小于z，所以返回-1；瑞典语中，ä大于z，所以返回1。 Math对象Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 静态属性Math对象的静态属性，提供以下一些数学常数。 Math.E：常数e。Math.LN2：2 的自然对数。Math.LN10：10 的自然对数。Math.LOG2E：以 2 为底的e的对数。Math.LOG10E：以 10 为底的e的对数。Math.PI：常数 Pi。Math.SQRT1_2：0.5 的平方根。Math.SQRT2：2 的平方根。 12345678Math.E // 2.718281828459045Math.LN2 // 0.6931471805599453Math.LN10 // 2.302585092994046Math.LOG2E // 1.4426950408889634Math.LOG10E // 0.4342944819032518Math.PI // 3.141592653589793Math.SQRT1_2 // 0.7071067811865476Math.SQRT2 // 1.4142135623730951 这些属性都是只读的，不能修改。 静态方法Math对象提供以下一些静态方法。 Math.abs()：绝对值Math.ceil()：向上取整，比如2.3会取3Math.floor()：向下取整，比如2.8会取2Math.max()：最大值Math.min()：最小值Math.pow()：指数运算Math.sqrt()：平方根Math.log()：自然对数Math.exp()：e的指数Math.round()：四舍五入Math.random()：随机数 Math.abs()Math.abs方法返回参数值的绝对值。 12Math.abs(1) // 1Math.abs(-1) // 1 Math.max()，Math.min()Math.max方法返回参数之中最大的那个值，Math.min返回最小的那个值。如果参数为空, Math.min返回Infinity, Math.max返回-Infinity。 1234Math.max(2, -1, 5) // 5Math.min(2, -1, 5) // -1Math.min() // InfinityMath.max() // -Infinity Math.floor()，Math.ceil()Math.floor方法返回小于参数值的最大整数（地板值）。 12Math.floor(3.2) // 3Math.floor(-3.2) // -4 Math.ceil方法返回大于参数值的最小整数（天花板值）。 12Math.ceil(3.2) // 4Math.ceil(-3.2) // -3 这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数。 1234567891011function ToInteger(x) &#123; x = Number(x); return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;ToInteger(3.2) // 3ToInteger(3.5) // 3ToInteger(3.8) // 3ToInteger(-3.2) // -3ToInteger(-3.5) // -3ToInteger(-3.8) // -3 上面代码中，不管正数或负数，ToInteger函数总是返回一个数值的整数部分。 Math.round()Math.round方法用于四舍五入。 123456Math.round(0.1) // 0Math.round(0.5) // 1Math.round(0.6) // 1// 等同于Math.floor(x + 0.5) 注意，它对负数的处理（主要是对0.5的处理）。 123Math.round(-1.1) // -1Math.round(-1.5) // -1Math.round(-1.6) // -2 Math.pow()Math.pow方法返回以第一个参数为底数、第二个参数为幂的指数值。 1234// 等同于 2 ** 2Math.pow(2, 2) // 4// 等同于 2 ** 3Math.pow(2, 3) // 8 下面是计算圆面积的方法。 12var radius = 20;var area = Math.PI * Math.pow(radius, 2); Math.sqrt()Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。 12Math.sqrt(4) // 2Math.sqrt(-4) // NaN Math.log()Math.log方法返回以e为底的自然对数值。 12Math.log(Math.E) // 1Math.log(10) // 2.302585092994046 如果要计算以10为底的对数，可以先用Math.log求出自然对数，然后除以Math.LN10；求以2为底的对数，可以除以Math.LN2。 12Math.log(100)/Math.LN10 // 2Math.log(8)/Math.LN2 // 3 Math.exp()Math.exp方法返回常数e的参数次方。 12Math.exp(1) // 2.718281828459045Math.exp(3) // 20.085536923187668 Math.random()Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 1Math.random() // 0.7151307314634323 任意范围的随机数生成函数如下。 123456function getRandomArbitrary(min, max) &#123; return Math.random() * (max - min) + min;&#125;getRandomArbitrary(1.5, 6.5)// 2.4942810038223864 上面的代码中，假设max-min=a，a即为min到max的距离，用a乘以Math.random()会得到0~a范围内的随机数，再加上min将这个范围进行偏移，就得到了min~(a+min)也就是min~max之间的随机数了。 任意范围的随机整数生成函数如下。 12345function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;getRandomInt(1, 6) // 5 返回随机字符的例子如下。 12345678910111213function random_str(length) &#123; var ALPHABET = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;; ALPHABET += &apos;abcdefghijklmnopqrstuvwxyz&apos;; ALPHABET += &apos;0123456789-_&apos;; var str = &apos;&apos;; for (var i=0; i &lt; length; ++i) &#123; var rand = Math.floor(Math.random() * ALPHABET.length); str += ALPHABET.substring(rand, rand + 1); &#125; return str;&#125;random_str(6) // &quot;NdQKOr&quot; 上面代码中，random_str函数接受一个整数作为参数，返回变量ALPHABET内的随机字符所组成的指定长度的字符串。 三角函数方法Math对象还提供一系列三角函数方法。 Math.sin()：返回参数的正弦（参数为弧度值）Math.cos()：返回参数的余弦（参数为弧度值）Math.tan()：返回参数的正切（参数为弧度值）Math.asin()：返回参数的反正弦（返回值为弧度值）Math.acos()：返回参数的反余弦（返回值为弧度值）Math.atan()：返回参数的反正切（返回值为弧度值） 123456789Math.sin(0) // 0Math.cos(0) // 1Math.tan(0) // 0Math.sin(Math.PI / 2) // 1Math.asin(1) // 1.5707963267948966Math.acos(1) // 0Math.atan(1) // 0.7853981633974483 Date对象Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 普通函数的用法Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。 12Date()// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot; 注意，即使带有参数，Date作为普通函数使用时，返回的还是当前时间。 12Date(2000, 1, 1)// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot; 上面代码说明，无论有没有参数，直接调用Date总是返回当前时间。 构造函数的用法Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。 1var today = new Date(); Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。 12345678var today = new Date();today// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;// 等同于today.toString()// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot; 上面代码中，today是Date的实例，直接求值等同于调用toString方法。 作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。 123456789101112// 参数为时间零点开始计算的毫秒数new Date(1378218728000)// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)// 参数为日期字符串new Date(&apos;January 6, 2013&apos;);// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)// 参数为多个整数，// 代表年、月、日、小时、分钟、秒、毫秒new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 关于Date构造函数的参数，有几点说明。 第一点，参数可以是负整数，代表1970年元旦之前的时间。 12new Date(-1378218728000)// Fri Apr 30 1926 17:27:52 GMT+0800 (CST) 第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。 1234567891011new Date(&apos;2013-2-15&apos;)new Date(&apos;2013/2/15&apos;)new Date(&apos;02/15/2013&apos;)new Date(&apos;2013-FEB-15&apos;)new Date(&apos;FEB, 15, 2013&apos;)new Date(&apos;FEB 15, 2013&apos;)new Date(&apos;Feberuary, 15, 2013&apos;)new Date(&apos;Feberuary 15, 2013&apos;)new Date(&apos;15 Feb 2013&apos;)new Date(&apos;15, Feberuary, 2013&apos;)// Fri Feb 15 2013 00:00:00 GMT+0800 (CST) 上面多种日期字符串的写法，返回的都是同一个时间。 第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。 12new Date(2013)// Thu Jan 01 1970 08:00:02 GMT+0800 (CST) 上面代码中，2013被解释为毫秒数，而不是年份。 12345678new Date(2013, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)new Date(2013, 0, 1, 0, 0, 0, 0)// Tue Jan 01 2013 00:00:00 GMT+0800 (CST) 上面代码中，不管有几个参数，返回的都是2013年1月1日零点。 最后，各个参数的取值范围如下。 年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。月：0表示一月，依次类推，11表示12月。日：1到31。小时：0到23。分钟：0到59。秒：0到59毫秒：0到999。 注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。 这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。 1234new Date(2013, 15)// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)new Date(2013, 0, 0)// Mon Dec 31 2012 00:00:00 GMT+0800 (CST) 上面代码的第二个例子，日期设为0，就代表上个月的最后一天。 参数还可以使用负数，表示扣去的时间。 1234new Date(2013, -1)// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)new Date(2013, 0, -1)// Sun Dec 30 2012 00:00:00 GMT+0800 (CST) 上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间。对月使用-1表示扣去一个月，对日使用-1表示扣去一天。 日期的运算类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 1234567var d1 = new Date(2000, 2, 1);var d2 = new Date(2000, 3, 1);d2 - d1// 2678400000d2 + d1// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot; 静态方法Date.now()Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。 1Date.now() // 1364026285194 Date.parse()Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析，请看下面的例子。 123456Date.parse(&apos;Aug 9, 1995&apos;)Date.parse(&apos;January 26, 2011 13:51:50&apos;)Date.parse(&apos;Mon, 25 Dec 1995 13:30:00 GMT&apos;)Date.parse(&apos;Mon, 25 Dec 1995 13:30:00 +0430&apos;)Date.parse(&apos;2011-10-10&apos;)Date.parse(&apos;2011-10-10T14:48:00&apos;) 上面的日期字符串都可以解析。 如果解析失败，返回NaN。 1Date.parse(&apos;xxx&apos;) // NaN Date.UTC()Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。 123456// 格式Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])// 用法Date.UTC(2011, 0, 1, 2, 3, 4, 567)// 1293847384567 该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 to类：从Date对象返回一个字符串，表示指定的时间。get类：获取Date对象的日期和时间。set类：设置Date对象的日期和时间。 Date.prototype.valueOf()valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。 1234var d = new Date();d.valueOf() // 1362790014817d.getTime() // 1362790014817 预期为数值的场合，Date实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。 1234var start = new Date();// ...var end = new Date();var elapsed = end - start; to 类方法Date.prototype.toString()toString方法返回一个完整的日期字符串。 123456var d = new Date(2013, 0, 1);d.toString()// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;d// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot; 因为toString是默认的调用方法，所以如果直接读取Date实例，就相当于调用这个方法。 Date.prototype.toUTCString()toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。 1234var d = new Date(2013, 0, 1);d.toUTCString()// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot; Date.prototype.toISOString()toISOString方法返回对应时间的 ISO8601 写法 1234var d = new Date(2013, 0, 1);d.toISOString()// &quot;2012-12-31T16:00:00.000Z&quot; 注意，toISOString方法返回的总是 UTC 时区的时间。 Date.prototype.toJSON()toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。 1234var d = new Date(2013, 0, 1);d.toJSON()// &quot;2012-12-31T16:00:00.000Z&quot; Date.prototype.toDateString()toDateString方法返回日期字符串（不含小时、分和秒）。 12var d = new Date(2013, 0, 1);d.toDateString() // &quot;Tue Jan 01 2013&quot; Date.prototype.toTimeString()toTimeString方法返回时间字符串（不含年月日）。 12var d = new Date(2013, 0, 1);d.toTimeString() // &quot;00:00:00 GMT+0800 (CST)&quot; Date.prototype.toLocaleDateString()toLocaleDateString方法返回一个字符串，代表日期的当地写法（不含小时、分和秒）。 12345var d = new Date(2013, 0, 1);d.toLocaleDateString()// 中文版浏览器为&quot;2013年1月1日&quot;// 英文版浏览器为&quot;1/1/2013&quot; Date.prototype.toLocaleTimeString()toLocaleTimeString方法返回一个字符串，代表时间的当地写法（不含年月日）。 12345var d = new Date(2013, 0, 1);d.toLocaleTimeString()// 中文版浏览器为&quot;上午12:00:00&quot;// 英文版浏览器为&quot;12:00:00 AM&quot; get 类方法Date对象提供了一系列get*方法，用来获取实例对象某个方面的值。 getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。getDate()：返回实例对象对应每个月的几号（从1开始）。getDay()：返回星期几，星期日为0，星期一为1，以此类推。getYear()：返回距离1900的年数。getFullYear()：返回四位的年份。getMonth()：返回月份（0表示1月，11表示12月）。getHours()：返回小时（0-23）。getMilliseconds()：返回毫秒（0-999）。getMinutes()：返回分钟（0-59）。getSeconds()：返回秒（0-59）。getTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。 所有这些get*方法返回的都是整数，不同方法返回值的范围不一样。 分钟和秒：0 到 59小时：0 到 23星期：0（星期天）到 6（星期六）日期：1 到 31月份：0（一月）到 11（十二月）年份：距离1900年的年数 1234567var d = new Date(&apos;January 6, 2013&apos;);d.getDate() // 6d.getMonth() // 0d.getYear() // 113d.getFullYear() // 2013d.getTimezoneOffset() // -480 上面代码中，最后一行返回-480，即 UTC 时间减去当前时间，单位是分钟。-480表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。 下面是一个例子，计算本年度还剩下多少天。123456function leftDays() &#123; var today = new Date(); var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999); var msPerDay = 24 * 60 * 60 * 1000; return Math.round((endYear.getTime() - today.getTime()) / msPerDay);&#125; 上面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。 getUTCDate()getUTCFullYear()getUTCMonth()getUTCDay()getUTCHours()getUTCMinutes()getUTCSeconds()getUTCMilliseconds() 1234var d = new Date(&apos;January 6, 2013&apos;);d.getDate() // 6d.getUTCDate() // 5 上面代码中，实例对象d表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以getDate方法返回6，对于 UTC 时区来说是1月5日，所以getUTCDate方法返回5。 set 类方法Date对象提供了一系列set*方法，用来设置实例对象的各个方面。 setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。setYear(year): 设置距离1900年的年数。setFullYear(year [, month, date])：设置四位年份。setHours(hour [, min, sec, ms])：设置小时（0-23）。setMilliseconds()：设置毫秒（0-999）。setMinutes(min [, sec, ms])：设置分钟（0-59）。setMonth(month [, date])：设置月份（0-11）。setSeconds(sec [, ms])：设置秒（0-59）。setTime(milliseconds)：设置毫秒时间戳。 这些方法基本是跟get*方法一一对应的，但是没有setDay方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即0是1月，11是12月。 12345var d = new Date (&apos;January 6, 2013&apos;);d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)d.setDate(9) // 1357660800000d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST) set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。 123456789var d1 = new Date(&apos;January 6, 2013&apos;);d1.setDate(32) // 1359648000000d1 // Fri Feb 01 2013 00:00:00 GMT+0800 (CST)var d2 = new Date (&apos;January 6, 2013&apos;);d.setDate(-1) // 1356796800000d // Sun Dec 30 2012 00:00:00 GMT+0800 (CST) set类方法和get类方法，可以结合使用，得到相对时间。 12345678var d = new Date();// 将日期向后推1000天d.setDate(d.getDate() + 1000);// 将时间设为6小时后d.setHours(d.getHours() + 6);// 将年份设为去年d.setFullYear(d.getFullYear() - 1); set*系列方法除了setTime()和setYear()，都有对应的 UTC 版本，即设置 UTC 时区的时间。 setUTCDate()setUTCFullYear()setUTCHours()setUTCMilliseconds()setUTCMinutes()setUTCMonth()setUTCSeconds() 1234var d = new Date(&apos;January 6, 2013&apos;);d.getUTCHours() // 16d.setUTCHours(22) // 1357423200000d // Sun Jan 06 2013 06:00:00 GMT+0800 (CST) 上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。 RegExp对象概述正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp(&apos;xyz&apos;); 上面两种写法是等价的，都新建了一个内容为xyz的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。 RegExp构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。 123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 上面代码中，正则表达式/xyz/有一个修饰符i。 实例属性正则对象的实例属性分成两类。 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。 上面三个属性都是只读的。 12345var r = /abc/igm;r.ignoreCase // truer.global // truer.multiline // true 另一类是与修饰符无关的属性，主要是下面两个。 RegExp.prototype.lastIndex：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符、进行连续搜索时有意义，详细介绍请看后文。RegExp.prototype.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 1234var r = /abc/igm;r.lastIndex // 0r.source // &quot;abc&quot; 实例方法RegExp.prototype.test()正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。 1/cat/.test(&apos;cats and dogs&apos;) // true 上面代码验证参数字符串之中是否包含cat，结果返回true。 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。 1234567891011var r = /x/g;var s = &apos;_x_x&apos;;r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4r.test(s) // false 上面代码的正则表达式使用了g修饰符，表示是全局搜索，会有多个结果。接着，三次使用test方法，每一次开始搜索的位置都是上一次匹配的后一个位置。 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 12345var r = /x/g;var s = &apos;_x_x&apos;;r.lastIndex = 4;r.test(s) // false 上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回false。 lastIndex属性只对同一个正则表达式有效，所以下面这样写是错误的。 12var count = 0;while (/a/g.test(&apos;babaa&apos;)) count++; 上面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。 如果正则模式是一个空字符串，则匹配所有字符串。 12new RegExp(&apos;&apos;).test(&apos;abc&apos;)// true RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。 123456var s = &apos;_x_x&apos;;var r1 = /x/;var r2 = /y/;r1.exec(s) // [&quot;x&quot;]r2.exec(s) // null 上面代码中，正则对象r1匹配成功，返回一个数组，成员是匹配结果；正则对象r2匹配失败，返回null。 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。因为除了和圆括号匹配的值之外，还有一个整体匹配的结果。如果整体不匹配那么直接返回null，并且不会出现括号内不匹配但整体匹配了的情况。 1234var s = &apos;_x_x&apos;;var r = /_(x)/;r.exec(s) // [&quot;_x&quot;, &quot;x&quot;] 上面代码的exec方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。 exec方法的返回数组还包含以下两个属性： input：整个原字符串。index：整个模式匹配成功的开始位置（从0开始计数）。 1234567var r = /a(b+)a/;var arr = r.exec(&apos;_abbba_aba_&apos;);arr // [&quot;abbba&quot;, &quot;bbb&quot;]arr.index // 1arr.input // &quot;_abbba_aba_&quot; 上面代码中的index属性等于1，是因为从原字符串的第二个位置开始匹配成功。 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 123456789101112131415161718192021var reg = /a/g;var str = &apos;abc_abc_abc&apos;var r1 = reg.exec(str);r1 // [&quot;a&quot;]r1.index // 0reg.lastIndex // 1var r2 = reg.exec(str);r2 // [&quot;a&quot;]r2.index // 4reg.lastIndex // 5var r3 = reg.exec(str);r3 // [&quot;a&quot;]r3.index // 8reg.lastIndex // 9var r4 = reg.exec(str);r4 // nullreg.lastIndex // 0 上面代码连续用了四次exec方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回null，正则实例对象的lastIndex属性也重置为0，意味着第四次匹配将从头开始。 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。 1234567891011var reg = /a/g;var str = &apos;abc_abc_abc&apos;while(true) &#123; var match = reg.exec(str); if (!match) break; console.log(&apos;#&apos; + match.index + &apos;:&apos; + match[0]);&#125;// #0:a// #4:a// #8:a 上面代码中，只要exec方法不返回null，就会一直循环下去，每次输出匹配的位置和匹配的文本。 正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。 字符串的实例方法字符串的实例方法之中，有4种与正则表达式有关。 String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 String.prototype.match()字符串实例对象的match方法对字符串进行正则匹配，返回匹配结果。 123456var s = &apos;_x_x&apos;;var r1 = /x/;var r2 = /y/;s.match(r1) // [&quot;x&quot;]s.match(r2) // null 从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。 12345var s = &apos;abba&apos;;var r = /a/g;s.match(r) // [&quot;a&quot;, &quot;a&quot;]r.exec(s) // [&quot;a&quot;] 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。 1234var r = /a|b/g;r.lastIndex = 7;&apos;xaxb&apos;.match(r) // [&apos;a&apos;, &apos;b&apos;]r.lastIndex // 0 上面代码表示，设置正则对象的lastIndex属性是无效的。 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。 12&apos;_x_x&apos;.search(/x/)// 1 上面代码中，第一个匹配结果出现在字符串的1号位置。 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。 1str.replace(search, replacement) 正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值，即g表示全局替换。 123&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot;&apos;aaa&apos;.replace(/a/, &apos;b&apos;) // &quot;baa&quot;&apos;aaa&apos;.replace(/a/g, &apos;b&apos;) // &quot;bbb&quot; 上面代码中，最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了。 replace方法的一个应用，就是消除字符串首尾两端的空格。 1234var str = &apos; #id div.class &apos;;str.replace(/^\s+|\s+$/g, &apos;&apos;)// &quot;#id div.class&quot; replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。 $&amp;：匹配的子字符串。$`：匹配结果前面的文本。$’：匹配结果后面的文本。$n：匹配成功的第n组内容，n是从1开始的自然数。$$：指代美元符号$。 12345&apos;hello world&apos;.replace(/(\w+)\s(\w+)/, &apos;$2 $1&apos;)// &quot;world hello&quot;&apos;abc&apos;.replace(&apos;b&apos;, &apos;[$`-$&amp;-$\&apos;]&apos;)// &quot;a[a-b-c]c&quot; 上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。 replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 123456789101112&apos;3 and 5&apos;.replace(/[0-9]+/g, function (match) &#123; return 2 * match;&#125;)// &quot;6 and 10&quot;var a = &apos;The quick brown fox jumped over the lazy dog.&apos;;var pattern = /quick|brown|lazy/ig;a.replace(pattern, function replacer(match) &#123; return match.toUpperCase();&#125;);// The QUICK BROWN fox jumped over the LAZY dog. 作为replace方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。 1234567891011121314151617var prices = &#123; &apos;p1&apos;: &apos;$1.99&apos;, &apos;p2&apos;: &apos;$9.99&apos;, &apos;p3&apos;: &apos;$5.00&apos;&#125;;var template = &apos;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&apos; + &apos;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&apos; + &apos;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&apos;;template.replace( /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g, function(match, $1, $2, $3, $4)&#123; return $1 + $2 + $3 + prices[$2] + $4; &#125;);// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot; 上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用$1到$4表示。匹配函数的作用是将价格插入模板中。 String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 1str.split(separator, [limit]) 该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。 1234567891011// 非正则分隔&apos;a, b,c, d&apos;.split(&apos;,&apos;)// [ &apos;a&apos;, &apos; b&apos;, &apos;c&apos;, &apos; d&apos; ]// 正则分隔，去除多余的空格&apos;a, b,c, d&apos;.split(/, */)// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]// 指定返回数组的最大成员&apos;a, b,c, d&apos;.split(/, */, 2)[ &apos;a&apos;, &apos;b&apos; ] 上面代码使用正则表达式，去除了子字符串的逗号后面的空格。上面的第二段代码，是因为匹配到了,，并且,后跟着的是0个或多个空格，因此能够将逗号+空格的字符匹配出来并作为分割符来分割字符串。 1234567// 例一&apos;aaa*a*&apos;.split(/a*/)// [ &apos;&apos;, &apos;*&apos;, &apos;*&apos; ]// 例二&apos;aaa**a*&apos;.split(/a*/)// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;] 上面代码的分割规则是0次或多次的a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是aaa，第二个分割符是a，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是aaa，第二个分隔符是0个a（即空字符），第三个分隔符是a，所以将字符串分成四个部分。 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。 12&apos;aaa*a*&apos;.split(/(a*)/)// [ &apos;&apos;, &apos;aaa&apos;, &apos;*&apos;, &apos;a&apos;, &apos;*&apos; ] 上面代码的正则表达式使用了括号，第一个组匹配是aaa，第二个组匹配是a，它们都作为数组成员返回。 匹配规则正则表达式的规则很复杂，下面一一介绍这些规则。 字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。 1/dog/.test(&apos;old dog&apos;) // true 上面代码中正则表达式的dog，就是字面量字符，所以/dog/匹配old dog，因为它就表示d、o、g三个字母连在一起。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。 点字符（.)点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。 1/c.t/ 上面代码中，c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。 位置字符 ^ 表示字符串的开始位置$ 表示字符串的结束位置 12345678910// test必须出现在开始位置/^test/.test(&apos;test123&apos;) // true// test必须出现在结束位置/test$/.test(&apos;new test&apos;) // true// 从开始位置到结束位置只有test/^test$/.test(&apos;test&apos;) // true/^test$/.test(&apos;test test&apos;) // false/^test$/.test(&apos;testtest&apos;) // false 选择符（|）竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 1/11|22/.test(&apos;911&apos;) // true 上面代码中，正则表达式指定必须匹配11或22。 多个选择符可以联合使用。 12// 匹配fred、barney、betty之中的一个/fred|barney|betty/ 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。 1/a( |\t)b/.test(&apos;a\tb&apos;) // true 上面代码指的是，a和b之间有一个空格或者一个制表符。 其他的元字符还包括\\、\*、+、?、()、[]、{}等，将在下文解释。 转义符正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠进行转义。比如要匹配+，就要写成\+。 12345/1+1/.test(&apos;1+1&apos;)// false/1\+1/.test(&apos;1+1&apos;)// true 上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。 正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 12345(new RegExp(&apos;1\+1&apos;)).test(&apos;1+1&apos;)// false(new RegExp(&apos;1\\+1&apos;)).test(&apos;1+1&apos;)// true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。字符串中使用了一个\将+转义为+本身，此时再放入构造函数中的字符串即为1\+1，就能够正常将加号转义。 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。[\b] 匹配退格键(U+0008)，不要与\b混淆。\n 匹配换行键。\r 匹配回车键。\t 匹配制表符 tab（U+0009）。\v 匹配垂直制表符（U+000B）。\f 匹配换页符（U+000C）。\0 匹配null字符（U+0000）。\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。 字符类字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。 12/[abc]/.test(&apos;hello world&apos;) // false/[abc]/.test(&apos;apple&apos;) // true 上面代码中，字符串hello world不包含a、b、c这三个字母中的任一个，所以返回false；字符串apple包含字母a，所以返回true。 有两个字符在字符类中有特殊含义。 脱字符（^）如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。 12/[^abc]/.test(&apos;hello world&apos;) // true/[^abc]/.test(&apos;bbc&apos;) // false 上面代码中，字符串hello world不包含字母a、b、c中的任一个，所以返回true；字符串bbc不包含a、b、c以外的字母，所以返回false。 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。 1234var s = &apos;Please yes\nmake my day!&apos;;s.match(/yes.*day/) // nulls.match(/yes[^]*day/) // [ &apos;yes\nmake my day&apos;] 上面代码中，字符串s含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式[^]包含一切字符，所以匹配成功。 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。 连字符（-）某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。 12/a-z/.test(&apos;b&apos;) // false/[a-z]/.test(&apos;b&apos;) // true 上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列。 以下都是合法的字符类简写形式。 1234[0-9.,][0-9a-fA-F][a-zA-Z0-9-][1-31] 上面代码中最后一个字符类[1-31]，不代表1到31，只代表1到3。 连字符还可以用来指定 Unicode 字符的范围。 123var str = &quot;\u0130\u0131\u0132&quot;;/[\u0128-\uFFFF]/.test(str)// true 上面代码中，\u0128-\uFFFF表示匹配码点在0128到FFFF之间的所有字符。 另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。 1/[A-z]/.test(&apos;\\&apos;) // true 上面代码中，由于反斜杠（‘\’）的ASCII码在大写字母与小写字母之间，结果会被选中。 预定义模式预定义模式指的是某些常见模式的简写方式。 \d 匹配0-9之间的任一数字，相当于[0-9]。\D 匹配所有0-9以外的字符，相当于[^0-9]。\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。\b 匹配词的边界。\B 匹配非词边界，即在词的内部。 下面是一些例子。 1234567891011// \s 的例子/\s\w*/.exec(&apos;hello world&apos;) // [&quot; world&quot;]// \b 的例子/\bworld/.test(&apos;hello world&apos;) // true/\bworld/.test(&apos;hello-world&apos;) // true/\bworld/.test(&apos;helloworld&apos;) // false// \B 的例子/\Bworld/.test(&apos;hello-world&apos;) // false/\Bworld/.test(&apos;helloworld&apos;) // true 上面代码中，\s表示空格，所以匹配结果会包括空格。\b表示词的边界，所以world的词首必须独立（词尾是否独立未指定），才会匹配。同理，\B表示非词的边界，只有world的词首不独立，才会匹配。由上面的代码可以看出-也算是词的边界。 通常，正则表达式遇到换行符（\n）就会停止匹配。 1234var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;/.*/.exec(html)[0]// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot; 上面代码中，字符串html包含一个换行符，结果点字符（.）不匹配换行符，导致匹配结果可能不符合原意。这时使用\s字符类，就能包括换行符。 1234567var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;/[\S\s]*/.exec(html)[0]// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;/.*\s.*/.exec(html)[0]// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot; 上面代码中，[\S\s]指代一切字符。 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 12/lo&#123;2&#125;k/.test(&apos;look&apos;) // true/lo&#123;2,5&#125;k/.test(&apos;looook&apos;) // true 上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间。 量词符量词符用来设定某个模式出现的次数。 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。* 星号表示某个模式出现0次或多次，等同于{0,}。+ 加号表示某个模式出现1次或多次，等同于{1,}。 1234567891011121314// t 出现0次或1次/t?est/.test(&apos;test&apos;) // true/t?est/.test(&apos;est&apos;) // true// t 出现1次或多次/t+est/.test(&apos;test&apos;) // true/t+est/.test(&apos;ttest&apos;) // true/t+est/.test(&apos;est&apos;) // false// t 出现0次或多次/t*est/.test(&apos;test&apos;) // true/t*est/.test(&apos;ttest&apos;) // true/t*est/.test(&apos;tttest&apos;) // true/t*est/.test(&apos;est&apos;) // true 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 12var s = &apos;aaa&apos;;s.match(/a+/) // [&quot;aaa&quot;] 上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。 12var s = &apos;aaa&apos;;s.match(/a+?/) // [&quot;a&quot;] 上面代码中，模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。 *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 修饰符修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。 修饰符可以单个使用，也可以多个一起使用。 12345// 单个修饰符var regex = /test/i;// 多个修饰符var regex = /test/ig; g 修饰符默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。 123456var regex = /b/;var str = &apos;abba&apos;;regex.test(str); // trueregex.test(str); // trueregex.test(str); // true 上面代码中，正则模式不含g修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。 1234567var regex = /b/g;var str = &apos;abba&apos;;regex.test(str); // trueregex.test(str); // trueregex.test(str); // falseregex.test(str); // true 上面代码中，正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串abba只有两个b，所以前两次匹配结果为true，第三次匹配结果为false。等到下一次匹配时又会变为true，因为此时lastIndex的值被重置为0，即再次从头开始匹配。 i 修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 12/abc/.test(&apos;ABC&apos;) // false/abc/i.test(&apos;ABC&apos;) // true 上面代码表示，加了i修饰符以后，不考虑大小写，所以模式abc匹配字符串ABC。 m 修饰符m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。 12/world$/.test(&apos;hello world\n&apos;) // false/world$/m.test(&apos;hello world\n&apos;) // true 上面的代码中，字符串结尾处有一个换行符。如果不加m修饰符，匹配不成功，因为字符串的结尾不是world；加上以后，$可以匹配行尾。 1/^b/m.test(&apos;a\nb&apos;) // true 上面代码要求匹配行首的b，如果不加m修饰符，就相当于b只能处在字符串的开始处。加上b修饰符以后，换行符\n也会被认为是一行的开始。 组匹配概述正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。 12/fred+/.test(&apos;fredd&apos;) // true/(fred)+/.test(&apos;fredfred&apos;) // true 上面代码中，第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配fred这个词。 下面是另外一个分组捕获的例子。123var m = &apos;abcabc&apos;.match(/(.)b(.)/);m// [&apos;abc&apos;, &apos;a&apos;, &apos;c&apos;] 上面代码中，正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。 注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容，而只捕获匹配整个表达式的内容。 12var m = &apos;abcabc&apos;.match(/(.)b(.)/g);m // [&apos;abc&apos;, &apos;abc&apos;] 上面代码使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的exec方法，配合循环，才能读到每一轮匹配的组捕获。 123456789var str = &apos;abcabc&apos;;var reg = /(.)b(.)/g;while (true) &#123; var result = reg.exec(str); if (!result) break; console.log(result);&#125;// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;] 上面的代码使用了exec加修饰符g，g表示exec每次执行都从上一次匹配结束的地方继续匹配。exec配合圆括号使用，则返回的结果，如果没有成功匹配则返回null，如果匹配成功了返回一个数组，其中，第一个值为整体匹配的结果，第二个值为第一个括号匹配的结果，第三个值为第二个括号匹配的结果，依次类推。 正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 12/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)// true 上面的代码中，\1表示第一个括号匹配的内容（即a），\2表示第二个括号匹配的内容（即c）。 下面是另外一个例子。1/y(..)(.)\2\1/.test(&apos;yabccab&apos;) // true 括号还可以嵌套。 12345/y((..)\2)\1/.test(&apos;yabababab&apos;) // true/y((..)a\2)\1/.test(&apos;yabaababaab&apos;) // true/y((..)c)\2\1/.test(&apos;yabcababcab&apos;) // true 上面代码中，\1指向外层括号，\2指向内层括号。 组匹配非常有用，下面是一个匹配网页标签的例子。 1234var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]// &apos;b&apos; 上面代码中，圆括号匹配尖括号之中的标签，而\1就表示对应的闭合标签。 上面代码略加修改，就能捕获带有属性的标签。 1234567891011121314var html = &apos;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&apos;;var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;var match = tag.exec(html);match[1] // &quot;b&quot;match[2] // &quot; class=&quot;hello&quot;&quot;match[3] // &quot;Hello&quot;match = tag.exec(html);match[1] // &quot;i&quot;match[2] // &quot;&quot;match[3] // &quot;world&quot; 非捕获组(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。 请看下面的例子。12var m = &apos;abc&apos;.match(/(?:.)b(.)/);m // [&quot;abc&quot;, &quot;c&quot;] 上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。 下面是用来分解网址的正则表达式。1234567891011// 正常匹配var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec(&apos;http://google.com/&apos;);// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]// 非捕获组匹配var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;url.exec(&apos;http://google.com/&apos;);// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;] 上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。 先行断言x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。 “先行断言”中，括号里的部分是不会返回的。 12var m = &apos;abc&apos;.match(/b(?=c)/);m // [&quot;b&quot;] 上面的代码使用了先行断言，b在c前面所以被匹配，但是括号对应的c不会被返回。 先行否定断言x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。 12/\d+(?!\.)/.exec(&apos;3.14&apos;)// [&quot;14&quot;] 上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。 “先行否定断言”中，括号里的部分是不会返回的。 12var m = &apos;abd&apos;.match(/b(?!c)/);m // [&apos;b&apos;] 上面的代码使用了先行否定断言，b不在c前面所以被匹配，而且括号对应的d不会被返回。 JSON对象JSON 格式JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。 每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。 JSON 对值的类型和格式有严格的规定。 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 以下都是合法的 JSON。 1234567[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#123; &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 &#125;&#123;&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] &#125;[ &#123; &quot;name&quot;: &quot;张三&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;&#125; ] 以下都是不合法的 JSON。 123456789101112&#123; name: &quot;张三&quot;, &apos;age&apos;: 32 &#125; // 属性名必须使用双引号[32, 64, 128, 0xFFF] // 不能使用十六进制值&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined &#125; // 不能使用 undefined&#123; &quot;name&quot;: &quot;张三&quot;, &quot;birthday&quot;: new Date(&apos;Fri, 26 Aug 2011 07:13:10 GMT&apos;), &quot;getName&quot;: function () &#123; return this.name; &#125;&#125; // 属性值不能使用函数和日期对象 注意，null、空数组和空对象都是合法的 JSON 值。 JSON 对象JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。 JSON.stringify()基本用法JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 1234567891011JSON.stringify(&apos;abc&apos;) // &quot;&quot;abc&quot;&quot;JSON.stringify(1) // &quot;1&quot;JSON.stringify(false) // &quot;false&quot;JSON.stringify([]) // &quot;[]&quot;JSON.stringify(&#123;&#125;) // &quot;&#123;&#125;&quot;JSON.stringify([1, &quot;false&quot;, false])// &apos;[1,&quot;false&quot;,false]&apos;JSON.stringify(&#123; name: &quot;张三&quot; &#125;)// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos; 上面代码将各种类型的值，转成 JSON 字符串。 注意，对于原始类型的字符串，转换结果会带双引号。 12JSON.stringify(&apos;foo&apos;) === &quot;foo&quot; // falseJSON.stringify(&apos;foo&apos;) === &quot;\&quot;foo\&quot;&quot; // true 上面代码中，字符串foo，被转成了&quot;\&quot;foo&quot;\&quot;。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值。 12JSON.stringify(false) // &quot;false&quot;JSON.stringify(&apos;false&apos;) // &quot;\&quot;false\&quot;&quot; 上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。 如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。 123456var obj = &#123; a: undefined, b: function () &#123;&#125;&#125;;JSON.stringify(obj) // &quot;&#123;&#125;&quot; 上面代码中，对象obj的a属性是undefined，而b属性是一个函数，结果都被JSON.stringify过滤。 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。 12var arr = [undefined, function () &#123;&#125;];JSON.stringify(arr) // &quot;[null,null]&quot; 上面代码中，数组arr的成员是undefined和函数，它们都被转成了null。 正则对象会被转成空对象。 1JSON.stringify(/foo/) // &quot;&#123;&#125;&quot; JSON.stringify方法会忽略对象的不可遍历属性。 12345678910111213var obj = &#123;&#125;;Object.defineProperties(obj, &#123; &apos;foo&apos;: &#123; value: 1, enumerable: true &#125;, &apos;bar&apos;: &#123; value: 2, enumerable: false &#125;&#125;);JSON.stringify(obj); // &quot;&#123;&quot;foo&quot;:1&#125;&quot; 上面代码中，bar是obj对象的不可遍历属性，JSON.stringify方法会忽略这个属性。 第二个参数JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 12345678910var obj = &#123; &apos;prop1&apos;: &apos;value1&apos;, &apos;prop2&apos;: &apos;value2&apos;, &apos;prop3&apos;: &apos;value3&apos;&#125;;var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];JSON.stringify(obj, selectedProperties)// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot; 上面代码中，JSON.stringify方法的第二个参数指定，只转prop1和prop2两个属性。 这个类似白名单的数组，只对对象的属性有效，对数组无效。 12345JSON.stringify([&apos;a&apos;, &apos;b&apos;], [&apos;0&apos;])// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;JSON.stringify(&#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;, [&apos;0&apos;])// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot; 上面代码中，第二个参数指定 JSON 格式只转0号属性，实际上对数组是无效的，只对对象有效。 第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。 123456789function f(key, value) &#123; if (typeof value === &quot;number&quot;) &#123; value = 2 * value; &#125; return value;&#125;JSON.stringify(&#123; a: 1, b: 2 &#125;, f)// &apos;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&apos; 上面代码中的f函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回。 注意，这个处理函数是递归处理所有的键。 123456789101112var o = &#123;a: &#123;b: 1&#125;&#125;;function f(key, value) &#123; console.log(&quot;[&quot;+ key +&quot;]:&quot; + value); return value;&#125;JSON.stringify(o, f)// []:[object Object]// [a]:[object Object]// [b]:1// &apos;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&apos; 上面代码中，对象o一共会被f函数处理三次，最后那行是JSON.stringify的输出。第一次键名为空，键值是整个对象o；第二次键名为a，键值是{b: 1}；第三次键名为b，键值为1。 递归处理中，每一次处理的对象，都是前一次返回的值。 1234567891011var o = &#123;a: 1&#125;;function f(key, value) &#123; if (typeof value === &apos;object&apos;) &#123; return &#123;b: 2&#125;; &#125; return value * 2;&#125;JSON.stringify(o, f)// &quot;&#123;&quot;b&quot;: 4&#125;&quot; 上面代码中，f函数修改了对象o，接着JSON.stringify方法就递归处理修改后的对象o。 如果处理函数返回undefined或没有返回值，则该属性会被忽略。 123456789function f(key, value) &#123; if (typeof(value) === &quot;string&quot;) &#123; return undefined; &#125; return value;&#125;JSON.stringify(&#123; a: &quot;abc&quot;, b: 123 &#125;, f)// &apos;&#123;&quot;b&quot;: 123&#125;&apos; 上面代码中，a属性经过处理后，返回undefined，于是该属性被忽略了。 第三个参数JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 123456789101112131415JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2);/*&quot;&#123; &quot;p1&quot;: 1, &quot;p2&quot;: 2&#125;&quot;*/JSON.stringify(&#123; p1:1, p2:2 &#125;, null, &apos;|-&apos;);/*&quot;&#123;|-&quot;p1&quot;: 1,|-&quot;p2&quot;: 2&#125;&quot;*/ 参数对象的 toJSON 方法如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。 下面是一个普通的对象。 1234567891011var user = &#123; firstName: &apos;三&apos;, lastName: &apos;张&apos;, get fullName()&#123; return this.lastName + this.firstName; &#125;&#125;;JSON.stringify(user)// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot; 现在，为这个对象加上toJSON方法。 1234567891011121314151617var user = &#123; firstName: &apos;三&apos;, lastName: &apos;张&apos;, get fullName()&#123; return this.lastName + this.firstName; &#125;, toJSON: function () &#123; return &#123; name: this.lastName + this.firstName &#125;; &#125;&#125;;JSON.stringify(user)// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot; 上面代码中，JSON.stringify发现参数对象有toJSON方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。 Date对象就有一个自己的toJSON方法。 123var date = new Date(&apos;2015-01-01&apos;);date.toJSON() // &quot;2015-01-01T00:00:00.000Z&quot;JSON.stringify(date) // &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot; 上面代码中，JSON.stringify发现处理的是Date对象实例，就会调用这个实例对象的toJSON方法，将该方法的返回值作为参数。 toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。 12345678910var obj = &#123; reg: /foo/&#125;;// 不设置 toJSON 方法时JSON.stringify(obj) // &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;// 设置 toJSON 方法时RegExp.prototype.toJSON = RegExp.prototype.toString;JSON.stringify(/foo/) // &quot;&quot;/foo/&quot;&quot; 上面代码在正则对象的原型上面部署了toJSON方法，将其指向toString方法，因此遇到转换成JSON时，正则对象就先调用toJSON方法转为字符串，然后再被JSON.stingify方法处理。 JSON.parse()JSON.parse方法用于将 JSON 字符串转换成对应的值。 12345678JSON.parse(&apos;&#123;&#125;&apos;) // &#123;&#125;JSON.parse(&apos;true&apos;) // trueJSON.parse(&apos;&quot;foo&quot;&apos;) // &quot;foo&quot;JSON.parse(&apos;[1, 5, &quot;false&quot;]&apos;) // [1, 5, &quot;false&quot;]JSON.parse(&apos;null&apos;) // nullvar o = JSON.parse(&apos;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&apos;);o.name // 张三 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。 12JSON.parse(&quot;&apos;String&apos;&quot;) // illegal single quotes// SyntaxError: Unexpected token ILLEGAL 上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。 为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。 12345try &#123; JSON.parse(&quot;&apos;String&apos;&quot;);&#125; catch(e) &#123; console.log(&apos;parsing error&apos;);&#125; JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。 123456789function f(key, value) &#123; if (key === &apos;a&apos;) &#123; return value + 10; &#125; return value;&#125;JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&apos;, f)// &#123;a: 11, b: 2&#125; 上面代码中，JSON.parse的第二个参数是一个函数，如果键名是a，该函数会将键值加上10。 console对象console对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 console的常见用途有两个。 调试程序，显示网页代码运行时的错误信息。提供了一个命令行接口，用来与网页代码互动。 浏览器实现console对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。 按 F12 或者Control + Shift + i（PC）/ Alt + Command + i（Mac）。 浏览器菜单选择“工具/开发者工具”。 在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。 打开开发者工具以后，顶端有多个面板。 Elements：查看网页的 HTML 源码和 CSS 代码。Resources：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。Network：查看网页的 HTTP 通信情况。Sources：查看网页加载的脚本源码。Timeline：查看各种网页行为随时间变化的情况。Performance：查看网页的性能情况，比如 CPU 和内存消耗。Console：用来运行 JavaScript 命令。 这些面板都有各自的用途，以下只介绍Console面板（又称为控制台）。 Console面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。 console 对象的静态方法console对象提供的各种静态方法，用来与控制台窗口互动。 console.log()，console.info()，console.debug()console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。 1234console.log(&apos;Hello World&apos;)// Hello Worldconsole.log(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)// a b c console.log方法会自动在每次输出的结尾，添加换行符。 123456console.log(1);console.log(2);console.log(3);// 1// 2// 3 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 12console.log(&apos; %s + %s = %s&apos;, 1, 1, 2)// 1 + 1 = 2 console.log方法支持以下占位符，不同类型的数据必须使用对应的占位符。 %s 字符串%d 整数%i 整数%f 浮点数%o 对象的链接%c CSS 格式字符串 12345var number = 11 * 9;var color = &apos;red&apos;;console.log(&apos;%d %s balloons&apos;, number, color);// 99 red balloons 使用%c占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行CSS渲染。 1234console.log( &apos;%cThis text is styled!&apos;, &apos;color: red; background: yellow; font-size: 24px;&apos;) 上面代码运行后，输出的内容将显示为黄底红字。 console.log方法的两种参数格式，可以结合在一起使用。 12console.log(&apos; %s + %s &apos;, 1, 1, &apos;= 2&apos;)// 1 + 1 = 2 如果参数是一个对象，console.log会显示该对象的值。 1234console.log(&#123;foo: &apos;bar&apos;&#125;)// Object &#123;foo: &quot;bar&quot;&#125;console.log(Date)// function Date() &#123; [native code] &#125; 上面代码输出Date对象的值，结果为一个构造函数。 console.info是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标，这个蓝色图标在chrome中可能要展开该条信息才能看到。 console.debug方法与console.log方法类似，会在控制台输出调试信息。但是，默认情况下，console.debug输出的信息不会显示，只有在打开显示级别在verbose的情况下，才会显示。 console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。 123456789[&apos;log&apos;, &apos;info&apos;, &apos;warn&apos;, &apos;error&apos;].forEach(function(method) &#123; console[method] = console[method].bind( console, new Date().toISOString() );&#125;);console.log(&quot;出错了！&quot;);// 2014-05-18T09:00.000Z 出错了！ 上面代码表示，使用自定义的console.log方法，可以在显示结果添加当前时间。 console.warn()，console.error()warn方法和error方法也是在控制台输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。 1234console.error(&apos;Error: %s (%i)&apos;, &apos;Server is not responding&apos;, 500)// Error: Server is not responding (500)console.warn(&apos;Warning! Too few nodes (%d)&apos;, document.childNodes.length)// Warning! Too few nodes (1) 可以这样理解，log方法是写入标准输出（stdout），warn方法和error方法是写入标准错误（stderr）。 console.table()对于某些复合类型的数据，console.table方法可以将其转为表格显示。 1234567var languages = [ &#123; name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; &#125;, &#123; name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; &#125;, &#123; name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; &#125;];console.table(languages); 上面代码的language变量，转为表格后会以(index), name, fileExtension为表头，以每个对象中各个对应的值为表格内容，画出一张表格。 类似的例子如下，可以拿去浏览器中试着运行。123456var languages = &#123; csharp: &#123; name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; &#125;, fsharp: &#123; name: &quot;F#&quot;, paradigm: &quot;functional&quot; &#125;&#125;;console.table(languages); console.count()count方法用于计数，输出它被调用了多少次。 12345678910111213141516function greet(user) &#123; console.count(); return &apos;hi &apos; + user;&#125;greet(&apos;bob&apos;)// default: 1// &quot;hi bob&quot;greet(&apos;alice&apos;)// default: 2// &quot;hi alice&quot;greet(&apos;bob&apos;)// default: 3// &quot;hi bob&quot; 上面代码每次调用greet函数，内部的console.count方法就输出执行次数。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。这个标签的默认值为default。 12345678910111213141516function greet(user) &#123; console.count(user); return &quot;hi &quot; + user;&#125;greet(&apos;bob&apos;)// bob: 1// &quot;hi bob&quot;greet(&apos;alice&apos;)// alice: 1// &quot;hi alice&quot;greet(&apos;bob&apos;)// bob: 2// &quot;hi bob&quot; 上面代码根据参数的不同，显示bob执行了两次，alice执行了一次。 console.dir()，console.dirxml()dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 12345678console.log(&#123;f1: &apos;foo&apos;, f2: &apos;bar&apos;&#125;)// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;console.dir(&#123;f1: &apos;foo&apos;, f2: &apos;bar&apos;&#125;)// Object// f1: &quot;foo&quot;// f2: &quot;bar&quot;// __proto__: Object 上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富。 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。1console.dir(document.body) Node 环境之中，还可以指定以代码高亮的形式输出。 1console.dir(obj, &#123;colors: true&#125;) dirxml方法主要用于以目录树的形式，显示 DOM 节点，对于DOM节点来说也就相当于log方法的效果。 1console.dirxml(document.body) 如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。 123console.dirxml([1, 2, 3])// 等同于console.dir([1, 2, 3]) console.assert()console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。 1234567891011console.assert(false, &apos;判断条件不成立&apos;)// Assertion failed: 判断条件不成立// 相当于try &#123; if (false) &#123; throw new Error(&apos;判断条件不成立&apos;); &#125;&#125; catch(e) &#123; console.error(e);&#125; 下面是一个例子，判断子节点的个数是否大于等于500。 1console.assert(list.childNodes.length &lt; 500, &apos;节点个数大于等于500&apos;) 上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。 console.time()，console.timeEnd()这两个方法用于计时，可以算出一个操作所花费的准确时间。 123456789console.time(&apos;Array initialize&apos;);var array= new Array(1000000);for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i] = new Object();&#125;;console.timeEnd(&apos;Array initialize&apos;);// Array initialize: 1914.481ms time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。 console.group()，console.groupEnd()，console.groupCollapsed()console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 12345678console.group(&apos;一级分组&apos;);console.log(&apos;一级分组的内容&apos;);console.group(&apos;二级分组&apos;);console.log(&apos;二级分组的内容&apos;);console.groupEnd(); // 一级分组结束console.groupEnd(); // 二级分组结束 上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分类”和“二级分类”前面都有一个折叠符号，可以用来折叠本级的内容。 console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 123456console.groupCollapsed(&apos;Fetching Data&apos;);console.log(&apos;Request Sent&apos;);console.error(&apos;Error: Server not responding (500)&apos;);console.groupEnd(); 上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。 console.trace()，console.clear()console.trace方法显示当前执行的代码在堆栈中的调用路径。 123456console.trace()// console.trace()// (anonymous function)// InjectedScript._evaluateOn// InjectedScript._evaluateAndWrap// InjectedScript.evaluate console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。 1console.clear() // 本句代码将会清空控制台所有输出 命令行 API浏览器控制台中，除了使用·console·对象，还可以使用一些控制台自带的命令行方法。 $_$_属性返回上一个表达式的值。 12342 + 2// 4$_// 4 $0 - $4控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。 $(selector)$(selector)返回第一个匹配的元素，等同于document.querySelector()。注意，如果页面脚本对$有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行$(selector)就会采用 jQuery 的实现，返回一个数组。 $$(selector)$$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。 $x(path)$x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。 1$x(&quot;//p[a]&quot;) 上面代码返回所有包含a元素的p元素。 inspect(object)inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如inspect(document)会在 Elements 面板显示document元素。JavaScript 对象在控制台面板Profiles面板中显示，比如inspect(window)。 getEventListeners(object)getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。 keys(object)，values(object)keys(object)方法返回一个数组，包含object的所有键名。 values(object)方法返回一个数组，包含object的所有键值。 123456var o = &#123;&apos;p1&apos;: &apos;a&apos;, &apos;p2&apos;: &apos;b&apos;&#125;;keys(o)// [&quot;p1&quot;, &quot;p2&quot;]values(o)// [&quot;a&quot;, &quot;b&quot;] monitorEvents(object[, events]) ，unmonitorEvents(object[, events])monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。 12monitorEvents(window, &quot;resize&quot;);monitorEvents(window, [&quot;resize&quot;, &quot;scroll&quot;]) 上面代码分别表示单个事件和多个事件的监听方法。 12monitorEvents($0, &apos;mouse&apos;);unmonitorEvents($0, &apos;mousemove&apos;); 上面代码表示如何停止监听。 monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。 mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”key：”keydown”, “keyup”, “keypress”, “textInput”touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset” 1monitorEvents($(&quot;#msg&quot;), &quot;key&quot;); 上面代码表示监听所有key大类的事件。 其他方法命令行 API 还提供以下方法。 clear()：清除控制台的历史。copy(object)：复制特定 DOM 元素到剪贴板。dir(object)：显示特定对象的所有属性，是console.dir方法的别名。dirxml(object)：显示特定对象的 XML 形式，是console.dirxml方法的别名。 debugger 语句debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i); if (i === 2) debugger;&#125; 上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。 属性描述对象概述JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。 下面是属性描述对象的一个例子。12345678&#123; value: 123, writable: false, enumerable: true, configurable: false, get: undefined, set: undefined&#125; 属性描述对象提供6个元属性。 （1）value value是该属性的属性值，默认为undefined。 （2）writable writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 （3）enumerable enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 （4）configurable configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 （5）get get是一个函数，表示该属性的取值函数（getter），默认为undefined。 （6）set set是一个函数，表示该属性的存值函数（setter），默认为undefined。 Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名。 12345678var obj = &#123; p: &apos;a&apos; &#125;;Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)// Object &#123; value: &quot;a&quot;,// writable: true,// enumerable: true,// configurable: true// &#125; 上面代码中，Object.getOwnPropertyDescriptor方法获取obj.p的属性描述对象。 注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。 1234var obj = &#123; p: &apos;a&apos; &#125;;Object.getOwnPropertyDescriptor(obj, &apos;toString&apos;)// undefined 上面代码中，toString是Obj对象继承的属性，Object.getOwnPropertyDescriptor无法获取。 Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 1234567var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 1, enumerable: true &#125;, p2: &#123; value: 2, enumerable: false &#125;&#125;);Object.getOwnPropertyNames(obj)// [&quot;p1&quot;, &quot;p2&quot;] 上面代码中，obj.p1是可遍历的，obj.p2是不可遍历的。Object.getOwnPropertyNames会将它们都返回。 这跟Object.keys的行为不同，Object.keys只返回对象自身的&lt;font color=”red&gt;可遍历属性的全部属性名。 123456789101112Object.keys([]) // []Object.getOwnPropertyNames([]) // [ &apos;length&apos; ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)// [&apos;hasOwnProperty&apos;,// &apos;valueOf&apos;,// &apos;constructor&apos;,// &apos;toLocaleString&apos;,// &apos;isPrototypeOf&apos;,// &apos;propertyIsEnumerable&apos;,// &apos;toString&apos;] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。 Object.defineProperty()，Object.defineProperties()Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。 1Object.defineProperty(object, propertyName, attributesObject) Object.defineProperty方法接受三个参数，依次如下。 属性所在的对象属性名（它应该是一个字符串）属性描述对象 举例来说，定义obj.p可以写成下面这样。 1234567891011var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 上面代码中，Object.defineProperty方法定义了obj.p属性。由于属性描述对象的writable属性为false，所以obj.p属性不可写。注意，这里的Object.defineProperty方法的第一个参数是{}（一个新建的空对象），p属性直接定义在这个空对象上面，然后返回这个对象，这是Object.defineProperty的常见写法。 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: &apos;abc&apos;, enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // &quot;abc&quot;obj.p3 // &quot;123abc&quot; 上面代码中，Object.defineProperties同时定义了obj对象的三个属性。其中，p3属性定义了取值函数get，即每次读取该属性，都会调用这个取值函数。 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, &apos;p&apos;, &#123; value: 123, get: function() &#123; return 456; &#125;&#125;);// TypeError: Invalid property.// A property cannot both have accessors and be writable or have a valueObject.defineProperty(obj, &apos;p&apos;, &#123; writable: true, get: function() &#123; return 456; &#125;&#125;);// TypeError: Invalid property descriptor.// Cannot both specify accessors and a value or writable attribute 上面代码中，同时定义了get属性和value属性，以及将writable属性设为true，就会报错。 Object.defineProperty()和Object.defineProperties()的第三个参数，是一个属性对象。它的writable、configurable、enumerable这三个属性的默认值都为false。 123456789var obj = &#123;&#125;;Object.defineProperty(obj, &apos;foo&apos;, &#123;&#125;);Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)// &#123;// value: undefined,// writable: false,// enumerable: false,// configurable: false// &#125; 上面代码中，定义obj.p时用了一个空的属性描述对象，就可以看到各个元属性的默认值。 Object.prototype.propertyIsEnumerable()实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。 12345var obj = &#123;&#125;;obj.p = 123;obj.propertyIsEnumerable(&apos;p&apos;) // trueobj.propertyIsEnumerable(&apos;toString&apos;) // false 上面代码中，obj.p是可遍历的，而继承自原型对象的obj.toString属性是不可遍历的。 元属性**属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。 valuevalue属性是目标属性的值。 12345678var obj = &#123;&#125;;obj.p = 123;Object.getOwnPropertyDescriptor(obj, &apos;p&apos;).value// 123Object.defineProperty(obj, &apos;p&apos;, &#123; value: 246 &#125;);obj.p // 246 上面代码是通过value属性，读取或改写obj.p的例子。 writablewritable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。 12345678910var obj = &#123;&#125;;Object.defineProperty(obj, &apos;a&apos;, &#123; value: 37, writable: false&#125;);obj.a // 37obj.a = 25;obj.a // 37 上面代码中，obj.a的writable属性是false。然后，改变obj.a的值，不会有任何效果。 注意，正常模式下，对writable为false的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对a属性重新赋予一个同样的值。 12345678910&apos;use strict&apos;;var obj = &#123;&#125;;Object.defineProperty(obj, &apos;a&apos;, &#123; value: 37, writable: false&#125;);obj.a = 37;// Uncaught TypeError: Cannot assign to read only property &apos;a&apos; of object 上面代码是严格模式，对obj.a任何赋值行为都会报错。 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。 123456789var proto = Object.defineProperty(&#123;&#125;, &apos;foo&apos;, &#123; value: &apos;a&apos;, writable: false&#125;);var obj = Object.create(proto);obj.foo = &apos;b&apos;;obj.foo // &apos;a&apos; 上面代码中，proto是原型对象，它的foo属性不可写。obj对象继承proto，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。 但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。 1234567891011var proto = Object.defineProperty(&#123;&#125;, &apos;foo&apos;, &#123; value: &apos;a&apos;, writable: false&#125;);var obj = Object.create(proto);Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;b&apos;&#125;);obj.foo // &quot;b&quot; enumerableenumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。 JavaScript 的早期版本，for...in循环是基于in运算符的。我们知道，in运算符不管某个属性是对象自身的还是继承的，都会返回true。这导致了无论是对象自身的属性还是继承的属性，for...in循环都能够遍历到。 12var obj = &#123;&#125;;&apos;toString&apos; in obj // true 上面代码中，toString不是obj对象自身的属性，但是in运算符也返回true，这导致了toString属性也会被for...in循环遍历。 这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被for...in循环遍历，同时还规定toString这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了for...in循环的可用性。 具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环Object.keys方法JSON.stringify方法 因此，enumerable可以用来设置“秘密”属性。 12345678910111213141516var obj = &#123;&#125;;Object.defineProperty(obj, &apos;x&apos;, &#123; value: 123, enumerable: false&#125;);obj.x // 123for (var key in obj) &#123; console.log(key);&#125;// undefinedObject.keys(obj) // []JSON.stringify(obj) // &quot;&#123;a:1, b:2, c:3&#125;&quot; 上面代码中，obj.x属性的enumerable为false，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。 注意，for...in循环包括继承的属性，Object.keys方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法。 另外，JSON.stringify方法会排除enumerable为false的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的enumerable设为false。 configurableconfigurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，configurable为false时，value、writable、enumerable和configurable都不能被修改了。 123456789101112131415161718var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;);Object.defineProperty(obj, &apos;p&apos;, &#123;value: 2&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, &apos;p&apos;, &#123;writable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, &apos;p&apos;, &#123;enumerable: true&#125;)// TypeError: Cannot redefine property: pObject.defineProperty(obj, &apos;p&apos;, &#123;configurable: true&#125;)// TypeError: Cannot redefine property: p 上面代码中，obj.p的configurable为false。然后，改动value、writable、enumerable、configurable，结果都报错。 注意，writable只有在false改为true会报错，true改为false是允许的。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; writable: true, configurable: false&#125;);Object.defineProperty(obj, &apos;p&apos;, &#123;writable: false&#125;)// 修改成功 至于value，只要writable和configurable有一个为true，就允许改动。 1234567891011121314151617181920212223242526var o1 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: true, configurable: false&#125;);Object.defineProperty(o1, &apos;p&apos;, &#123;value: 2&#125;)// 修改成功var o2 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: false, configurable: true&#125;);Object.defineProperty(o2, &apos;p&apos;, &#123;value: 2&#125;)// 修改成功var o3 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, writable: false, configurable: false&#125;);Object.defineProperty(o3, &apos;p&apos;, &#123;value: 2&#125;)// TypeError: Cannot redefine property: p 另外，configurable为false时，直接目标属性赋值，不报错，但不会成功。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 1, configurable: false&#125;);obj.p = 2;obj.p // 1 上面代码中，obj.p的configurable为false，对obj.p赋值是不会生效的。如果是严格模式，还会报错。 可配置性决定了目标属性是否可以被删除（delete）。 12345678910var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 1, configurable: true &#125;, p2: &#123; value: 2, configurable: false &#125;&#125;);delete obj.p1 // truedelete obj.p2 // falseobj.p1 // undefinedobj.p2 // 2 上面代码中，obj.p1的configurable是true，所以可以被删除，obj.p2就无法删除。 存取器除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。 一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值。 1234567891011var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; get: function () &#123; return &apos;getter&apos;; &#125;, set: function (value) &#123; console.log(&apos;setter: &apos; + value); &#125;&#125;);obj.p // &quot;getter&quot;obj.p = 123 // &quot;setter: 123&quot; 上面代码中，obj.p定义了get和set属性。obj.p取值时，就会调用get；赋值时，就会调用set。 JavaScript 还提供了存取器的另一种写法。 12345678var obj = &#123; get p() &#123; return &apos;getter&apos;; &#125;, set p(value) &#123; console.log(&apos;setter: &apos; + value); &#125;&#125;; 上面的写法与定义属性描述对象是等价的，而且使用更广泛。 注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）。 存取器往往用于，属性的值依赖对象内部数据的场合。 12345678910111213141516var obj =&#123; $n : 5, get next() &#123; return this.$n++ &#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw new Error(&apos;新的值必须大于当前值&apos;); &#125;&#125;;obj.next // 5obj.next = 10;obj.next // 10obj.next = 5;// Uncaught Error: 新的值必须大于当前值 上面代码中，next属性的存值函数和取值函数，都依赖于内部属性$n。 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。 123456789101112var extend = function (to, from) &#123; for (var property in from) &#123; to[property] = from[property]; &#125; return to;&#125;extend(&#123;&#125;, &#123; a: 1&#125;)// &#123;a: 1&#125; 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。 1234extend(&#123;&#125;, &#123; get a() &#123; return 1 &#125;&#125;)// &#123;a: 1&#125; 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。 123456789101112131415var extend = function (to, from) &#123; for (var property in from) &#123; if (!from.hasOwnProperty(property)) continue; Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;)// &#123; get a()&#123; return 1 &#125; &#125;) 上面代码中，hasOwnProperty表示该实例对象自身是否具有该属性，那一行代码用来过滤掉继承的属性，否则会报错，因为Object.getOwnPropertyDescriptor读不到继承属性的属性描述对象。 控制对象状态有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 12345678910var obj = new Object();Object.preventExtensions(obj);Object.defineProperty(obj, &apos;p&apos;, &#123; value: &apos;hello&apos;&#125;);// TypeError: Cannot define property:p, object is not extensible.obj.p = 1;obj.p // undefined 上面代码中，obj对象经过Object.preventExtensions以后，就无法添加新属性了。 Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。 12345var obj = new Object();Object.isExtensible(obj) // trueObject.preventExtensions(obj);Object.isExtensible(obj) // false 上面代码中，对obj对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。 Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。 12345678var obj = &#123; p: &apos;hello&apos; &#125;;Object.seal(obj);delete obj.p;obj.p // &quot;hello&quot;obj.x = &apos;world&apos;;obj.x // undefined 上面代码中，obj对象执行Object.seal方法以后，就无法添加新属性和删除旧属性了。 Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。 12345678910111213141516171819202122232425262728var obj = &#123; p: &apos;a&apos;&#125;;// seal方法之前Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)// Object &#123;// value: &quot;a&quot;,// writable: true,// enumerable: true,// configurable: true// &#125;Object.seal(obj);// seal方法之后Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)// Object &#123;// value: &quot;a&quot;,// writable: true,// enumerable: true,// configurable: false// &#125;Object.defineProperty(o, &apos;p&apos;, &#123; enumerable: false&#125;)// TypeError: Cannot redefine property: p 上面代码中，使用Object.seal方法之后，属性描述对象的configurable属性就变成了false，然后改变enumerable属性就会报错。 Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。 1234var obj = &#123; p: &apos;a&apos; &#125;;Object.seal(obj);obj.p = &apos;b&apos;;obj.p // &apos;b&apos; 上面代码中，Object.seal方法对p属性的value无效，是因为此时p属性的可写性由writable决定。 Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。 1234var obj = &#123; p: &apos;a&apos; &#125;;Object.seal(obj);Object.isSealed(obj) // true 这时，Object.isExtensible方法也返回false。 1234var obj = &#123; p: &apos;a&apos; &#125;;Object.seal(obj);Object.isExtensible(obj) // false Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 1234567891011121314var obj = &#123; p: &apos;hello&apos;&#125;;Object.freeze(obj);obj.p = &apos;world&apos;;obj.p // &quot;hello&quot;obj.t = &apos;hello&apos;;obj.t // undefineddelete obj.p // falseobj.p // &quot;hello&quot; 上面代码中，对obj对象进行Object.freeze()以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。 Object.isFrozen()Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。 123456var obj = &#123; p: &apos;hello&apos;&#125;;Object.freeze(obj);Object.isFrozen(obj) // true 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。 12345678var obj = &#123; p: &apos;hello&apos;&#125;;Object.freeze(obj);Object.isSealed(obj) // trueObject.isExtensible(obj) // false Object.isFrozen的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。 123456789var obj = &#123; p: &apos;hello&apos;&#125;;Object.freeze(obj);if (!Object.isFrozen(obj)) &#123; obj.p = &apos;world&apos;;&#125; 上面代码中，确认obj没有被冻结后，再对它的属性赋值，就不会报错了。 局限性上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。 1234567var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);proto.t = &apos;hello&apos;;obj.t// hello 上面代码中，对象obj本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在obj上读到。 一种解决方案是，把obj的原型也冻结住。12345678var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);Object.preventExtensions(proto);proto.t = &apos;hello&apos;;obj.t // undefined 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。 12345678var obj = &#123; foo: 1, bar: [&apos;a&apos;, &apos;b&apos;]&#125;;Object.freeze(obj);obj.bar.push(&apos;c&apos;);obj.bar // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 上面代码中，obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。]]></content>
      <categories>
        <category>JavaScript标准教程笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小知识点整理]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于console.log方法console.log函数，IE中的console.log函数如果打印一个复杂对象，都会调用该对象的toString方法，但是如果是在如chrome等的浏览器中就不会这样。 例如，下面一段代码12345678910111213141516171819var a = &#123; value: 2, valueOf: function()&#123; console.log(&quot;执行了valueOf方法&quot;); return this; &#125;, toString: function()&#123; console.log(&quot;执行了toString方法&quot;); return ++this.value; &#125;&#125;console.log(a);//这一句在chrome里输出a这个对象，打印时不调用toString方法//但在IE中的输出是，日志: 执行了toString方法 ; 日志: 3 //所以可以知道IE在执行console.log打印对象的时候已经调用一次toString方法了//哪怕使用console.log(a.valueOf());也是同理//不同浏览器对valueOf和toString的调用次数是不一样的 关于Servlet中的的编码Servlet中设置请求的编码是req.setCharacterEncoding，设置相应的编码是resp.setContentType(&quot;text/html;charset=UTF-8&quot;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript标准参考教程》阅读笔记之《语法》]]></title>
    <url>%2F2018%2F05%2F06%2F%E3%80%8AJavaScript%E6%A0%87%E5%87%86%E5%8F%82%E8%80%83%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E8%AF%AD%E6%B3%95%E3%80%8B%2F</url>
    <content type="text"><![CDATA[整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址 基本语法语句JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤。如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 变量提升JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 注意：中文是合法的标识符，可以用作变量名。 JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 条件语句条件语句包括if和switch。 if结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，往往由一个条件表达式产生，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 对同一个变量进行多次判断时，多个if…else语句可以连写在一起。 else代码块总是与离自己最近的那个if语句配对。 switch结构switch结构会根据switch关键字后紧跟的变量或表达式的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 多个if…else连在一起使用的时候，可以转为使用更方便的switch结构。 switch语句部分和case语句部分，都可以使用表达式。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 三元运算符 ?:JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 这个三元运算符可以被视为if…else…的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar do not has a value&apos;)// myVar do not has a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 循环语句循环语句用于重复执行某个操作，它有多种形式。 while 循环while语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 所有for循环，都可以改写成while循环。 for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do…while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。for循环也可以使用break语句跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 数据类型概述JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种，具体如下。（ES6 又新增了第七种 Symbol 类型的值） 数值（number）：整数和小数（比如1和3.14）字符串（string）：文本（比如Hello World）。布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）。undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。null：表示空值，即此处的值为空。对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 其中，对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object）数组（array）函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符instanceof运算符Object.prototype.toString方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean，函数返回function，undefined返回undefined（利用这一点，typeof可以用来检查一个没有声明的变量，而不报错），对象返回object，null返回object。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。实际编程中，这个特点通常用在判断语句，可以提高程序的健壮性。 12345678910111213// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125;typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true 另外，null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null 和 undefined概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，实际上在语法效果上几乎没区别。在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 含义与用法都差不多，同时设置两个这样的值其实与历史原因有关。1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 两元逻辑运算符： &amp;&amp; (And)，|| (Or)前置逻辑运算符： ! (Not)相等运算符：===，!==，==，!=比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果JavaScript预期某个位置应该是布尔值（比如if后的判断语句），会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefinednullfalse0NaN“”或’’（空字符串） 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 数值概述整数和浮点数JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的”位运算“部分。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数第2位到第12位（共11位）：指数部分第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 JavaScript提供的有效数字最长为53个二进制位，即精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-2的53次方到2的53次方，都可以精确表示。大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。1Math.pow(2, -1075) // 0 下面是一个实际的例子。1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324 数值的表示法JavaScript的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。数值也可以采用科学计数法表示，例子如下。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。十六进制：有前缀0x或0X的数值。二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 12345025 // 21，因为有前导并且后边的阿拉伯数字没有超过8029 // 29，有前导但是后边的阿拉伯数字超过了80xff // 2550o377 // 2550b11 // 3 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报SyntaxError错误。前导0表示八进制，处理时很容易造成混乱。ES5的严格模式和ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 特殊数值正零和负零前面说过，JavaScript的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 NaN含义NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合，比如。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; 运算规则NaN不等于任何值，包括它本身。1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN Infinity含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷，它们是不相等的。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。Infinity与NaN比较，总是返回false。12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true 运算规则Infinity的四则运算，符合无穷的数学计算规则。 12345678910111213141516171819202122232425262728295 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0// 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。0 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity// Infinity加上或乘以Infinity，返回的还是Infinity。Infinity + Infinity // InfinityInfinity * Infinity // Infinity// Infinity减去或除以Infinity，得到NaN。Infinity - Infinity // NaNInfinity / Infinity // NaN// Infinity与null计算时，null会转成0，等同于与0的计算。null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity// Infinity与undefined计算，返回的都是NaN。undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 与数值相关的全局方法parseInt()基本用法parseInt方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos;123&apos;) // 123 如果parseInt的参数不是字符串，则会先转为字符串再转换。字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 123456789parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 而如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 123456parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。如果字符串以0开头，将其按照10进制解析。而对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 1234567parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 123456parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。比如要将一个字符串转换为二进制，但是字符串中出现了大于等于2的值。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。因此使用的时候一定要十分小心。下面举出几个例子： 123456789101112parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1parseInt(&apos;0x11&apos;, 2) // 0// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 12345678910parseInt(011, 2) // 011首先被转换为字符串9，9不是二进制的有效字符，返回NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2)parseInt(&apos;011&apos;, 2) // 011被当作二进制处理，返回3 parseFloat()parseFloat方法用于将一个字符串转为浮点数，会自动过滤字符串前导的空格。 如果字符串符合科学计数法，则会进行相应的转换。而parseInt是不会对符合科学记数法的字符串进行转换的。 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 12345678910parseFloat(&apos;3.14&apos;) // 3.14parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。出于同样的原因，对于对象和数组，isNaN也返回true。 1234567891011isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // trueisNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值。 总结来说，能被Number转换为数值类型的数据，使用isNaN就是有效的。因此，使用isNaN之前，最好判断一下数据类型。123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。123function myIsNaN(value) &#123; return value !== value;&#125; isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串概述定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠\，用来转义。双引号字符串内部使用双引号，也是如此。 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠\。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 如果想输出多行字符串，有一种利用多行注释的变通方法。12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\n&apos;).slice(1, -1).join(&apos;\n&apos;)// &quot;line 1// line 2// line 3&quot; 转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \0 ：null（\u0000）\b ：后退键（\u0008）\f ：换页符（\u000C）\n ：换行符（\u000A）\r ：回车键（\u000D）\t ：制表符（\u0009）\v ：垂直制表符（\u000B）\’ ：单引号（\u0027）\” ：双引号（\u0022）\ ：反斜杠（\u005C） 反斜杠还有三种特殊用法。 \HHH ：反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 \xHH ：\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 \uXXXX ：\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; length 属性length属性返回字符串的长度，该属性也是无法改变的。因为是属性所以不用加()。改变length属性不会生效，也不会报错。 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。12var f\u006F\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。1btoa(&apos;你好&apos;) 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。encodeURIComponent方法不会对 ASCII 字母和数字进行编码，也不会对ASCII 标点符号进行编码。12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象概述生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量·obj·，所以变量·obj·就指向一个对象。 键名对象的所有键名都是字符串（ES6又引入了Symbol值也可以作为键值），所以加不加引号都可以。如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 如果属性的值还是一个对象，就形成了链式引用。12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 属性可以动态创建，不必在对象声明时就指定。 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;&quot;hello world&quot;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值，那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 表达式还是语句？对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 12&#123; foo: 123 &#125; // 解释为语句(&#123; foo: 123&#125;) // 解释为对象 这种差异在eval语句（作用是对字符串求值）中反映得最明显。12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 属性的操作读取属性读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 查看所有属性查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] delete 命令delete命令用于删除对象的属性，删除成功后返回true。如果再次访问被删除的属性，会返回undefined。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》的Object对象一章）。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。 12var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true，检查的是键名 in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。 12var obj = &#123;&#125;;&apos;toString&apos; in obj // true 上面代码中，toString方法不是对象obj自身的属性，而是继承的属性。但是，in运算符不能识别，对继承的属性也返回true。 for…in 循环for...in循环用来遍历一个对象的全部属性。 12345678var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(obj[i]);&#125;// 1// 2// 3 下面是一个使用for...in循环，提取对象属性名的例子。 123456789101112var obj = &#123; x: 1, y: 2&#125;;var props = [];var i = 0;for (var p in obj) &#123; props[i++] = p&#125;props // [&apos;x&apos;, &apos;y&apos;] for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。1234567var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name with 语句with语句的格式如下：123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 数组定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 数组的赋值除了在定义时赋值，也可以先定义后赋值。 123456789var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];// 或者var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。 123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。而如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。例子如下： 1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 我们知道，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 length 属性数组的length属性，返回数组的成员数量。 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。 12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 因此，清空数组的一个有效方法，就是将length属性设为0。 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 但是，如果人为设置length为不合法的值，JavaScript 会报错。 1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值，例子如下。 1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。一定要注意检查的是键名。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。 12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for…in遍历数组。数组的遍历可以考虑使用for循环或while循环。数组的forEach方法，也可以用来遍历数组。 1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位个数影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 数组的空位是可以读取的，返回undefined。 12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 但如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。“类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 关于arguments作一个简短的概述：在函数代码中，使用特殊对象arguments，开发者无需明确指出参数名，就能访问它们。 例如，在函数 sayHi() 中，第一个参数是message。用 arguments[0]也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。因此，无需明确命名参数，就可以重写函数：1234567function sayHi() &#123; if (arguments[0] == &quot;bye&quot;) &#123; return; &#125; alert(arguments[0]);&#125; 还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length即可。 用arguments对象判断传递给函数的参数个数，即可模拟函数重载： 12345678910function doAdd() &#123; if(arguments.length == 1) &#123; alert(arguments[0] + 5); &#125; else if(arguments.length == 2) &#123; alert(arguments[0] + arguments[1]); &#125;&#125;doAdd(10); //输出 &quot;15&quot;doAdd(40, 20); //输出 &quot;60&quot; 当只有一个参数时，doAdd()函数给参数加5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，doAdd(10)输出的是”15”，而 doAdd(40, 20) 输出的是”60”。虽然不如重载那么好，不过已足以避开 ECMAScript 的这种限制。 回到正题，使用数组的slice方法可以将“类似数组的对象”变成真正的数组。1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。 12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。 1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 概述函数的声明JavaScript 有三种声明函数的方法。 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。比如。123function print(s) &#123; console.log(s);&#125; （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。123456789101112function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1) 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 这也就是说，只有函数声明形式才能被提升，赋值形式是无法提升的。 12345678f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function// 等同于var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。 因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义，因为function命令声明的函数被提升了，而后才执行到赋值语句的定义，此时函数已经被覆盖了。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 不能在条件语句中声明函数根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。 123456789if (foo) &#123; function x() &#123;&#125;&#125;try &#123; function x() &#123;&#125;&#125; catch(e) &#123; console.log(e);&#125; 上面代码分别在if代码块和try代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。 但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。 12345if (false) &#123; function f() &#123;&#125;&#125;f() // 不报错 上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。如下。 12345if (false) &#123; var f = function () &#123;&#125;;&#125;f() // undefined 函数的属性和方法name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2 但是，上面这种情况，只有在变量的值是一个匿名函数时name属性才会返回变量名。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终不变，等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 函数作用域定义作用域（scope）指的是变量存在的范围。 在ES5的规范中，Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;;&#125; 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 1234567891011var x = function () &#123; console.log(a);&#125;;function y(f) &#123; var a = 2; f();&#125;y(x)// ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。 参数概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 123456function square(x) &#123; return x * x;&#125;square(2) // 4square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 参数的省略函数参数不是必需的，Javascript 允许省略参数。 123456789function f(a, b) &#123; return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 123456function f(a, b) &#123; return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 12345678var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 同名参数如果有同名的参数，则取最后出现的那个值。 123456function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2f(1) // undefined 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 调用函数f的时候，如果没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 arguments 对象定义由于JavaScript允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 12345678910var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。使用&#39;use strict&#39;;开启严格模式。 12345678var f = function(a, b) &#123; &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 与数组的关系需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; callee 属性arguments对象带有一个callee属性，返回它所对应的原函数。 12345var f = function () &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他知识点闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 123456function f1() &#123; var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。*在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 这也就是说，start作为createIncreamentor的内部变量，一直没有被回收，所以这个start一直占用内存，可以想象，从第一次声明inc时传入5，start的值为5，因为inc的作用就是返回start的值，然后再将start自增1，所以第一次调用时会返回5，而第二次调用时，start在上次调用时已经自增了1，并且没有被回收，所以第二次调用的结果为6，第二次返回6之后start的值又变为7了。依次类推。 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, // 注意这里返回的getAge是getAge函数 setAge: setAge // 注意这里返回的setAge是setAge函数 &#125;;&#125;var p1 = Person(&apos;张三&apos;);p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 eval 命令eval命令的作用是，将字符串当作语句执行。 12eval(&apos;var a = 1;&apos;);a // 1 上面代码将字符串当作语句运行，生成了变量a。 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。 1eval(&apos;return;&apos;); eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 1234var a = 1;eval(&apos;a = 2&apos;);a // 2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; &apos;use strict&apos;; eval(&apos;var foo = 123&apos;); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; &apos;use strict&apos;; var foo = 1; eval(&apos;foo = 2&apos;); console.log(foo); // 2&#125;)() 上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。 此外，eval的命令字符串不会得到 JavaScript 引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。 通常情况下，eval最常见的场合是解析 JSON 数据字符串，不过正确的做法应该是使用浏览器提供的JSON.parse方法。 JavaScript 引擎内部，eval实际上是一个引用，默认调用一个内部方法。这使得eval的使用分成两种情况，一种是像上面这样的调用eval(expression)，这叫做“直接使用”，这种情况下eval的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时eval的作用域总是全局作用域。 123456789var a = 1;function f() &#123; var a = 2; var e = eval; e(&apos;console.log(a)&apos;);&#125;f() // 1 上面代码中，eval是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。 eval的间接调用的形式五花八门，只要不是直接调用，即只要不是eval(expression)的形式，都属于间接调用。 1234eval.call(null, &apos;...&apos;)window.eval(&apos;...&apos;)(1, eval)(&apos;...&apos;)(eval, eval)(&apos;...&apos;) 上面这些形式都是eval的间接调用，因此它们的作用域都是全局作用域。 与eval作用类似的还有Function构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。 1234567891011var jsonp = &apos;foo(&#123;&quot;id&quot;: 42&#125;)&apos;;var f = new Function( &apos;foo&apos;, jsonp );// 相当于定义了如下函数// function f(foo) &#123;// foo(&#123;&quot;id&quot;:42&#125;);// &#125;f(function (json) &#123; console.log( json.id ); // 42&#125;) 上面代码中，jsonp是一个字符串，Function构造函数将这个字符串，变成了函数体。调用该函数的时候，jsonp就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。 对于本例来说就是将f函数接收的参数，也就是作为参数的函数代码放在函数f的作用域里执行。函数f的作用就是接收一个函数，向这个函数传参，参数为{&quot;id&quot;:42}，并且调用。本例中对f传入了一个函数，传入的函数的作用是接收一个json值，并且打印这个json值的id属性的值。总的来说，就是在函数f的内部调用了打印json数据的函数。 不过，new Function()的写法也可以读写全局作用域，所以也是应该避免使用它。 运算符加法运算符基本规则加法运算符（+）是最常见的运算符，用来求两个数值的和。 需要注意的是，JavaScript 允许非数值的相加。12true + true // 21 + true // 2 上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。 比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。 1&apos;a&apos; + &apos;bc&apos; // &quot;abc&quot; 如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。 121 + &apos;a&apos; // &quot;1a&quot;false + &apos;a&apos; // &quot;falsea&quot; 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。 12&apos;3&apos; + 4 + 5 // &quot;345&quot;，先执行&apos;3&apos;+4的连接操作，再执行了‘34’+5的连接操作3 + 4 + &apos;5&apos; // &quot;75&quot;，先执行了3+4等于7，再执行了7+‘5’的连接操作 上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果。 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。 1231 - &apos;2&apos; // -11 * &apos;2&apos; // 21 / &apos;2&apos; // 0.5 上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。 对象的相加如果运算子是对象，必须先转成原始类型的值，然后再相加。 12var obj = &#123; p: 1 &#125;;obj + 2 // &quot;[object Object]2&quot; 上面代码中，对象obj转成原始类型的值是[object Object]，再加2就得到了上面的结果。 对象转成原始类型的值，规则如下。 首先，自动调用对象的valueOf方法。 12var obj = &#123; p: 1 &#125;;obj.valueOf() // &#123; p: 1 &#125; 一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。 12var obj = &#123; p: 1 &#125;;obj.valueOf().toString() // &quot;[object Object]&quot; 对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果。 知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。 1234567var obj = &#123; valueOf: function () &#123; return 1; &#125;&#125;;obj + 2 // 3 上面代码中，我们定义obj对象的valueOf方法返回1，于是obj + 2就得到了3。这个例子中，由于valueOf方法直接返回一个原始类型的值，所以不再调用toString方法。 下面是自定义toString方法的例子。 1234567var obj = &#123; toString: function () &#123; return &apos;hello&apos;; &#125;&#125;;obj + 2 // &quot;hello2&quot; 上面代码中，对象obj的toString方法返回字符串hello。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。 注意，toString方法不一定非要返回字符串类型的值，也可以返回一个数值1234567var obj = &#123; toString: function () &#123; return 1; &#125;&#125;;obj+2 // 3 同理，valueOf方法也不一定非要返回数值类型的值，也可以返回字符串或其他类型的值。1234567var obj = &#123; valueOf: function () &#123; return &apos;hello&apos;; &#125;&#125;;obj + 2 // &quot;hello2&quot; 我们回到正题，这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。 12345var obj = new Date();obj.valueOf = function () &#123; return 1 &#125;;obj.toString = function () &#123; return &apos;hello&apos; &#125;;obj + 2 // &quot;hello2&quot; 上面代码中，对象obj是一个Date对象的实例，并且自定义了valueOf方法和toString方法，结果toString方法优先执行。 算术运算符包括加法运算符在内，JavaScript 共提供10个算术运算符，用来完成基本的算术运算。 加法运算符：x + y减法运算符： x - y乘法运算符：x * y除法运算符：x / y指数运算符：x ** y余数运算符：x % y自增运算符：++x 或者 x++自减运算符：--x 或者 x--数值运算符： +x负数值运算符：-x 减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符。 余数运算符余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。 112 % 5 // 2，即12除以5得到的余数 需要注意的是，余数运算的运算结果的正负号由第一个运算子的正负号决定。 12-1 % 2 // -11 % -2 // 1 余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。 126.5 % 2.1// 0.19999999999999973 自增和自减运算符自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。 123456var x = 1;++x // 2x // 2--x // 1x // 1 上面代码的变量x自增后，返回2，再进行自减，返回1。这两种情况都会使得，原始变量x的值发生改变。 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。 12345var x = 1;var y = 1;x++ // 1++y // 2 上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。 数值运算符，负数值运算符数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。 123+true // 1+[] // 0+&#123;&#125; // NaN 上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）。具体的类型转换规则，参见《数据类型转换》一章。 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符，但是连用的时候记得加括号，否则会变成自减运算符。 123var x = 1;-x // -1-(-x) // 1 上面代码最后一行的圆括号不可少，否则会变成自减运算符。 数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。 指数运算符指数运算符（``）完成指数运算，前一个运算子是底数，后一个运算子是指数**。 11 ** 3 // 1，即1的3次方 赋值运算符赋值运算符（Assignment Operators）用于给变量赋值。 最常见的赋值运算符，当然就是等号（=）。 12345// 将 1 赋值给变量 xvar x = 1;// 将变量 y 的值赋值给变量 xvar x = y; 赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。 1234567891011121314151617// 等同于 x = x + yx += y// 等同于 x = x - yx -= y// 等同于 x = x * yx *= y// 等同于 x = x / yx /= y// 等同于 x = x % yx %= y// 等同于 x = x ** yx **= y 下面是与位运算符的结合（关于位运算符，请见后文的介绍）。1234567891011121314151617// 等同于 x = x &gt;&gt; yx &gt;&gt;= y// 等同于 x = x &lt;&lt; yx &lt;&lt;= y// 等同于 x = x &gt;&gt;&gt; yx &gt;&gt;&gt;= y// 等同于 x = x &amp; yx &amp;= y// 等同于 x = x | yx |= y// 等同于 x = x ^ yx ^= y 这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。 比较运算符比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。 12 &gt; 1 // true 注意，比较运算符可以比较各种类型的值，不仅仅是数值。 JavaScript 一共提供了8个比较运算符。 &lt; 小于运算符&gt; 大于运算符&lt;= 小于或等于运算符&gt;= 大于或等于运算符== 相等运算符=== 严格相等运算符!= 不相等运算符!== 严格不相等运算符 这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。 字符串的比较字符串按照字典顺序进行比较。 123&apos;cat&apos; &gt; &apos;dog&apos; // false&apos;cat&apos; &gt; &apos;catalog&apos; // false&apos;cat&apos; &gt; &apos;apple&apos; // true JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。 1&apos;cat&apos; &gt; &apos;Cat&apos; // true&apos; 上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。 总体上来讲，小写字母都在大写字母的后边，都比大写字母大。 由于所有字符都有 Unicode 码点，因此汉字也可以比较。 1&apos;大&apos; &gt; &apos;小&apos; // false 上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回false。 非字符串的比较原始类型的值两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。 12345678910115 &gt; &apos;4&apos; // true// 等同于 5 &gt; Number(&apos;4&apos;)// 即 5 &gt; 4true &gt; false // true// 等同于 Number(true) &gt; Number(false)// 即 1 &gt; 02 &gt; true // true// 等同于 2 &gt; Number(true)// 即 2 &gt; 1 上面代码中，字符串和布尔值都会先转成数值，再进行比较。 这里有一个特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。 1234561 &gt; NaN // false1 &lt;= NaN // false&apos;1&apos; &gt; NaN // false&apos;1&apos; &lt;= NaN // falseNaN &gt; NaN // falseNaN &lt;= NaN // false 对象如果运算子是对象，会转为原始类型的值，再进行比较。 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，详细解释参见《数据类型的转换》一章。 123456789var x = [2];x &gt; &apos;11&apos; // true// 等同于 [2].valueOf().toString() &gt; &apos;11&apos;// 即 &apos;2&apos; &gt; &apos;11&apos;x.valueOf = function () &#123; return &apos;1&apos; &#125;;x &gt; &apos;11&apos; // false// 等同于 [2].valueOf() &gt; &apos;11&apos;// 即 &apos;1&apos; &gt; &apos;11&apos; 两个对象之间的比较也是如此。1234567891011[2] &gt; [1] // true// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()// 即 &apos;2&apos; &gt; &apos;1&apos;[2] &gt; [11] // true// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()// 即 &apos;2&apos; &gt; &apos;11&apos;&#123;x: 2&#125; &gt;= &#123;x: 1&#125; // true// 等同于 &#123;x: 2&#125;.valueOf().toString() &gt;= &#123;x: 1&#125;.valueOf().toString()// 即 &apos;[object Object]&apos; &gt;= &apos;[object Object]&apos; 注意，Date 对象实例用于比较时，是先调用toString方法。如果返回的不是原始类型的值，再接着对返回值调用valueOf方法。 严格相等运算符JavaScript 提供两种相等运算符：==和===。 简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。 122 == &apos;2&apos; // true2 === &apos;2&apos; // false 严格相等运算符的算法如下。 不同类型的值如果两个值的类型不同，直接返回false。 121 === &quot;1&quot; // falsetrue === &quot;true&quot; // false 上面代码比较数值的1与字符串的“1”、布尔值的true与字符串&quot;true&quot;，因为类型不同，结果都是false。 同一类的原始类型值同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。 11 === 0x1 // true 上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。 需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。 12NaN === NaN // false+0 === -0 // true 复合类型值两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。 123&#123;&#125; === &#123;&#125; // false[] === [] // false(function () &#123;&#125; === function () &#123;&#125;) // false 上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。 如果两个变量引用同一个对象，则它们相等。123var v1 = &#123;&#125;;var v2 = v1;v1 === v2 // true 注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。 123new Date() &gt; new Date() // falsenew Date() &lt; new Date() // falsenew Date() === new Date() // false 上面的三个表达式，前两个比较的是值，最后一个比较的是地址，所以都返回false。 undefined 和 nullundefined和null与自身严格相等。NaN与任何值都不相等（包括自身） 12undefined === undefined // truenull === null // true 由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。 123var v1;var v2;v1 === v2 // true 严格不相等运算符严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。 11 !== &apos;1&apos; // true 相等运算符相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。 比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下。 原始类型的值原始类型的数据会转换成数值类型再进行比较。 1234567891011121314151617181920212223242526272829301 == true // true// 等同于 1 === Number(true)0 == false // true// 等同于 0 === Number(false)2 == true // false// 等同于 2 === Number(true)2 == false // false// 等同于 2 === Number(false)&apos;true&apos; == true // false// 等同于 Number(&apos;true&apos;) === Number(true)// 等同于 NaN === 1&apos;&apos; == 0 // true// 等同于 Number(&apos;&apos;) === 0// 等同于 0 === 0&apos;&apos; == false // true// 等同于 Number(&apos;&apos;) === Number(false)// 等同于 0 === 0&apos;1&apos; == true // true// 等同于 Number(&apos;1&apos;) === Number(true)// 等同于 1 === 1&apos;\n 123 \t&apos; == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。 对象与原始类型值比较对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 12345678[1] == 1 // true// 等同于 Number([1]) == 1[1] == &apos;1&apos; // true// 等同于 Number([1]) == Number(&apos;1&apos;)[1] == true // true// 等同于 Number([1]) == Number(true) 上面代码中，数组[1]与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成数值，然后再与字符串进行比较，这时字符串也会转成数值；与布尔值进行比较，两个运算子都会先转成数值，然后再进行比较。 undefined 和 nullundefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 1234567false == null // falsefalse == undefined // false0 == null // false0 == undefined // falseundefined == null // true 绝大多数情况下，对象与undefined和null比较，都返回false。只有在对象转为原始值得到undefined时，才会返回true，这种情况是非常罕见的。 相等运算符的缺点相等运算符隐藏的类型转换，会带来一些违反直觉的结果。 12345678910111213140 == &apos;&apos; // true0 == &apos;0&apos; // true2 == true // false2 == false // falsefalse == &apos;false&apos; // falsefalse == &apos;0&apos; // truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true 上面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。 不相等运算符相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。 11 != &apos;1&apos; // false 布尔运算符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：!且运算符：&amp;&amp;或运算符：||三元运算符：?: 取反运算符（!）取反运算符是一个感叹号，用于将布尔值变为相反值，即true变成false，false变成true。 12!true // false!false // true 对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。 undefinednullfalse0NaN空字符串（’’） 12345678910!undefined // true!null // true!0 // true!NaN // true!&quot;&quot; // true!54 // false!&apos;hello&apos; // false![] // false!&#123;&#125; // false 上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。 如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。 123!!x// 等同于Boolean(x) 上面代码中，不管x是什么类型的值，经过两次取反运算后，变成了与Boolean函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。 且运算符（&amp;&amp;）且运算符（&amp;&amp;）往往用于多个表达式的求值。 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 123456789&apos;t&apos; &amp;&amp; &apos;&apos; // &quot;&quot;&apos;t&apos; &amp;&amp; &apos;f&apos; // &quot;f&quot;&apos;t&apos; &amp;&amp; (1 + 2) // 3&apos;&apos; &amp;&amp; &apos;f&apos; // &quot;&quot;&apos;&apos; &amp;&amp; &apos;&apos; // &quot;&quot;var x = 1;(1 - 1) &amp;&amp; ( x += 1) // 0x // 1 上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为false，则直接返回它的值0，而不再对第二个运算子求值，所以变量x的值没变。 这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。 1234567if (i) &#123; doSomething();&#125;// 等价于i &amp;&amp; doSomething(); 上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用。 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值，如果没有布尔值为false的表达式，则返回最后一个表达式的值。 12true &amp;&amp; &apos;foo&apos; &amp;&amp; &apos;&apos; &amp;&amp; 4 &amp;&amp; &apos;foo&apos; &amp;&amp; true// &apos;&apos; 上面代码中，第一个布尔值为false的表达式为第三个表达式，所以得到一个空字符串。 注意，使用且运算符的表达式如果放在if语句的括号内时，if语句会求出整个表达式的最终返回值的布尔值，并依此来决定下一步的操作。 或运算符（||）或运算符（||）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 1234&apos;t&apos; || &apos;&apos; // &quot;t&quot;&apos;t&apos; || &apos;f&apos; // &quot;t&quot;&apos;&apos; || &apos;f&apos; // &quot;f&quot;&apos;&apos; || &apos;&apos; // &quot;&quot; 短路规则对这个运算符也适用。 123var x = 1;true || (x = 2) // truex // 1 上面代码中，且运算符的第一个运算子为true，所以直接返回true，不再运行第二个运算子。所以，x的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值，如果没有布尔值为true的表达式，则返回最后一个表达式的值。 12false || 0 || &apos;&apos; || 4 || &apos;foo&apos; || true// 4 上面代码中第一个布尔值为true的表达式是第四个表达式，所以得到数值4。 或运算符常用于为一个变量设置默认值。1234567function saveText(text) &#123; text = text || &apos;&apos;; // ...&#125;// 或者写成saveText(this.text || &apos;&apos;) 上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。 三元条件运算符（?:）三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。 12&apos;t&apos; ? &apos;hello&apos; : &apos;world&apos; // &quot;hello&quot;0 ? &apos;hello&apos; : &apos;world&apos; // &quot;world&quot; 上面代码的t和0的布尔值分别为true和false，所以分别返回第二个和第三个表达式的值。 通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，&lt;font color=red”&gt;if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。 1console.log(true ? &apos;T&apos; : &apos;F&apos;); 上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了。 位运算符概述位运算符用于直接对二进制位进行计算，一共有7个。 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。二进制否运算符（not）：符号为~，表示对一个二进制位取反。异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。 有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。 1i = i | 0; 上面这行代码的意思，就是将i（不管是整数或小数）转为32位整数。 利用这个特性，可以写出一个函数，将任意数值转为32位整数。123function toInt32(x) &#123; return x | 0;&#125; 上面这个函数将任意值与0进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。 123456toInt32(1.001) // 1toInt32(1.999) // 1toInt32(1) // 1toInt32(-1) // -1toInt32(Math.pow(2, 32) + 1) // 1toInt32(Math.pow(2, 32) - 1) // -1 上面代码中，toInt32可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于2的32次方的整数，大于32位的数位都会被舍去。 技巧：可以使用a|0将a（是一个数字，不管是整数或小数）转为32位整数。 二进制或运算符二进制或运算符（|）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。 10 | 3 // 3 上面代码中，0和3的二进制形式分别是00和11，所以进行二进制或运算会得到11（即3）。 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。与0进行二进制或运算，则二进制位保持不变，原本为1的二进制位仍然为1，原本为0的二进制位仍然为0。 122.9 | 0 // 2-2.9 | 0 // -2 需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。 122147483649.4 | 0;// -2147483647 二进制与运算符二进制与运算符（&amp;）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1。 10 &amp; 3 // 0 上面代码中，0（二进制00）和3（二进制11）进行二进制与运算会得到00（即0）。 二进制否运算符二进制否运算符（~）将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。 1~ 3 // -4 上面表达式对3进行二进制否运算，得到-4。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。 3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。 考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。则取反后的结果等于-1减去这个数本身。 1~ -3 // 2 上面表达式可以这样算，-3的取反值等于-1减去-3，结果为2。 对一个整数连续两次二进制否运算，得到它自身。 1~~3 // 3 所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。 1234~~2.9 // 2~~47.11 // 47~~1.9999 // 1~~3 // 3 使用二进制否运算取整，是所有取整方法中最快的一种。 对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。 1234567891011// 相当于~Number(&apos;011&apos;)~&apos;011&apos; // -12// 相当于~Number(&apos;42 cats&apos;)~&apos;42 cats&apos; // -1// 相当于~Number(&apos;0xcafebabe&apos;)~&apos;0xcafebabe&apos; // 889275713// 相当于~Number(&apos;deadbeef&apos;)~&apos;deadbeef&apos; // -1 Number函数将字符串转为数值的规则，参见《数据的类型转换》一章。 对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。 12345678// 相当于 ~Number([])~[] // -1// 相当于 ~Number(NaN)~NaN // -1// 相当于 ~Number(null)~null // -1 异或运算异或运算（^）在两个二进制位不同时返回1，相同时返回0。 10 ^ 3 // 3 上面表达式中，0（二进制00）与3（二进制11）进行异或运算，它们每一个二进制位都不同，所以得到11（即3）。 “异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值，这是互换两个变量的值的最快方法。 12345678910111213141516var a = 10;var b = 99;a ^= b, b ^= a, a ^= b;a // 99b // 10// 或者写为a = a^b; // 105b = a^b; // 10a = a^b; // 99a // 99b // 10 异或运算也可以用来取整。 112.9 ^ 0 // 12 左移运算符左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（最高位即符号位不参与移动）。 即一个数字a，左移n位，相当于a乘以2的n次方。 12345678// 4 的二进制形式为100，// 左移一位为1000（即十进制的8）// 相当于乘以2的1次方4 &lt;&lt; 1// 8-4 &lt;&lt; 1// -8 上面代码中，-4左移一位得到-8，是因为-4的二进制形式是11111111111111111111111111111100，左移一位后得到11111111111111111111111111111000，该数转为十进制（减去1后取反，再加上负号）即为-8。 如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。 1234513.5 &lt;&lt; 0// 13-13.5 &lt;&lt; 0// -13 左移运算符用于二进制数值非常方便。 123456789101112var color = &#123;r: 186, g: 218, b: 85&#125;;// RGB to HEX// (1 &lt;&lt; 24)的作用为保证结果是6位数var rgb2hex = function(r, g, b) &#123; return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b) .toString(16) // 先转成十六进制，然后返回字符串 .substr(1); // 去除字符串的最高位，返回后面六个字符串&#125;rgb2hex(color.r, color.g, color.b)// &quot;#bada55&quot; 上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。 右移运算符右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）。 即一个数字a，右移n位，相当于a除以2的n次方。 1234567891011121314154 &gt;&gt; 1// 2/*// 因为4的二进制形式为 00000000000000000000000000000100，// 右移一位得到 00000000000000000000000000000010，// 即为十进制的2*/-4 &gt;&gt; 1// -2/*// 因为-4的二进制形式为 11111111111111111111111111111100，// 右移一位，头部补1，得到 11111111111111111111111111111110,// 即为十进制的-2*/ 右移运算可以模拟 2 的整除运算。 1234567891011121314155 &gt;&gt; 1// 2// 相当于 5 / 2 = 221 &gt;&gt; 2// 5// 相当于 21 / 4 = 521 &gt;&gt; 3// 2// 相当于 21 / 8 = 221 &gt;&gt; 4// 1// 相当于 21 / 16 = 1 带符号位的右移运算符带符号位的右移运算符（&gt;&gt;&gt;）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。 123456789104 &gt;&gt;&gt; 1// 2-4 &gt;&gt;&gt; 1// 2147483646/*// 因为-4的二进制形式为11111111111111111111111111111100，// 带符号位的右移一位，得到01111111111111111111111111111110，// 即为十进制的2147483646。*/ 这个运算实际上将一个值转为32位无符号整数。 查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符，进行右移0的运算。 1-1 &gt;&gt;&gt; 0 // 4294967295 上面代码表示，-1作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即(2^32)-1，等于11111111111111111111111111111111）。 开关作用位运算符可以用作设置对象属性的开关。 假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。 1234var FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000 上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。 然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。 123456var flags = 5; // 二进制的0101if (flags &amp; FLAG_C) &#123; // ...&#125;// 0101 &amp; 0100 =&gt; 0100 =&gt; true 上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。 现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。 12var mask = FLAG_A | FLAG_B | FLAG_D;// 0001 | 0010 | 1000 =&gt; 1011 上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。 有了掩码，二进制或运算可以确保打开指定的开关。 1flags = flags | mask; 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。 1flags = flags &amp; mask; 异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。 1flags = flags ^ mask; 二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。 1flags = ~flags; 其他运算符void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 12void 0 // undefinedvoid(0) // undefined 上面是void运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为void运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，void 4 + 7实际上等同于(void 4) + 7。 下面是void运算符的一个例子。123var x = 3;void (x = 5) //undefinedx // 5 这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。 请看下面的代码。123456&lt;script&gt;function f() &#123; console.log(&apos;Hello World&apos;);&#125;&lt;/script&gt;&lt;a href=&quot;http://example.com&quot; onclick=&quot;f(); return false;&quot;&gt;点击&lt;/a&gt; 上面代码中，点击链接后，会先执行onclick的代码，由于onclick返回false，所以浏览器不会跳转到 example.com。 void运算符可以取代上面的写法。1&lt;a href=&quot;javascript: void(f())&quot;&gt;文字&lt;/a&gt; 下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。123&lt;a href=&quot;javascript: void(document.form.submit())&quot;&gt; 提交&lt;/a&gt; 逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。 123456&apos;a&apos;, &apos;b&apos; // &quot;b&quot;var x = 0;var y = (x++, 10);x // 1y // 10 运算顺序优先级JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。 14 + 5 * 6 // 34 上面的代码中，乘法运算符（*）的优先性高于加法运算符（+），所以先执行乘法，再执行加法，相当于下面这样。14 + (5 * 6) // 34 如果多个运算符混写在一起，常常会导致令人困惑的代码。 1234var x = 1;var arr = [];var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0]; 上面代码中，变量y的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（&lt;=)、严格相等（===）、或（||）、三元（?:）、等号（=）。因此上面的表达式，实际的运算顺序如下。1var y = ((arr.length &lt;= 0) || (arr[0] === undefined)) ? x : arr[0]; 记住所有运算符的优先级，是非常难的，也是没有必要的。 圆括号的作用圆括号（()）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。 1(4 + 5) * 6 // 54 上面代码中，由于使用了圆括号，加法会先于乘法执行。 运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。 顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。 注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。 12var x = 1;(x) = 2; 上面代码的第二行，如果圆括号具有求值作用，那么就会变成1 = 2，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。 这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。 123(exprssion)// 等同于expression 函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。 123456function f() &#123; return 1;&#125;(f) // function f()&#123;return 1;&#125;f() // 1 上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。 12(var a = 1)// SyntaxError: Unexpected token var 左结合与右结合对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。 1x + y + z 上面代码先计算最左边的x与y的和，然后再计算与z的和。 但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（=）和三元条件运算符（?:）。12w = x = y = z;q = a ? b : c ? d : e ? f : g; 上面代码的运算结果，相当于下面的样子。12w = (x = (y = z));q = a ? b : (c ? d : (e ? f : g)); 上面的两行代码，各有三个等号运算符和三个三元运算符，都是先计算最右边的那个运算符。 数据类型转换JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。 强制转换强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。 Number()使用Number函数，可以将任意类型的值转化成数值。 下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。 原始类型值原始类型值的转换规则如下。 1234567891011121314151617181920212223// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0Number(NaN) // NaN Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 12parseInt(&apos;42 cats&apos;) // 42Number(&apos;42 cats&apos;) // NaN 上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。 另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12parseInt(&apos;\t\v\r12.34\n&apos;) // 12Number(&apos;\t\v\r12.34\n&apos;) // 12.34 对象简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。 1234Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5Number([]) // 0，因为toString方法转化为&quot;&quot;，即空字符串 之所以会这样，是因为Number背后的转换规则比较复杂。 调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 如果toString方法返回的是对象，就报错。 请看下面的例子。 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125; 上面代码中，Number函数将obj对象转为数值。背后发生了一连串的操作，首先调用obj.valueOf方法, 结果返回对象本身；于是，继续调用obj.toString方法，这时返回字符串[object Object]，对这个字符串使用Number函数，得到NaN。 默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，而toString方法返回对象的类型字符串（比如[object Object]）。所以，会有下面的结果。 1Number(&#123;&#125;) // NaN 如果toString方法返回的不是原始类型的值，结果就会报错。 1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;Number(obj)// TypeError: Cannot convert object to primitive value 上面代码的valueOf和toString方法，返回的都是对象，所以转成数值时会报错。 从上例还可以看到，valueOf和toString方法，都是可以自定义的。 1234567891011121314151617181920212223Number(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// 2Number(&#123; toString: function () &#123; return 3; &#125;&#125;)// 3Number(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// 2 上面代码对三个对象使用Number函数。第一个对象返回valueOf方法的值，第二个对象返回toString方法的值，第三个对象表示valueOf方法先于toString方法执行。 String()String函数可以将任意类型的值转化成字符串，转换规则如下。 原始类型值 数值：转为相应的字符串。字符串：转换后还是原来的值。布尔值：true转为字符串”true”，false转为字符串”false”。undefined：转为字符串”undefined”。null：转为字符串”null”。 12345String(123) // &quot;123&quot;String(&apos;abc&apos;) // &quot;abc&quot;String(true) // &quot;true&quot;String(undefined) // &quot;undefined&quot;String(null) // &quot;null&quot; 对象String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 12String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 如果valueOf方法返回的是对象，就报错。 下面是一个例子。 123456String(&#123;a: 1&#125;)// &quot;[object Object]&quot;// 等同于String(&#123;a: 1&#125;.toString())// &quot;[object Object]&quot; 上面代码先调用对象的toString方法，发现返回的是字符串[object Object]，就不再调用valueOf方法了。 如果toString法和valueOf方法，返回的都是对象，就会报错。 1234567891011var obj = &#123; valueOf: function () &#123; return &#123;&#125;; &#125;, toString: function () &#123; return &#123;&#125;; &#125;&#125;;String(obj)// TypeError: Cannot convert object to primitive value 下面是通过自定义toString方法，改变返回值的例子。 1234567891011121314151617181920212223String(&#123; toString: function () &#123; return 3; &#125;&#125;)// &quot;3&quot;String(&#123; valueOf: function () &#123; return 2; &#125;&#125;)// &quot;[object Object]&quot;String(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;)// &quot;3&quot; 上面代码对三个对象使用String函数。第一个对象返回toString方法的值（数值3），第二个对象返回的还是toString方法的值（[object Object]），第三个对象表示toString方法先于valueOf方法执行。 Boolean()Boolean函数可以将任意类型的值转为布尔值。 它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。 undefinednull-0或+0NaN‘’（空字符串） 12345Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&apos;&apos;) // false 注意，所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true（详见《原始类型值的包装对象》一章）。 123Boolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true 所有对象的布尔值都是true，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于obj1 &amp;&amp; obj2这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为true。 自动转换下面介绍自动转换，它是以强制转换为基础的。 遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。 第一种情况，不同类型的数据互相运算。1123 + &apos;abc&apos; // &quot;123abc&quot; 第二种情况，对非布尔值类型的数据求布尔值。123if (&apos;abc&apos;) &#123; console.log(&apos;hello&apos;)&#125; // &quot;hello&quot; 第三种情况，对非数值类型的值使用一元运算符（即+和-）。12+ &#123;foo: &apos;bar&apos;&#125; // NaN- [1, 2, 3] // NaN 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。 自动转换为布尔值JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。 下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是Boolean函数。 12345// 写法一expression ? true : false// 写法二!! expression 自动转换为字符串JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。 12345678&apos;5&apos; + 1 // &apos;51&apos;&apos;5&apos; + true // &quot;5true&quot;&apos;5&apos; + false // &quot;5false&quot;&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot;&apos;5&apos; + [] // &quot;5&quot;&apos;5&apos; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;&apos;5&apos; + undefined // &quot;5undefined&quot;&apos;5&apos; + null // &quot;5null&quot; 这种自动转换很容易出错。 12345var obj = &#123; width: &apos;100&apos;&#125;;obj.width + 20 // &quot;10020&quot; 上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。 自动转换为数值JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 下面是几个特殊例子。 1234567true - 1 // 0false - 1 // -1&apos;abc&apos; - 1 // NaN&apos;5&apos; * [] // 0false / &apos;5&apos; // 0，可以计算0除以几，只不过都等于0null + 1 // 1undefined + 1 // NaN 上面代码中，运算符两侧的运算子，都被转成了数值。 注意：null转为数值时为0，而undefined转为数值时为NaN。 一元运算符也会把运算子转成数值。 1234+&apos;abc&apos; // NaN-&apos;abc&apos; // NaN+true // 1-false // 0 错误处理机制Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 12var err = new Error(&apos;出错了&apos;);err.message // &quot;出错了&quot; 上面代码中，我们调用Error构造函数，生成一个实例对象err。Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 使用name和message这两个属性，可以对发生什么错误有一个大概的了解。 123if (error.name) &#123; console.log(error.name + &apos;: &apos; + error.message);&#125; stack属性用来查看错误发生时的堆栈。1234567891011121314151617function throwit() &#123; throw new Error(&apos;&apos;);&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace &#125;&#125;catchit()// Error// at throwit (~/examples/throwcatch.js:9:11)// at catchit (~/examples/throwcatch.js:3:9)// at repl:1:5 上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。 原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log &apos;hello&apos;);// Uncaught SyntaxError: Unexpected string 上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。 1234567// 等号左侧不是变量console.log() = 1// Uncaught ReferenceError: Invalid left-hand side in assignment// this 对象不能手动赋值this = 1// ReferenceError: Invalid left-hand side in assignment RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。 主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。123// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length TypeError 对象TypeError对象是变量或参数不是预期类型，或者调用了不存在的方法时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 123456new 123// Uncaught TypeError: number is not a funcvar obj = &#123;&#125;;obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function URIError 对象URIError对象是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 12decodeURI(&apos;%2&apos;)// URIError: URI malformed EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。eval是求值函数，实际上用的并不多。 总结以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。 1234567var err1 = new Error(&apos;出错了！&apos;);var err2 = new RangeError(&apos;出错了，变量超出有效范围！&apos;);var err3 = new TypeError(&apos;出错了，变量类型无效！&apos;);err1.message // &quot;出错了！&quot;err2.message // &quot;出错了，变量超出有效范围！&quot;err3.message // &quot;出错了，变量类型无效！&quot; 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 1234567function UserError(message) &#123; this.message = message || &apos;默认信息&apos;; this.name = &apos;UserError&apos;;&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。 1new UserError(&apos;这是自定义的错误！&apos;); 对上例中的prototype进行简短的解释，prototype 属性使用户有能力向对象添加属性和方法，语法为object.prototype.name=value。例子如下： 1234567891011121314function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);employee.prototype.salary=null;bill.salary=20000;document.write(bill.salary);// 20000 对于上例中的constructor，constructor 属性返回对创建此对象的数组函数的引用，语法object.constructor。例子如下： 123456789101112131415161718var test=new Array();if (test.constructor==Array)&#123; document.write(&quot;This is an Array&quot;);&#125;if (test.constructor==Boolean)&#123; document.write(&quot;This is a Boolean&quot;);&#125;if (test.constructor==Date)&#123; document.write(&quot;This is a Date&quot;);&#125;if (test.constructor==String)&#123; document.write(&quot;This is a String&quot;);&#125; 使用constructor属性。1234567891011function employee(name,job,born)&#123; this.name=name; this.job=job; this.born=born;&#125;var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);document.write(bill.constructor);// function employee(name, job, born)// &#123;this.name = name; this.job = job; this.born = born;&#125; throw语句throw语句的作用是手动中断程序执行，抛出一个错误。 1234if (x &lt; 0) &#123; throw new Error(&apos;x 必须为正数&apos;);&#125;// Uncaught ReferenceError: x is not defined 上面代码中，如果变量x小于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个Error实例。 throw也可以抛出自定义错误。 1234567function UserError(message) &#123; this.message = message || &apos;默认信息&apos;; this.name = &apos;UserError&apos;;&#125;throw new UserError(&apos;出错了！&apos;);// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125; 上面代码中，throw抛出的是一个UserError实例。 实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。 12345678910111213141516171819// 抛出一个字符串throw &apos;Error！&apos;;// Uncaught Error！// 抛出一个数值throw 42;// Uncaught 42// 抛出一个布尔值throw true;// Uncaught true// 抛出一个对象throw &#123; toString: function () &#123; return &apos;Error!&apos;; &#125;&#125;;// Uncaught &#123;toString: ƒ&#125; 对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try…catch 结构一旦发生错误，程序就中止执行了。JavaScript提供了try...catch结构，允许对错误进行处理，选择是否往下执行。 123456789try &#123; throw new Error(&apos;出错了!&apos;);&#125; catch (e) &#123; console.log(e.name + &quot;: &quot; + e.message); console.log(e.stack);&#125;// Error: 出错了!// at &lt;anonymous&gt;:3:9// ... 上面代码中，try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。 catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去，可以避免程序崩溃。 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构，如下。 123456789101112var n = 100;try &#123; throw n;&#125; catch (e) &#123; if (e &lt;= 50) &#123; // ... &#125; else &#123; throw e; &#125;&#125;// Uncaught 100 为了捕捉不同类型的错误，catch代码块之中可以加入判断语句，如下。 12345678910try &#123; foo.bar();&#125; catch (e) &#123; if (e instanceof EvalError) &#123; console.log(e.name + &quot;: &quot; + e.message); &#125; else if (e instanceof RangeError) &#123; console.log(e.name + &quot;: &quot; + e.message); &#125; // ...&#125; finally 代码块try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。 123456789101112function cleansUp() &#123; try &#123; throw new Error(&apos;出错了……&apos;); console.log(&apos;此行不会执行&apos;); &#125; finally &#123; console.log(&apos;完成清理工作&apos;); &#125;&#125;cleansUp()// 完成清理工作// Error: 出错了…… 上面代码中，由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方，注意是执行完finally代码块以后。 12345678910111213function idle(x) &#123; try &#123; console.log(x); return &apos;result&apos;; &#125; finally &#123; console.log(&quot;FINALLY&quot;); &#125;&#125;idle(&apos;hello&apos;)// hello// FINALLY// &quot;result&quot; 上面代码说明，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。注意，只有在finally块执行完毕后，才会显示return语句的值。 下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。 12345678910111213var count = 0;function countUp() &#123; try &#123; return count; &#125; finally &#123; count++; &#125;&#125;countUp()// 0count// 1 上面代码说明，return语句的count的值，是在finally代码块运行之前就获取了。 下面的例子充分反映了try...catch...finally这三者之间的执行顺序。 123456789101112131415161718192021222324function f() &#123; try &#123; console.log(0); throw &apos;bug&apos;; &#125; catch(e) &#123; console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 &#125; finally &#123; console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 &#125; console.log(5); // 不会运行&#125;var result = f();// 0// 1// 3result// false catch代码块之中，触发转入finally代码快的标志，不仅有return语句，还有throw语句。 JavaScript 编程风格概述“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。 有人说，编译器的规范叫做”语法规则“（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫”编程风格“（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。 所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。 必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。 缩进行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。 Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。 无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。 区块如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。 123if (a) b(); c(); 上面代码的原意可能是下面这样。 1234if (a) &#123; b(); c();&#125; 但是，实际效果却是下面这样。 1234if (a) &#123; b();&#125; c(); 因此，建议总是使用大括号表示区块。 另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。1234block&#123; // ...&#125; 另一种是起首的大括号跟在关键字的后面。 123block &#123; // ...&#125; 一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。 12345678910return&#123; key: value&#125;;// 相当于return;&#123; key: value&#125;; 上面的代码的原意，是要返回一个对象，但实际上返回的是undefined，因为 JavaScript 自动在return语句后面添加了分号。为了避免这一类错误，需要写成下面这样。 123return &#123; key : value&#125;; 因此，表示区块起首的大括号，不要另起一行。 圆括号圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）用于提高表达式的优先级。 12345// 圆括号表示函数的调用console.log(&apos;abc&apos;);// 圆括号表示表达式的组合(1 + 2) * 3 建议可以用空格，区分这两种不同的括号。 表示函数调用时，函数名与左括号之间没有空格。 表示函数定义时，函数名与左括号之间没有空格。 其他情况时，前面位置的语法元素与左括号之间，都有一个空格。 但是要注意创建一个匿名函数的时候，function和()之间应该有一个空格。 1function (x) &#123;...&#125; 上面的代码是一个匿名函数，function是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。 行尾的分号分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。 不使用分号的情况首先，以下三种情况，语法规定本来就不需要在结尾添加分号。 for 和 while 循环12345for ( ; ; ) &#123;&#125; // 没有分号while (true) &#123;&#125; // 没有分号 注意，do...while循环是有分号的。 123do &#123; a--;&#125; while(a &gt; 0); // 分号不能省略 分支语句：if，switch，try123456789if (true) &#123;&#125; // 没有分号switch () &#123;&#125; // 没有分号try &#123;&#125; catch &#123;&#125; // 没有分号 函数的声明语句12function f() &#123;&#125; // 没有分号 注意，函数表达式仍然要使用分号。 12var f = function f() &#123;&#125;; 以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。 分号的自动添加除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。 123var a = 1// 等同于var a = 1; 这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。 因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。 12345678910111213141516171819202122// 等同于 var a = 3vara=3// 等同于 &apos;abc&apos;.length&apos;abc&apos;.length// 等同于 return a + b;return a +b;// 等同于 obj.foo(arg1, arg2);obj.foo(arg1,arg2);// 等同于 3 * 2 + 10 * (27 / 6)3 * 2+10 * (27 / 6) 上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。 1234567x = y(function () &#123; // ...&#125;)();// 等同于x = y(function () &#123;...&#125;)(); 下面是更多不会自动添加分号的例子。123456789101112131415161718192021// 引擎解释为 c(d+e)var a = b + c(d+e).toString();// 引擎解释为 a = b/hi/g.exec(c).map(d)// 正则表达式的斜杠，会当作除法运算符a = b/hi/g.exec(c).map(d);// 解释为&apos;b&apos;[&apos;red&apos;, &apos;green&apos;]，// 即把字符串当作一个数组，按索引取值var a = &apos;b&apos;[&apos;red&apos;, &apos;green&apos;].forEach(function (c) &#123; console.log(c);&#125;)// 解释为 function (x) &#123; return x &#125;(a++)// 即调用匿名函数，结果f等于0var a = 0;var f = function (x) &#123; return x &#125;(a++) 只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。 1234567if (a &lt; 0) a = 0console.log(a)// 等同于下面的代码，// 因为 0console 没有意义if (a &lt; 0) a = 0;console.log(a) 另外，如果一行的起首是“自增”（++）或“自减”（--）运算符，则它们的前面会自动添加分号。 12345678910a = b = c = 1a++b--cconsole.log(a, b, c)// 1 2 0 上面代码之所以会得到1 2 0的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。 1234a = b = c = 1;a;++b;--c; 如果continue、break、return和throw这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果return语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。 123456return&#123; first: &apos;Jane&apos; &#125;;// 解释成return;&#123; first: &apos;Jane&apos; &#125;; 由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。 不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。 另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。 12;var a = 1;// ... 上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。 全局变量JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。 因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如UPPER_CASE。 变量声明JavaScript 会自动将变量声明”提升“（hoist）到代码块（block）的头部。 123456789if (!x) &#123; var x = &#123;&#125;;&#125;// 等同于var x;if (!x) &#123; x = &#123;&#125;;&#125; 这意味着，变量x是if代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部。 123456789for (var i = 0; i &lt; 10; i++) &#123; // ...&#125;// 写成var i;for (i = 0; i &lt; 10; i++) &#123; // ...&#125; 上面这样的写法，就容易看出存在一个全局的循环变量i。 另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。 with语句with可以减少代码的书写，但是会造成混淆。 123with (o) &#123; foo = bar;&#125; 上面的代码，可以有四种运行结果： 1234o.foo = bar;o.foo = o.bar;foo = bar;foo = o.bar; 这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用with语句。 相等和严格相等JavaScript 有两个表示相等的运算符：”相等“（==）和”严格相等“（===）。 相等运算符会自动转换变量类型，造成很多意想不到的情况。 12345670 == &apos;&apos;// true1 == true // true2 == true // false0 == &apos;0&apos; // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; // true&apos; \t\r\n &apos; == 0 // true 因此，建议不要使用相等运算符（==），只使用严格相等运算符（===）。 语句的合并有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是 1234a = b;if (a) &#123; // ...&#125; 他喜欢写成下面这样。123if (a = b) &#123; // ...&#125; 上面代码是将a = b这个赋值语句放在了if这个判断语句中。 虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样。 123if （a === b）&#123; // ...&#125; 建议不要将不同目的的语句，合并成一行。 自增和自减运算符自增（++）和自减（--）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的++运算符都可以用+= 1代替。 123++x// 等同于x += 1; 改用+= 1，代码变得更清晰了。 建议自增（++）和自减（--）运算符尽量使用+=和-=代替。 switch…case 结构switch...case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。 而且，switch...case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。 123456789101112131415function doAction(action) &#123; switch (action) &#123; case &apos;hack&apos;: return &apos;hack&apos;; break; case &apos;slash&apos;: return &apos;slash&apos;; break; case &apos;run&apos;: return &apos;run&apos;; break; default: throw new Error(&apos;Invalid action.&apos;); &#125;&#125; 上面的代码建议改写成对象结构。 12345678910111213141516171819function doAction(action) &#123; var actions = &#123; &apos;hack&apos;: function () &#123; return &apos;hack&apos;; &#125;, &apos;slash&apos;: function () &#123; return &apos;slash&apos;; &#125;, &apos;run&apos;: function () &#123; return &apos;run&apos;; &#125; &#125;; if (typeof actions[action] !== &apos;function&apos;) &#123; throw new Error(&apos;Invalid action.&apos;); &#125; return actions[action]();&#125; 上面的代码中最后返回的actions[action]如果不加()则是一个函数，加了()代表调用返回的函数。 因此，建议switch...case结构可以用对象结构代替。]]></content>
      <categories>
        <category>JavaScript标准教程笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime使用技巧]]></title>
    <url>%2F2018%2F04%2F20%2FSublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Sublime版本3的新特性 可以直接打开图片 Goto Anything 使用ctrl+p打开 可以在css文件内部使用@快速定位选择器 可以在js文件内部使用@快速定位函数 可以在html文件内部使用#快速查找 多行游标 产生多行游标的办法： 光标停留在一个词上按ctrl+d，再按ctrl+d就会选中下一个重复词，按ctrl+k再按ctrl+d可以跳过当前词再选择下一个词 光标停留在某一位置，按住shift按住鼠标右键拖动可以快速创建多行游标 选中某一个词，alt+f3可以全选这个词 命令模式 使用ctrl+shift+p打开命令模式 可以快速跳转页面 可以快速改变文档的识别格式，比如打开命令模式窗口，输入js，当前文档就会以JavaScript规则解析高亮 输入minimap，出现的选项可以隐藏/显示minimap emmet 文档开头输入一个!按ctrl+e即可生成html5的头，此时光标自动停留在title部分，使用ctrl+p goto anything来进行页面跳转，输入#body跳转到body处，然后按ctrl+enter快速在该行下方添加一行，就可以开始编辑html5代码了，这一过程无需鼠标操作 使用&gt;符号表示子元素，使用.指明class名称，使用$指明class名称中的数字序号 带缩进粘贴：ctrl+shift+v 当前行上方添加新行：ctrl+shift+enter 使用{}来指明标签内的内容，比如h2{this is title}会生成&lt;h2&gt;this is title&lt;/h2&gt; ctrl+e可以快速闭合标签 package control 可以通过pci在命令窗口中快速匹配package control : install package 安装主题： 可以去package control官网预览一些主题，在Labels——Theme下看 theme-soda theme-flatland theme-spacegray 可以在package control官网中的popular下查看比较流行的插件 snippet 在命令模式中输入snippet，选择function可以直接生成一个js函数，用tab键可以切换高亮，减少鼠标的使用 其实在编辑区中输入fun按回车使用sublime编辑器的自动补全完成这一过程 prototype快速使用原型链 document.getElementById等函数的输入，可以通过安装JavaScript snippet插件，然后输入ei按回车即可 还有很多snippet可以自己探索 advanceNewFile 使用ctrl+alt+N输入文件名或带路径的文件名快速创建文件，不存在的目录也会自动帮忙创建，这比用ctrl+n然后保存的方式要快的多 httpRequester 用于测试服务器端请求 get请求通过访问页面直接测试 post请求通过表单提交测试 使用了httpRequester插件之后，只需要编写一些注释，然后选中这段注释，按下ctrl+alt+R即可弹出一个新的tab页，内容即为运行是否成功等相关信息 nettus fetch 新建一个jQuery.js文件，然后在文件中使用命令模式中使用Fetch File命令，选择想要的文件按下enter，然后就会自动下载最新版本的jQuery side bar相关的插件 可以增强sublime的sidebar的功能，使用后可以直接在sublime中右键一个html文件在浏览器中打开 DocBlockr快速添加注释 可以自动补全注释块 如果是js文件，在一个函数的上方，输入/**，然后按tab键可以自动补齐一个函数的注释格式 使用lint进行语法及风格及校验 目前各个语言基本都有自己的lint系统，可以对语言的语法及风格进行检验 sublime linter是一个总体框架，如果想要针对某个语言需要在具体安装，比如针对js的需要再安装JSHint（JSLint的增强版） 在jshint的网站中可以查看所有可配置参数的说明，可以在工程文件中创建一个.jshintrc文件来配置自己想规定的规则]]></content>
      <categories>
        <category>开发工具使用</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andorid学习笔记]]></title>
    <url>%2F2018%2F04%2F17%2FAndorid%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Android简介知识点 JVM是基于栈的，而DVM是基于寄存器的，运行效率要快一些 每个Android进程都有自己 Dalvik虚拟机，避免一个应用宕机造成整个系统的崩溃。 Android基于Linux内核，进程运行在DVM中。 Android组件 Activity：负责界面显示，是组件的容器 Service：负责后台处理数据 Content Provider：不同组件、应用之间的数据共享 Broadcast Receiver：广播接收组件，比如手机连接到wifi后，会发送一个广播消息，如果一个应用比如百度云盘的数据同步功能对wifi的连接状态感兴趣，那么在接到这个广播信息后该app就可以做出反应 Intent：不同组件之间的跳转，可以携带一些数据，系统会根据携带的值跳转到对应的页面 View：图形用户组件的基类 编程语言的选择 Java（推荐） JavaScript（开发一次，安卓和ios都可用，但是体验不太好） Android开发环境关于开发工具Android Studio Android Monitor窗口：用于监控调试信息，可以设置显示信息的最低级别；其中，Verbose是级别最低、最详细的信息级别； 调试信息可以通过Log.d()、Log.e()等方法进行打印，后边的字母对应着不同的信息级别，如d即为Debug，e即为Error。Log方法的第一个参数为Activity.class.toString()，第二个参数为打印信息内容。 SDK Manager可以用来下载不同版本的SDK，也可以用于查看API Level AVD Manager用于管理或启动开发工具自带的模拟器 关于模拟器Android Studio配置了模拟器，可以在AVD Manager —— Create Virtual Device中创建新的模拟器，点击绿色箭头即可启动对应的模拟器。也可以使用如Nox（夜神）模拟器来进行调试，因为Android Studio自带的可能有点卡。 关于项目 创建项目时，定义的Package Name在手机中会作为唯一标识，不可能有2个应用具有相同的Package Name，通过Package Name和签名控制了同一厂家应用的更新。 Activity相当于一个类，在Activity文件的onCreate()方法中使用setContentView方法来绑定对应的layout文件 layout文件均为XML文件，是布局文件 可以在java包下使用MVC模式，进一步分层为Activity包和Service包等 关于目录结构app | |- manifests（存放Android App的主配置文件） | | | |- AndroidManifest.xml（Android App的主配置文件，在这里注册Activity、组件、服务、权限等） | | |- java | | | |- com.project.company（用于存放类） | | | | | |- MainAcitivity | | | |- res （资源文件夹） | | | |- drawable（存放图片，也可能放在raw中，区别是drawable中的图片资源可能被压缩） | | | |- layout（布局文件，其中存放形如activity_main.xml的文件） | | | |- mipmap（地图） | | | |- values（一些值，包括数组arrays、颜色colors、字符strings、长度dimens等xml文件，也可以通过后缀加以区分实现类似语言切换等功能） | | | |- menu（目录） | | 关于Activity和Layout Activity中的onCreate方法会在界面第一次被创建时执行，在这里可以执行一些初始化操作，比如setContentView(R.layout.layoutname)方法来加载布局文件等 Layout是一种xml布局文件，最外层由布局标签包裹，比如相对布局就是由一对标签包裹的 项目打包及调试监控签名签名是用于防止开发商使用相同的包名，但实际上不是同一开发商开发的情况。签名保证了开发商的唯一性，只有签名程序一致时，才可以正常更新app。 发布版本app的发布版本分为调试版debug或发布版release]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2018%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本篇文章整理自《Linux系统概述》课堂笔记，会有一些与Linux无关的课外知识补充。考试重点在标题前用※标注，十分重要的点会标为彩色。Linux常用命令部分为避免符号混淆，不使用※标注重点，重点直接标为彩色，并且凡是该命令列出的选项均为常用或重点的选项。 基本概念整理操作系统的概念操作系统是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。 操作系统的基本功能包括存储管理、进程和处理及管理、文件管理、设备管理和用户接口服务。 操作系统的类型 批处理系统 分时系统：很普遍 实时系统：典型的实时系统如VxWorks 网络操作系统 分布式操作系统 Linux系统的特点 与Unix兼容 自由软件，源码公开 性能高，安全性强 便于定制和再开发 互操作性高 全面的多任务和真正的32位操作系统 Linux的常用版本 核心版本：主要是Linux的内核，由Linus等人不断开发和推出新的内核。内核版本号格式：x.y.zz-www，x为主版本号，y为次版本号，z为修订版本号。 发行版本：是各个公司推出的版本，与核心版是各自独立发展的，发行版是一些基于Linux核心的软件包。 Linux系统基础知识使用工具推荐虚拟机：VMware（本文使用）、Virtualbox（免费） 虚拟机使用注意事项： 同时开启的所有虚拟机占用内存不要超过真实内存的一半。 一般来讲，建立一个win7内存至少1G+，而建立一个Linux系统内存1G即可，有些版本的Linux系统可能500M+也可以。 但内存也不要过小，否则虚拟机的性能将十分低，导致运行速度过慢。 虚拟机的运行：虚拟机与真实设备共用外存和CPU，内存则划分一块真实内存来使用，硬盘实际上是一个硬盘文件。 系统镜像（*.iso）：红帽企业版、CentOS、debian、openSUSE等，本文均使用红帽企业版。 VMware常用功能 快照功能：虚拟机 —— 快照 —— 拍摄快照/快照管理器；用于记录当前配置环境，后续操作过程中如果出现错误可以随时还原；在快照管理器中右键点击 —— 转到快照，可以使系统还原到该快照； 克隆功能：虚拟机 —— 管理 —— 克隆；用于快速复制一个相同的虚拟机； VMware Tools的安装：虚拟机 —— 重新安装VMware Tools，则安装包会以虚拟光驱的形式出现在虚拟机中，是一个压缩包，使用命令将它解压到/tmp中，然后执行安装 VMware Tools的几个明显的功能：①屏幕自动调整；②可以在真机和虚拟机之间复制文件；③提高游戏性能，是对VMware的增强 虚拟机中系统的安装（VMware安装64位红帽企业版） 在VMware中选择创建新的虚拟机 —— 配置类型选择典型 —— 选择稍后安装操作系统 —— 选择Linux系统 —— 选择green Hat Enterprise版本（这里其实就是个名字，并没有什么实际影响） —— 指定存储路径 —— 指定磁盘容量使用默认配置即可，默认将虚拟磁盘拆分为多个文件即可 —— 选择自定义硬件做最后的调整 —— 完成 开机进行系统安装，开机前保证虚拟光驱中放入了系统镜像（.iso）文件 系统安装部分 选择Test this media &amp; install green Hat Enterprise Linux 7.4，然后根据系统提示安装即可 注意安装时选择带GUI的服务器，并勾选开发工具选项保证gcc可以使用 注意事项： 有些电脑主板不支持开启VT，这样的电脑不能使用64位虚拟机。 如果是安装服务器用的Linux，先不要选择中文，服务器是没有GUI的，因为真实终端刚安装好的时候看不到中文，会全部显示乱码，此时就没办法使用了。 服务器一般为了性能，是不会使用GUI的。 ※Linux系统中硬盘设备的命名规则Linux通过字母和数字的组合来标志硬盘分区。前两个字母表示分区所在的设备的类型，如hd表示IDE硬盘即并口硬盘，sd表示SCSI/SATA/USB硬盘即串口硬盘，第三个字母表示分区在哪个设备上，如hda表示第一块IDE硬盘，hdb表示第二块IDE硬盘，sdc表示第三块串口硬盘等；最后的数字表示分区的次序，如数字1~4表示主分区或扩展分区，而逻辑分区从5开始。如果没有对磁盘分区，则一律不加数字，表示整块磁盘。例：/dev/sda5其中，dev是Linux系统中硬盘设备文件所在的目录；sd表示为串口硬盘，相对的，hd表示为并口硬盘；a表示硬盘的顺序号；5表示分区的顺序号；综上所述，上述命名表示Linux系统中第一块串口硬盘的第5个分区。 ※Linux系统分区规则 默认必须有一个/即根分区，也就相当于Windows系统中的C盘； 默认必须有一个swap分区即交换空间，它用作虚拟内存，通常为内存的1-1.5倍大小甚至2倍。（补充：windows系统的虚拟内存为pagefile.sys，存储在C盘是个隐藏文件。虚拟内存防止所有内存空间突然全部用完的情况，虽然虚拟内存速度很慢，但可以预防紧急情况；还有一种情况是电脑突然待机，此时会把数据放到虚拟内存中） /boot分区是用于保证即使根分区出现问题也能启动计算机的，可以没有。 Linux中的主分区至少有1个，最多有4个（由于分区表大小限制）； 扩展分区可以没有，最多1个； 逻辑分区建立在扩展分区之下，可以有多个； 综上所述，主分区+扩展分区（逻辑分区1+逻辑分区2+…+逻辑分区n）=硬盘容量。 ※在Unix或Linux系统上实现GUI的机制——X WindowX Window模型如下图： Window系统上鼠标点击时是由被点击的应用程序直接获得鼠标点击事件，而Linux系统上则不然，Linux系统在点击后首先通知X Server服务器，X Server收到后，根据大概的位置推算出被点击的是哪个应用程序，再通过X协议告知该应用程序。因此，Windows系统的GUI比Linux稍快。 ※整个X Window由三个部分组成：X ServerX ClientX protocol:X Server与X Client之间的通信协议 其中X Server与X Client可以不在同一台机器上。在启动X Window时，首先启动X Server，然后启动X Client，最后建立通信。 ※Linux常用的文件系统Linux常用的文件系统有ext4、xfs、f2fs、zfs、btrfs补充： windows常用的文件系统有FAT32、NTFS、exFat ios常用的文件系统APFS Linux系统常见的压缩文件后缀 .tar.gz .bz2 .zip .gz .tar.bz2 ※Linux系统的分区表分区表有两种形式 MBR：最多支持4个主分区，或者3个主分区以及一个扩展分区，扩展分区下可以划分出若干个逻辑分区 GPT：支持几乎无限个分区数量，但Windows系统最多支持128个GPT分区 ※GNOME和KDE桌面 GNOME：用GTK、GTK+等应用程序开发包开发的；而GTK是用C语言开发的 KDE：用Qt库开发的，而Qt由c++开发。 一些名词 虚拟控制台 虚拟终端 控制台 命令行 终端 CLI(Commender Line Interface)这些在Linux系统上指代的都是同一样东西，也就是可以输入命令行的窗口或界面。放在Windows系统上来讲就是cmd。其中虚拟控制台和虚拟终端稍有特殊，它们指代的是图形用户界面中的命令行窗口。 Linux系统快捷操作 在Linux系统中使用ctrl+alt+Fn（n=1,2,3..n）来切换到第n个终端，也有些发行版采用快捷键alt+Fn ctrl+shift+t可以在终端窗口中新建标签 命令行快捷方式 输入一个很长的文件名时，可以先输入头几个字母，然后按tab键补全；系统补全操作会在出现其他可能的选择时停下来，此时要么再输入一位；要么再按tab键出现可能选择后，在对照着可能的选择中你要的那个文件名多输入一位，然后再按tab补全 ↑重复运行过的命令中的上一条命令，↓查找运行过的命令中的下一条命令 .bash_history记录之前输入的命令，默认为1000条。使用方法：按ctrl+R，命令提示符会变为(reverse-i-search)，此时输入的东西会去之前输入过的命令中匹配，找到后按回车键即可执行 ※Linux与Windows在命令行与GUI启动顺序上的差异 Linux是先启动命令行，在启动到黑底白字的终端界面后所有功能已经能够正常使用，GUI只是在Linux系统之上运行的一套应用程序，GUI上又提供了可以使用命令行的虚拟终端；（红帽企业版默认在第一个终端上运行GUI） Windows系统的GUI与系统内核是高度集成的，它首先启动GUI，命令行只是运行在GUI上的一个应用程序。 ※Linux系统中根目录下每个文件夹的作用 /bin ：即Binary（二进制）的缩写，用于存放一些命令文件 /sbin ：s代表super user，用于存放root用户专用的一些命令文件 /boot ：boot意为启动、引导，如果不为Linux系统单独建立一个分区则会生成一个boot文件夹，用于存放操作系统的内核以及启动时必需的文件 /dev ：device的缩写，用于存放一些硬件设备 /proc ：内存的映射，如果要修改内存中的数据就通过proc修改，因此备份系统的时候，proc文件夹是不需要备份的 /etc ：存放各种程序的配置文件，这个文件夹一般体积较小，但很重要 /lib(或/lib64) ：用于存放动态链接；相当于Windows系统中的dll文件，程序是以功能片段+共享库的形式运行的，Linux系统中这样的文件后缀名一般为.so或.a /lost+found ：系统的“失物招领处”，非法关机后这里会存有一些文件，一般不会用到，但数据恢复的时候可能会需要找这个文件夹中的文件 /mnt ：mount的缩写，即挂载。挂载操作都需要一个挂载点，Linux系统中的挂载点通常放在这个目录下 /root ：root用户的主目录/家目录，只能root用户自己查看和操作，普通用户没有权限 /home ：普通用户用来存放自己的数据，即普通用户的主目录/家目录。比如有一个名为stu的用户，则它的主目录为/home/stu /var ：放一些经常发生变化的文件，比如日志文件、缓存文件等 /tmp ：存放一些临时文件，重要的文件一定不要放在tmp文件夹里，因为这个文件夹要么定时自动清理，要么开机自动清理，重要文件放在这里容易丢失 /usr ：这个文件夹体积非常大，会放很多东西，比如应用程序的文件之类 /media ：作用同mnt文件夹，区别在于，mnt文件夹下一般存放手动挂载设备的挂载点，而media文件夹下一般存放自动挂载设备（如U盘、移动硬盘等）的挂载点 /opt ：option的缩写，意为“选择”，这个文件夹是一个可选的文件夹 为什么使用Linux命令行因为一般执行远程操作管理的时候都是进入文本环境，GUI会消耗很多不必要的流量；而且使用命令行对做技术支持的人来说十分便利 Linux系统的文件 Linux系统的文件名几乎可以有ASCII字符的任意组合构成，文件名最长可多达255个字符 Linux上可以有形式上的扩展名，扩展名有没有都可以；Linux是通过文件的头信息来识别文件类型的，扩展名在Linux系统上并不起作用，顶多可以由图形用户界面识别扩展名并显示对应的图标而已，再者是为了使文件在不同的文件系统中能够统一类型； Linux中的文件有三个时间信息： ctime：即create time，创建时间 mtime：即modify time，修改时间，对文件内容进行修改或者对文件附属数据进行修改时会更新这个值 atime：访问时间，使用touch命令可以更新这个值 很多配置文件只能root用户修改 Linux系统中的所有文件都有权限和主人 Linux系统的用户 用户注册信息存放在/etc/passwd文件中，编号1000之后的是用户创建的用户，1000之前的是系统默认创建的用户 Linux系统中要删除用户，实际上就是删除/etc/passwd中该用户的那一行信息，并删除/home/用户名这个用户主目录 一般来讲，Linux系统上的home文件夹会单独放在一个分区，就如同windows系统中的D、E、F盘那样，因为重装系统时会格式化根分区，Windows会格式化C盘，将home单独放在一个分区可以避免用户数据丢失 如果Linux的用户改名，主目录是不会改名的 Linux系统中的几种文件类型 普通文件 目录文件：即文件夹 设备文件 符号链接文件：分为软链接和硬链接 Linux系统中的路径 绝对路径，以根目录即/开头 相对路径，以目录名开头或以./开头，比如./etc/也就相当于etc/，代表当前目录下有个etc文件夹 Linux系统中的硬链接和软链接 硬链接：不可以跨分区 软链接：相当于windows系统中的快捷方式，可以跨分区，也称为符号链接 Linux系统常用命令※Shell提示符 root用户： # 其他用户： $ ※shell提示符前面字符串的含义[root@localhost home]# root代表当前登录的用户的用户名 localhost代表当前登录的主机名 home代表当前所在目录 # 是root用户的shell提示符 注意：命令行中输入密码时是没有回显的 Linux系统一般命令格式命令名 [选项] [参数]通常情况下选项是一个短横线加一个字母，如-a、-x、-b，这三个选项也可以略写为-axb；通常两个短横线之后跟一个完整的单词，如–all，则all是一个单词，是一个选项，而不是三个选项；通常来讲会是这样，但并不绝对。 命令名必须是小写的英文字母，并且往往是表示相应功能的英文单词或单词的缩写；命令名、选项和参数彼此间必须用空格或制表符隔开，不能连在一起，连续的空格会被shell解释为单个空格 who命令用于显示当前已注册到系统的所有用户名、所用终端名和注册到系统的时间。tty即为真实终端，是无图形用户界面的终端。pts指的是虚拟终端，是GUI中运行的终端窗口。who am i命令将列出使用该命令的当前用户的相关信息 用户退出登录 logout exit ctrl+P 发送消息 shutdown -k 不关机，只发送消息给所有用户 关机 halt shutdown -h （time可以写为now，代表立刻关机） 例：shutdown -h 11:00 &lt;message&gt; 在11点关机并发送消息message poweroff 注意：有的发行版只有root用户可以关机 重启 reboot shutdown -r ctrl+alt+del ctrl+alt+backspace —— 重启GUI init命令涉及到init命令，首先要了解几个运行级别 0 —— 表示关机 6 —— 表示重启则命令init 0即表示关机 clear命令用于清除屏幕上的信息，类似于dos中的cls命令。 passwd命令用于修改密码。root用户使用passwd 用户名可以不需要原密码就修改该用户的密码 pwd命令 用于显示当前工作路径，可以使用cd命令来切换工作路径 选项： -P 显示实际路径，即，如果路径中有链接文件，-P会将链接文件替换为真实文件 -L 显示逻辑路径 su命令 用于切换用户身份，用法su username，如果不加用户名则默认切换到root用户 root用户切换到普通用户不需要密码，但普通用户切换到root用户需要密码 不建议从root用户用su命令切换到其他用户，因为这样相当于root用户穿了普通用户的马甲，一旦退出无需密码直接退回到root用户，这样有可能会导致一定的安全问题；建议使用exit命令退出root用户同时退回普通用户 echo命令 用于将命令行中的参数回显到标准输出（即屏幕）上，如echo $PATH会显示环境变量PATH的值；而echo 字符串A会显示字符串A 选项： -n ：表示输出字符串String之后光标不换行 date命令 用于在屏幕上显示或设置系统的日期和时间 date显示的日期信息中，有一列CST意为China Standard Time，中国标准时间，即北京时间 date %y%m%d%H%M%S 可以显示年月日时分秒格式的日期 cal命令 用于显示日历，一般格式为 cal [选项] [[[day]month]year] 如：cal 2008会显示08年的日历，cal 03 2020会显示2020年3月的日历 file命令使用file 文件名可以查看文件的头信息 查找 find ：用于在硬盘中查找文件的位置，用法find 路径 -name *example，其中*example代表以example结尾的文件 locate ：用于查找文件的位置，但在文件量特别大的情况下速度比find快，因为locate有一个小型的数据库并建立了索引，所以查找很快，但最新生成的文件可能查找不到因为还没有加入索引中 grep ：用法grep 字符串 文件名，显示文件中包含该字符串的行，通常作为过滤器使用，如cat fstab | grep fs命令会将管道（即|）前面命令的输出作为管道后边命令的输入，前半部分命令用于输出文件全部内容，则fstab文件的所有内容作为后半部分命令的输入，最终得到fstab中包含fs的行 常用的文件操作命令 cat命令 用途：用于显示文件的所有内容；用于链接两个或多个文件 选项：-n，即–number，从1开始对所有输出行编号 举例： cat f1 f2&gt;f3会将f1和f2的内容合并起来，然后通过输出重定向符号&gt;的作用，将它们放入文件f3中。 more命令 用途：显示文件内容，每次显示一屏；按空格键显示下一屏，按enter键显示下一行内容；文件浏览完毕后自动退出；是一次性读取整个文件； less命令 用途：与more类似也用于显示文件内容，但是区别在于，less允许用户向前或向后浏览文件，而more命令只能向前浏览。less命令在开始显示之前，不必读入整个文件，是部分读取，适合用于大文件；用pageup键上翻页，用pagedown键向下翻页，退出可以按q或Q，或者:q，:Q，或者ZZ均可。 head命令 用途：用于在屏幕上显示指定文件的开头若干行，默认为前10行 用法：head [选项] [文件] 选项：-n，即–lines=N，显示指定文件的前面N行 tail命令 用途：用于在屏幕上显示指定文件的末尾部分 用法：tail [选项] [FILE] 选项： -f，当文件增长时输出附加的数据 -n，即–lines=N，输出最后的N行，而不是默认的10行 touch命令 用途：用于修改文件的时间标签（即更新文件的atime）或者创建一个空文件 用法：touch [选项] file，如果file不存在则新建一个文件；如果file已经存在则会更新文件的访问时间 file命令 用途：用于确定文件类型 用法：file [选项] 文件名 匹配、排序及显示指定内容的命令 grep命令 用途：用于在文本文件中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行 用法：grep [选项] 模式 [文件...] 选项：-i，即–ignore-case，匹配比较时不区分字母的大小写 sort命令 用途：用于对文本文件的各行进行排序 用法：sort [选项] [文件] uniq命令 用途：用于从排好序的文件中去除重复行，需要注意的一点是，uniq比较的是相邻的行 用法：` uniq [选项] [输入文件[输出文件]] ※文件压缩命令 Linux常见的压缩格式 filename.tar.gz（最普通） filename.tar.bz2 filename.tar.xz（最常用） .zip（通用，zip压缩包在各个系统上均可使用） filename.tar.gz 压缩：tar zcvf filename.tar.gz some_file_dirs 解压：tar zxvf filename.tar.gz (-c /路径) 解释：z选项指定了用于gz包；c选项和x选项分别指定了压缩和解压；v选项指定了需要显示详细信息，这个选项可以省略；f选项指明文件；解压命令中的-C选项可以指明解压到指定路径 filename.tar.bz2 压缩：tar jcvf filename.tar.bz2 some_file_dirs 解压：tar jxvf filename.tar.bz2 filename.tar.xz 压缩：tar Jcvf filename.tar.xz some_file_dirs 解压：tar Jxvf filename.tar.xz filename.zip 解压：unzip filename.zip 一点知识补充，其实现在微软的无论docx还是pptx格式的文件，只要这些后缀名带x的，实际上就是zip文件，是可以解压的 比较文件内容的命令 comm命令（一般不用，一般会用vimdiff） 用途：用于对两个已经排序的文件进行逐行比较 用法：comm [选项] 文件1 文件2 diff命令 用途：用来比较两个文本文件，并找出他们的不同 用法：diff [选项] 文件1 文件2 注：diff命令会生成一个patch文件，这个文件保存了两者之间的不同，相当于补丁的作用 复制、删除和移动文件的命令 ※cp命令 用途：用于将源文件或目录复制到目标文件或目录中 用法：cp [选项] 源文件或目录 目标文件或目录 选项： -v，显示拷贝的详细过程，如果不用-v则只有光标在闪烁 -R，-r，递归复制目录，即将源目录下的所有文件及其各级子目录都复制到目标位置，此时目标文件必须为一个目录名 特例： cp 目录 不存在的文件的文件名会将前边的目录复制为一个新文件夹，命名为后边的文件名 cp -r dir newdir，如果dir已经存在，会将dir放到newdir中；如果newdir不存在，会将dir复制为newdir rm命令 用途：用于删除文件或目录 用法：rm [选项] [文件] 选项： -f，即–force，忽略不存在的文件，并且不给出提示信息；但是如果是普通用户删除文件，如果没有删除某个文件的权限，那么即使加了-f也是删不掉的 -r，-R，即-recursive，递归地删除指定目录及其下属的各级子目录和相应的文件 -i，交互式地删除文件，即删除文件之前会给出提示并需要用户逐个确认，与-f相反 mv命令 用途：①对文件或目录重新命名②将文件从一个目录移动到另一个目录中 用法：mv [选项] 源文件 目标文件 解释：如果目标文件与源文件路径不同，则是移动操作；如果路径相同，就相当于是重命名操作 文件内容统计命令 wc命令 用途：用于统计指定文件的字节数、字数、行数，并将统计结果显示出来 用法：wc [选项] [文件] 选项： -c，即–bytes，统计字节数 -l，即–lines，统计行数 -m，即–chars，统计字符数 -w，即–words，统计字数 常用的目录操作命令 mkdir命令 用途：用来创建目录 用法：mkdir [选项] dirname 选项：-p，即–parents，可以一次建立多个目录，即如果为新建目录所指定的路径dirname中有些父目录尚不存在，此选项可以自动创建它们 如果要创建一个名字中带空格的文件夹，则使用mkdir &quot;a b&quot;或者mkdir a\ b rmdir命令 用途：可以从一个目录中删除一个或多个空的子目录 用法：rmdir [选项] dirname 改变工作目录和显示目录内容 cd命令 用途：用于改变工作目录 用法：cd [dirname] 几种用法： cd /绝对路径 ：cd命令可以跟一个绝对路径 cd ./相对路径 ：cd命令也可以跟一个相对路径 cd ：cd后什么都不加或者加一个空格，代表将工作目录改为用户主目录 cd ~ ：同上，代表跳回用户主目录 cd .. ：跳回上级目录，..代表上级目录 cd . ：跳回当前目录，其实相当于原地踏步。.代表当前目录 cd - ：后退一步，连续使用则会在两个工作目录之间来回跳转 关于路径的注意点：根目录的.和..是一样的；绝对路径一定是以根目录也就是/开头的 ※ls命令 用途：列出指定目录的内容 用法：ls [选项] [file] 选项： -a，即–all，显示指定目录下所有子目录和文件，包括以.开头的隐藏文件，包括.和.. -d，如果参数是目录，则只显示它的名字（不显示其内容）；往往与-l选项一起使用，以得到该目录本身的详细信息 -h，一般结合-l选项使用，使文件大小字段带有一个最合适的单位方便用户查看 -l，以长格式显示文件的详细信息，输出的信息分成多列，它们依次是：文件类型与权限 链接数 文件主 文件组 文件大小 建立或最近修改的时间 文件名，其中，链接数指的是硬链接数，文件组显示的是主组的名称，即文件所属的用户属于哪个组 例如：-rw-r–r– 2 mengqc group 809 12月 27 2008 myfile2 综上所述，ls -lha是一个很常用的命令，用于显示某个目录中所有文件的带单位的详细信息；并且，ls -l这个命令可以简写为ll ※关于ls命令中的10个表示文件类型与权限的字符头一个字符代表了文件类型，所用字符及含义如下： - 普通文件 d 即dir，目录文件 b 即block，块设备文件，一般是指能存储数据的，比如硬盘 c 即char，字符设备文件，一般是能够显示字符的，比如打印机和屏幕 l 即link，符号链接文件，也就是软链接 s 套接字文件（socket），一般网络编程会用到 p 命名管道文件（pipe），管道即”|” 随后的九个字符分为三组，每组3个字符，分别代表了三组权限：第一组代表文件所有者的读、写、执行权限；第二组表示同组用户的读、写、执行权限；第三组表示其他用户的读、写、执行权限，在权限部分会有详细讲解，其中 r 即read，读 w 即write，写 x 即execute，执行，对于目录文件则表示该目录可以访问 - 代表没有对应的权限 s 不常见 t 不常见 权限字段的组合中，rwxrwxrwx的限制是最少的，但是Linux系统中一般不会设置成这样 ln命令 用途：用来创建链接 用法：ln [选项] 源文件 [目标文件] 选项：-s，即–symbolic，建立符号链接而不是硬链接，如果要创建硬链接就不加-s ※改变文件或目录存取权限的命令chmod命令 用途：即change mode，用于改变或设置文件或目录的存取权限，但是只有文件主或超级用户root才有权用chmod命令改变文件或目录的存取权限 用法：改变文件权限有两种方法：文字设定法、数字设定法（常用） 文字设定法用法：chmod [who] [+|-|=] [mode] filename 例如：chmod o + r file.txt是为其他用户增加file.txt文件的读权限 操作对象who可以取的值有： u，表示“用户（user）”，即文件或目录的所有者； g，表示“同组（group）用户”，即与文件属主有相同组ID的所有用户； o，表示“其他（others）用户”； a，表示“所有（all）用户”，它是系统默认值（a=u+g+o） 操作符号可以是： +，即添加某个权限； -，即取消某个权限； =，即赋予给定权限并取消其他所有权限（如果有的话）； mode所表示的权限可以是下述字母的任意组合： r，可读；（对于目录r权限表示可以用ls命令查看内容） w，可写； x，可执行（或可搜索目录）；（对于目录x权限表示进入权限，即能够对该目录使用cd命令） X，只有该目标文件是目录文件或对某些用户有可执行权限时，才有“可执行/搜索”属性 s，在文件执行时，把进程的属主或组ID置为该文件的文件属主。方式u+s设置文件的用户ID位，g+s设置组ID位 t，受限删除标志或粘着位，即程序的文本保存到交换设备上 u，与文件属主拥有一样的权限； g，与和文件属主同组的用户拥有一样的权限； o，与其他用户拥有一样的权限； 例题 $ chmod a-x mm.txt、chmod -x mm.txt、$ chmod ugo-x mm.txt这三种形式均为为所有用户取消对mm.txt文件的执行权限 $ chmod ug+w,o-x text 为文件所有者和同组用户添加可写权限，为其他用户取消可执行权限 $ chmod a+x sort 为所有用户添加sort文件的执行权限 $ chmod a=rx sort 直接指定权限为r,x ※数字设定法（常用） 0 表示没有权限 1 表示可执行，即x，对目录表示可进入权限，也就是可以对该目录使用cd命令 2 表示可写权限，即w 4 表示可读权限，即r，对于目录表示可以使用ls命令查看该目录的内容 用法：将数字相加则表示文件的权限 例如：读、写权限即为4+2=6（读/写） 通常有了r，即读权限才能有其他权限例题： $ chmod 644 mm.txt $ chmod 750 wch.txt 上述例题中的三个数字分别对应着u、g、o用户 Linux系统有2种用户，3类人，3种权限其中，2种用户指的是root用户及其他用户；3类人指的是user，group，other；3种权限指的是读权限r、写权限w、执行权限x。 linux命令行中文件的颜色白色 —— 普通；蓝色 —— 目录；绿色 —— 可执行；红色 —— 压缩文件；浅蓝色 —— 链接文件；红色闪烁 —— 链接的文件有问题；黄色 —— 设备文件；灰色 —— 其他文件； 课外知识补充计算机概括来讲可以分为几个部分硬件、软件、固件。软件分为几类：系统软件、支撑软件、应用软件。固件是安装在硬件（比如主板内）上的软件，它引导操作系统的运行。它可以完成比如开机时显示厂商的界面和设置启动顺序等的界面等。 计算机的几种状态关机；休眠：windows将内存中的文件生成镜像文件存放在一个.sys文件中；Linux系统将内存中的文件生成镜像放入交换空间中，如果交换空间大小小于内存的大小，则不支持这种模式；休眠后执行关机操作，再开机时会直接读取镜像。睡眠：可唤醒的状态。 BIOSBIOS即Basic Input Output System，基本输入输出系统。BIOS负责在系统通电时进行自检并且找到引导程序grub，grub再去硬盘上找到系统内核kernel。tips：为什么引导程序普遍使用grub而不使用Lilo：因为Lilo要求内核必须放在硬盘的1024柱前面。 区别内存与外存最直接的方法断电后数据丢失的就是内存，而断电后数据仍旧可以保存的则是外存。用这种方法可以明显得知，现在普遍流传的“手机内存”的叫法其实是错误的。 安装多系统时的安装顺序低版本→高版本，Windows→Linux。而lilo（或grub）负责多系统的引导，应当最后安装到MBR（分区表）中。 关于文件系统ISO9660 —— 光盘文件系统，其中除了存储的数据之外还有其他信息，夹带了这些信息可以用于防盗版，因为这样软件只能通过光盘安装，单纯的复制文件光盘中的内容是无法安装的。而.iso文件就相当于虚拟光盘，需要虚拟光驱来运行。FAT32 —— 此种文件系统不支持超过4G的文件，常应用在手机存储卡，win98，U盘等。NTFS —— 即NT FIle System（NT文件系统），是windows系统常用的文件系统。 windows系统相关 windows系统的内核：windows NT windows使用的文件系统：NTFS也就是NT File System Linux系统版本 Fedora是红帽9.0后可以免费使用的发行版，而rhel是9.0后为企业准备的发行版。 Android内核使用的是Linux系统 系统调用是操作系统内核与用户程序、应用程序之间的接口。在Unix/Linux系统上，系统调用以C函数的形式出现，比如用于打开一个文件的open函数。结构如下图： 服务器的内存泄漏指服务器上运行的软件不释放内存，因为服务器上运行的软件都是不经常关闭的，最后程序占用的内存会越来越大，导致内存泄漏。 其他 1752年9月没有3号-13号]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目架构学习]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[好的前端工程师和架构师一定是对数据非常敏感的，通过数据可以为用户提供更好的体验。 好的目录组织是一个好的架构的开始。每个目录要做什么事情一定要让它职责分明。除了目录组织的架构之外还有页面组织的架构。views中存放的都是视图代码，views中除了放一些页面之外，还可以将页面都共有的部分放到views/includes文件夹中，然后在其他页面中引入这些视图文件。视图页面一般不会有太复杂的逻辑关系，基本只有包含与被包含的关系，因此include中只需要平行摆放这些组件即可。当然，如果你的项目十分庞大，比如一个登录模块就有几十种，那么可以再使用文件夹来区分他们。 更高级一些的架构设计则包含了组件化和设计模式。这方面主要针对js代码，因为html和css的逻辑性并不是很强。Js中的继承和Extend是Js抽象的基础，因为js不像其他面向对象语言一样与生俱来这些功能。 Extend比如浅拷贝（适用于基本数据类型），深拷贝（使用于引用数据类型）。浅拷贝与深拷贝其实就是一个抽象出来的extend函数，使子元素具有父元素的属性。对于基本数据类型来说，就是循环复制父元素中的元素。 js中的继承，一特有的方式就是原型链继承。 划分命名空间，前端模块拆分的最基本的形式可以认为是闭包的一种应用，但是这种方式对于命名空间的管理过于随意。闭包有一个问题就是在闭包内声明的变量会常驻在内存中，因此要避免在闭包内声明过于大的变量。其实在实际项目中不会大规模的使用js的继承和扩展，一是因为项目逻辑一般不会那么复杂，二是因为一些类库为我们提供了便利，比如jQuery就提供了一个封装好的extend方法。 常用的是组件化，比如一个弹出窗口可以做成一个组件。我们可以使用开源框架来完成最终的组件的组织和管理，例如requirejs/seajs，这两个框架遵循了两种规范，一个是cmd规范，一个是amd规范，cmd指明模块是按需加载的，即依赖就近；amd则是依赖关系前置，即使用一个依赖于a,b,c三个模块的组件时，如果使用这个组件会先加载这三个模块，不管这三个模块在组件初始化的过程中用没用到。 模块化框架基本只用到两个方法，一个是define，也就是定义一个模块；一个是require，也就是使用一个模块。 前端工程师拿到交互图时应该已经能大致想到整个网站的架子是什么样的，一定要统观全局一定要考虑有哪些部分是公用的，考虑一下如何抽象出来，也就是组件化开发。 当设计图出炉后，应该考虑到api的对接，虽然不能做到百分百精确，但要有一个大概的规划要明确哪部分是静态的，哪部分是动态的，并与后台负责人员进行讨论。 通常来讲首页的性能会影响到用户的留存率，因此首页一定要认真考虑性能方面的问题。前端项目目录结构创建一个静态目录，其中包括一个css文件夹，一个js文件夹。css文件夹中可以有module文件夹，其中的css文件用于组件，如dialog.js；可以有include文件夹，其中的css用于页面公用部分，如header.css，footer.css等；可以有一个release目录，用于打包之后的文件存放在这里；css文件夹下可以有一个package.json文件来书写打包规则。script文件夹中可以存放页面的js文件，比如common.js；可以有一个widget目录，其中存放一些组件的js；可以有一个release目录，用于打包之后发布在这里；script文件夹下可以有一个package.json文件来书写打包规则。图片文件分两种情况，一种是网站上的静态图片，可以在css文件夹下面创建一个img文件夹，用于存放这些静态图片，但是不要存放太多否则会影响性能；另一种是动态读取的图片，通常是放到服务器上的。 开发实现流程规范 切图 从页面结构上来考虑，把页面中的公用部分抽象出来 从css文件上来考虑，抽象出一些公用的css，比如reset.css等 可以使用地址来访问css文件 如果前端工程要抽象出模板，那么可以有一套模板对开发者友好，有一套模板对用户友好，对用户友好的模板就可以通过自动化工具打包生成 模板用一个更简洁的形式把页面组装出来展示给用户]]></content>
      <categories>
        <category>思想</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基础学习笔记]]></title>
    <url>%2F2018%2F04%2F14%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础less只是一种方便程序员编写的工具，最终引用的还是css文件。可以使用软件koala进行编译，也可以使用一些IDE设置进行自动编译。 Less中的注释CSS提供 /*这个注释在Less被编译为css文件的时候会被编译*/形式的注释，而LESS又多提供了一种//这种注释不会被编译注释。 Less中的变量Less中使用@开头来声明变量，如@test_width:300px;调用时：123.box&#123; width:@test_width&#125; Less中的混合混合也就是可以将声明的一个class直接放到另一个class内部。1234567.box&#123; width:@test_width; .border;&#125;.border&#123; border:solid 5px pink;&#125; 会被编译为1234.box&#123; width:@test_width; border:solid 5px pink;&#125; 混合是可以带参数的。123456.border_02(@border_width)&#123; border: solid yellow @border_width;&#125;.test_hunhe&#123; .border_02(30px);&#125; 会被编译为123.test_hunhe&#123; border:solid #ffff00 30px;&#125; 混合的参数是可以有默认值的。123456.border_03(@border_width: 10px)&#123; border: solid gr een @border_width;&#125;.test_hunhe_03&#123; .border_03();//这里使用10px的默认值，如果要变动传一个新值即可，这个括号不能丢&#125; 混合很常用的一个地方就是在边框圆角，我们知道css设置border_radius是需要兼容的。因此可以像下面这样使用：12345678910.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 40px; .border_radius(10px);//默认是5px但这里不使用默认值改为10px&#125; 这样，每次只要调用一下border_radius并传入参数即可。 Less中的匹配模式使用CSS写三角：12345678.sanjiao&#123; width: 0; height: 0; overflow: hidden; border-width: 10px; border-color: transparent transparent red transparent;/*是个向上的三角*/ border-style: dashed dashed solid dashed; /*其实只写一个solid即可，但ie6上solid会显示出一个黑色的正方形，因此指定一个边为solid，另外均为dashed即可*/&#125; 使用匹配模式写三角：1234567891011.triangle(top,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: transparent transparent red transparent; border-style: dashed dashed solid dashed;&#125;.triangle(bottom,@width:5px,@color:#ccc)&#123; border-width: @width; border-color: red transparent transparent transparent; border-style: solid dashed dashed dashed;&#125; 此时使用123.sanjiao&#123; .triangle(top);/*这样即可指定画出向上的三角，即第一个triangle*/&#125; 匹配模式中还提供了一个方法，可以指定所有参与匹配模式的样式共同的部分：123456.triangle(@_,@width:5px,@color:#ccc)&#123;/*后边的不可以省略*/ width: 0; height: 0; overflow: hidden;&#125;//不管匹配到谁，这段代码都会被编译出来 匹配模式用于定位：12345678910111213.pos(r)&#123; position: relative;&#125;.pos(a)&#123; position: absolute;&#125;.pos(f)&#123; position: fixed;&#125;.test&#123; width: 200px; .pos(a);&#125; 其实这样匹配模式看来有些类似于Java中的多态。 Less中的运算比如123456@test_01: 300px;.box_01&#123; width: (@test_01 + 20) * 5;//因为@test_01带有了单位px，因此后边的20和5可以不需要带单位。&#125;//Less规定一个式子中只要有一个数字带了单位，其他的数字便会自动转化。 Less中的颜色也是可以加减的，但一般不会用到。 Less中的嵌套比如有下面这样的一段html代码1234567&lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这里是测试文字&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 如果是平时写css，可能会用以下方式来规定样式：1234.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125; 但如果使用了Less中的嵌套，就会变成下面这样：12345678910111213.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125;&#125; 此时a的样式可以写在两个位置，第一种写法是a被li包裹在里面，和html结构完全一致：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; a&#123; float:left; &#125; &#125;&#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list li a &#123; float:left;&#125; 第二种写法是a与li同级：1234567891011121314151617.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px; &#125; a&#123; float:left; &#125; &#125; 这种写法会被编译成：123456789101112131415.list&#123; width: 600px; margin: 30px auto; padding: 0; list-style: none;&#125;.list li&#123; height: 30px; line-height:30px; background-color:pink; margin-bottom: 5px;&#125;.list a &#123; float:left;&#125; 因为.list li a的匹配次数会多于.list a，因此我们提倡将a写为与li同级。 关于嵌套还有一个例子，就是css中常见的a:hover，原本的写法是：12.list a&#123;&#125;.list a:hover&#123;&#125; 现在可以写为：12345678910.list &#123; ... a &#123; ... &amp;:hover&#123; color:red; &#125; &#125;&#125; &amp;符号代表的是上一层的选择器，在这个例子中指代的就是a如果html结构上有两个class是互相嵌套的，比如外层调用class为title，内层调用的class为title_nav，则可以在嵌套中使用&amp;_nav来代表title_nav。 Less中的@arguments变量@arguments变量用的其实不是特别特别多，它包含了所有传递进来的参数，如果不想单独处理每个参数的时候就可以这样写。比如：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg();&#125; 此时arguments会自动匹配所有参数，也就会编译成：123.test_arguments&#123; border: 30px #ff0000 solid;&#125; 如果稍加修改：123456.border_arg(@w:30px,@c:red,@b:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg(40px);&#125; 则此时arguments也会自动执行对应的更改，即会编译成：123.test_arguments&#123; border: 40px #ff0000 solid;&#125; 这就是arguments，如果一个属性的值全部都要改动的时候可以这样使用。 Less的避免编译有时候我们需要输出一些不正确的CSS语法或者使用一个Less不认识的专有语法，要输出这样的值我们可以在字符串前面加上一个~。比如CSS3中的滤镜，calc函数等都可能遇到这种情况，示例如下：123.test_03&#123; width: calc(300px - 30px);&#125; 此时会直接编译成：123.test_03&#123; width: calc(270px);&#125; 这种情况就是，我们本意是想要浏览器来计算这个值的，可是现在被Less直接计算了，此时就可以使用避免编译，让Less不要进行计算，留给浏览器计算。代码如下：123.test_03&#123; width: ~&apos;calc(300px - 30px)&apos;;//单引号双引号都行&#125; 此时会编译为：123.test_03&#123; width: calc(300px - 30px);&#125; 一般用于CSS3中的calc或滤镜，避免软件出现一些不必要的错误，或者执行一些不必要的运算。 !important关键字css中的important是让样式的优先级最高。Less中的混合模式实际上也可以加important关键字。比如之前写过的border_radius，我们可以为它加上important关键字：12345678.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.test_important&#123; .border_radius()!important;&#125; 这样可以编译为：12345.test_important&#123; -webkit-border-radius: 5px !important; -moz-border-radius: 5px !important; border-radius: 5px !important;&#125; 这个可以在调试的时候使用，一般是不要用important关键字比较好。 Less中的导入使用@import &quot;less&quot;会导入less.less文件，可以用加拓展名使用@import (less) &quot;a.css&quot;会导入a.css文件的样式，注意导入css的时候这句import写在哪，编译的时候a.css中的样式就会出现在哪，因此如果要让它在最前面就要把import写在最前面。如果写成@import &quot;a.css&quot;，则less不会将里面的样式内容拿出来，编译为css文件的时候会编译为一个导入的css即css文件中的@import &quot;a.css&quot;。因此需要使用(less)对它进行转换。 其他小知识点补充 如果子元素浮动，父元素必须清楚浮动才能有高度，否则父元素高度为零。一定要注意！ 使用CSS父元素清除浮动： 12345678.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; 这样再在父元素上调用clearfix类即可。 如果是在Less中，则代码如下： 12345678.clearfix&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix; 这种写法编译css文件的时候会吧clearfix编译出来，如果不想这样做可以写成以下方式： 12345678.clearfix()&#123; &amp;:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; zoom: 1;&#125; 然后在父元素的类中调用.clearfix();，其实父元素加不加括号都可以，这样做只是为了能够方便区分这里到底是个混合还是单纯引入了一个css。 兼容IE6的清除浏览器自带样式的方式： 1234*&#123;margin:0;padding:0;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration: none;&#125;img&#123;border:none;&#125;//因为ie6下图片默认是有边框的 使用less还可以将浮动写为： 12345678.fl(@fl:left)&#123; float: @fl; display: inline;&#125;.fr(@fr:right)&#123; float: @fr; display: inline;&#125; 调用时使用.fl()或.fr()调用即可]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F14%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础操作部分初始化git init 将修改提交到暂存区git add tips：使用git add .可以将当前工作区中的所有存在修改的文件一次性全部提交到暂存区 将暂存区提交到版本库git commit -m “commit message” 跳过暂存区，直接把工作区的修改提交到版本库git commit -a -m “commit message” 查看工作区状态git status 查看工作区修改内容，也就是查看工作区与暂存区的区别git diff 恢复到指定id的版本git reset -hard 查看提交历史git log 查看格式化后的提交历史git log –pretty=oneline 可以查看所有分支的所有操作记录（包括提交、回退、已删除的提交操作记录等）git reflog 查看工作区和版本库里面最新版本的区别git diff HEAD –reaadme.txt 切换分支或恢复工作树文件git checkout 切换到一个指定分支： git checkout 分支名称 创建并切换到新的分支中： git checkout -b 分支名称 撤销修改： git checkout – 一种情况是文件修改后还没有放到暂存区，此时撤销修改也就是回到了版本库中的状态。即，上一次git commit后，修改了文件，但没有执行git add，回到上一次git commit时的状态。 第二种情况是文件已经添加到了暂存区，又做了修改，此时撤销修改就回到了添加到暂存区时的状态。即，修改了文件，并且执行了git add，然后又修改了文件，此时会撤销到git add时的状态。 撤销暂存区的修改，但不修改工作区git reset HEAD 从版本库中删除文件git rm 远程仓库部分创建SSH Keyssh -keygen -t rsa -C “email@mail.com“ 创建与远程仓库的关联git remote add origin git@github.com:Fnine59/project_name.git tips: origin是远程仓库的名字 把本地库的所有内容都推送到远程库git push -u origin master tips: 第一次推送master分支时加上-u参数，则不仅会将本地的master分支推送到远程仓库中的master分支，还会将它们相互关联起来，这样以后推送或拉取时就可以简化命令了。 从远程仓库克隆项目git clone git@github.com:Fnine59/project_name.git (SSH协议形式) git clone https://github.com/Fnine59/project_name.git (HTTP协议形式) 从远程仓库拉取数据git fetch 查看远程仓库信息git remote git remote -v (查看远程库的详细信息) git remote show (更详细一些) 远程仓库重命名git remote rename 分支操作部分分支操作规范1234567master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 创建并切换到example分支git checkout -b 查看分支git branch 创建example分支git branch 切换到example分支 git checkout 合并指定分支到当前分支git merge 删除example分支git branch -d 查看分支的合并情况git log –graph –pretty=oneline -abbrev -commit 查看分支合并图git log –graph 采用普通模式合并指定分支到当前分支git merge –no-ff -m “使用普通模式合并分支” 本地分支操作部分保存工作区现场，操作完其他后可以恢复工作区继续工作git stash 恢复保存的工作区现场，但是恢复后不删除stash内容git stash apply 删除保存的工作区现场git stash drop 恢复保存的工作区现场，同时删除stash内容git stash pop 强行删除分支git branch -D 远程分支操作部分将master分支推送到远程库对应的远程分支git push origin master 从远程仓库抓取分支git pull 建立本地example分支和远程example分支的关联git branch –set -upstream origin/ 标签操作部分新建标签git tag 根据提交的id创建带说明的标签git tag -a -m “tag message” commit id 查看所有标签git tag 查看的标签信息git show 推送一个本地标签到远程仓库中git push origin 推送本地所有未推送过的标签到远程git push origin –tags 删除标签git tag -d 删除远程标签git push originn :refs/tags/ 文件恢复从暂存区恢复文件到工作区可以使用 git checkout . 或 git checkout --&lt;file&gt;命令 从版本库恢复文件到工作区和暂存区使用 git checkout HEAD . 或 git checkout HEAD &lt;file&gt;命令，会从HEAD指向的master分支中的全部或部分文件来替换暂存区以及工作区中的文件 从版本库恢复提交到暂存区git reset –soft 从版本库恢复提交到暂存区和工作区，等同于checkout HEAD .git reset –hard]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%85%B3%E4%BA%8EJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Class类的使用Java中其实有两种东西不是对象，一个是普通的数据类型（但有包装类来弥补了），另一个是Java中静态的成员。Java中的类其实也是对象，它是java.lang.Class类的实例对象。 既然任何一个类都是Class类的实例对象，那么Class类的实例对象应该如何表示呢？ 通过查看Class类的源代码可以知道，它具有一个私有的构造方法，在类的外部无法直接调用。因此我们无法使用new关键字来直接表示Class类的实例对象。 现假设有一个类名为Foo的类，并且通过new关键字实例化了一个Foo类的对象foo1，现有三种表示方式来表示这个Class类的实例对象Foo： * `Class c1 = Foo.class;` 这种表示方式实际在告诉我们任何一个类都有一个隐含的静态成员变量class。 * `Class c2 = foo1.getClass();` 已经知道该类的对象，通过getClass方法获取 * `Class c3 = null; c3 = Class.forName(&quot;com.fnine59.reflect.Foo);` * 根据官网的解释，**c1，c2表示了Foo类的类类型（class type）**，证明万事万物皆对象，类也是对象，是Class类的实例对象，这个对象我们称为该类的类类型。 * **不管用c1，c2或c3哪种表达方式都表示了Foo类的类类型，它们是相等的，因为一个类只能是Class类的一个实例对象。** 我们完全可以通过类的类类型来创建该类的对象实例，即通过c1或c2或c3来创建Foo类的实例。可以使用Foo foo = (Foo)c1.newInstance();来创建Foo类的实例。这种办法需要该类有无参的构造方法。 Java动态加载类编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（DOM篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88DOM%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建节点与属性处理 $(&quot;html结构&quot;)可以创建出来，例如$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)，如果要指定属性，则$(&quot;&lt;div id=&#39;test&#39; class=&#39;aaron&#39;&gt;我是文本节点&lt;/div&gt;&quot;)即可。 DOM内部插入append()与appendTo() .append(content)向每个匹配id元素内部追加内容 .appendTo(content)把所有匹配的元素追加到另一个指定的元素集合中 这个方法可以使得创建的新节点显示在文档中，将新创建的元素当作页面某一个元素的子元素放到其内部即可。 append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。 appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。 区别：append()前面是被插入的对象，后面是要在对象内插入的元素内容；appendTo()前面是要插入的元素内容，而后面是被插入的对象 DOM内部插入prepend()与prependTo() .prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素。 .prependTo()方法把所有匹配的元素前置到另一个指定的元素集合中。 DOM外部插入after()与before() 内部插入着重于节点之间的父子、祖辈关系；而外部插入着眼于节点之间的兄弟关系。 .after(content)方法在匹配元素集合中的每个元素后插入参数指定的内容，作为其兄弟节点。 .before(content)方法按参数设定，在匹配元素的前面插入内容。 DOM外部插入insertAfter()与insertBefore() .insertBefore()方法在目标元素前面插入集合中每个匹配的元素 .insertAfter()方法在目标元素后面插入集合中每个匹配的元素 注意：after和before方法都是将要插入的内容作为参数，而insertBefore和insertAfter方法则相反，要插入的内容在方法前面。 删除节点 empty() empty方法用于清除指定元素中的所有子节点 remove() remove方法与empty方法一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 remove方法可以传参，比如$(&quot;p&quot;).remove(&quot;:contains(&#39;3&#39;)&quot;)，意思是找到所有p元素中，包含了3的元素，这个也是一个过滤器的处理。可以通过类似于$(&quot;p&quot;).filter(&quot;:contains(&#39;3&#39;)&quot;).remove()的方式进行处理。 detach() 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理。 可以使用一个变量接收detach方法的返回值，当执行完detach方法后会移除对象，但仅仅是显示效果没有了，在内存中还是存在的，可以使用append(刚才接收返回值的变量)将元素重新放回文档流中。这时可以发现该元素绑定的事件仍然生效。 DOM拷贝clone() clone方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 注意：如果节点有事件或者数据之类的其他处理，我们需要通过clone(true)传递一个布尔值true用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。 clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色。 DOM替换replaceWith()和replaceAll() .replaceWith(newContent)用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。 .replaceAll(target)用集合的匹配元素替换每个目标元素。 注意：这两个方法都会删除与节点相关联的所有数据和事件处理程序。 DOM包裹 wrap()方法 .wrap(wrappingElement)在集合中匹配的每个元素周围包裹一个HTML结构 .wrap( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。使用后的效果与直接传递参数是一样的，只不过可以把代码写在函数体内部，写法不同而已。 unwrap()方法 这个方法与wrap的方法是相反的，将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在的话）在原来的位置。 wrapALl()方法 .wrapAll(wrappingElement)：给集合中匹配的元素增加一个外面包裹的HTML结构。 这个方法同样有.wrapALl(function)的写法，通过回调的方式可以单独处理每一个元素，等同于wrap的处理。 wrapInner()方法 .wrapInner(wrappingElement)：给集合中匹配的元素的内部增加包裹的HTML结构。 例子： 12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 给所有元素增加一个p包裹 1$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;) 最后的结构 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 此方法也有.wrapInner( function )的写法，允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行并返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。效果等同于第一种处理。 jQuery的遍历 children()方法 用于快速查找元素合集里面的第一级子元素。由于jQuery是一个合集对象，所以通过children是匹配合集中每一个元素的第一级子元素。同时也因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，因此允许传一个选择器的表达式。比如$(&#39;.div&#39;).children(&#39;:last&#39;)。 find()方法 find是遍历当前元素集合中每个元素的后代，不仅是儿子，祖孙辈也可以。 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 *。 find只在后代中遍历，不包括自己。 parent()方法 用于快速查找合集里面每一个元素的父元素。 jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素。同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 parents()方法 用于快速查找合集里面每一个元素的所有祖辈元素。 也有无参或带参两种使用方法。 closest()方法 该方法从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。closest()方法接受一个匹配元素的选择器字符串。 与parents方法类似，但还是有些区别： 起始位置不同：.closest开始于当前元素 .parents开始于父元素 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 next()方法 用于快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合。 next()无参数：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素。 next()方法选择性地接受同一类型选择器表达式： 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。 prev()方法 用于快速查找合集里面每一个元素紧邻的前面同辈元素的元素集合。 prev方法也有无参和有参两种用法。 siblings()方法 用于快速查找指定元素集合中每一个元素的同辈元素 此方法也有也有无参和有参两种用法。 add()方法 用来创建一个新的jQuery对象，元素添加到匹配的元素集合中。 each()方法 .each()方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始计数）。 例子： 1234&lt;ul&gt; &lt;li&gt;慕课网&lt;/li&gt; &lt;li&gt;Aaron&lt;/li&gt;&lt;/ul&gt; 以上是结构，现在开始迭代li，循环2次···$(“li”).each(function(index, element) { //index 索引 0,1 //element是对应的li节点 li,li //this 指向的是li //如果需要提前退出，可以以通过返回 false以便在回调函数内中止循})`]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记整理（基础篇）]]></title>
    <url>%2F2018%2F03%2F31%2FjQuery%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[jQuery版本进入官方网站获取最新的版本http://jquery.com/download/，这里需要注意 jQuery 分 2 个系列版本 1.x 与 2.x，主要的区别在于 2.x 不再兼容 IE6、7、8浏览器，这样做的目的是为了兼容移动端开发。由于减少了一些代码，使得该版本比 jQuery 1.x 更小、更快。 $(document).ready 等页面的文档(document)中的节点都加载完毕后，再执行后续代码。 jQuery对象和DOM对象的转换 jQuery-&gt;DOM：jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。可以利用数组下标的方式读取到jQuery中的DOM对象。 DOM-&gt;jQuery：如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象。通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了。 选择器 id选择器 语法：$( &quot;#id&quot; ) 注意：id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的。 类选择器 语法：$( &quot;.class&quot; ) 元素选择器（根据给定的标记名称选择所有的元素） 语法：$( &quot;element&quot; ) 全选择器 语法$( &quot;*&quot; ) 层级选择器 &gt; （大于号）紧跟父子关系 如$(“div &gt; p”)表示选择div下的直接层是p的节点。 + （加号） 紧跟兄弟关系 如$(“div + p”)表示选择div同层的左右相邻的p节点。 ~ （波浪线）任意距离兄弟关系 如$(“div ~ p”)表示选择div同层的p节点。 （空格） 任意层父子关系 如$(“div p”)表示选择div下的p节点（不管中间隔多少层）。 , （逗号） 表示选择器组合，如$(“div p, span p”)表示div下p节点和span下p节点。 基本筛选选择器 注意jQuery合集都是从0开始索引 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 可见性筛选选择器 $(&quot;:visible&quot;) 选择所有显示的元素 $(&quot;:hidden&quot;) 选择所有隐藏的元素 注意：:hidden选择器，不仅仅包含样式是display=”none”的元素，还包括隐藏表单、visibility等等。 隐藏一个元素的方法有以下几种 CSS display的值是none type=”hidden”的表单元素 宽度和高度都显式设置为0 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的指是0 属性筛选选择器 属性选择器让你可以基于属性来定位一个元素，可以只指定该元素的某个属性，这样所有使用该属性而不管它的值，这个元素都将被定位，也可以更加明确并定位在这些属性上使用特定值的元素。 描述如下： 在这么多属性选择器中[attr=&quot;value&quot;]和[attr*=&quot;value&quot;]是最实用的，[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等。[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件。 表单元素选择器 具体方法描述： 注意：除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。因此大部分表单类别筛选器可以使用属性筛选器替换。比如 $(&#39;:password&#39;) == $(&#39;[type=password]&#39;) 表单对象属性筛选选择器 具体方法描述： 注意：选择器适用于单选框和复选框，对于下拉框元素应该使用:selected选择器。在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素。 特殊选择器this **this和$(this)的区别： this是JavaScript中的关键字，指的是当前的上下文对象，简单地说就是方法/属性的所有者。 $(this)：通过把$()方法传入当前的元素对象的引用this，把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法直接处理样式了。 总结来说，this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 jQuery的属性与样式 .attr()与.removeAttr() .attr() attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } .removeAttr()删除方法：为匹配的元素集合中的每个元素中移除一个属性（attribute） 注意区分Attribute和Property的概念，property是DOM中的属性，是JavaScript里的对象，例如tagName，nodeName，nodeType，defaultChecked，和 defaultSelected等；而attribute是HTML标签上的特性，它的值只能够是字符串；例如html中常用的id、class、title、align等。 获取Attribute就需要用.attr()，获取Property就需要用.prop() .html()与.text() .html()方法获取集合中第一个匹配元素的html内容，或者设置每一个匹配元素的html内容，具体有3中用法如下： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 注意：因为.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） .text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .text()结果返回一个字符串，包含所有匹配元素的合并文本 .val() .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function )，一个用来返回设置值的函数 .html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 .addClass()与.removeClass() .addClass()方法通过动态改变类名（class），可以让其修改元素呈现出不同的效果。用法如下： .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ): 这个函数返回一个或更多用空格隔开的要增加的样式名 注意：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上。 .removeClass()方法从匹配的元素中删除全部或者指定的class，用法如下： .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) )： 一个函数，返回一个或多个将要被移除的样式名 注意：如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。 .toggleClass()样式切换 通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass。用法如下： .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名。 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意：toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加。并且，toggleClass会保留原有的Class名后新增，通过空格隔开。 .css() 用于获取元素样式属性的计算值或者设置元素的CSS属性。用法如下： 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 通过.css方法设置的样式属性优先级要高于.addClass方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记及技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面马上要面试了，重新温习一下基础，把慕课网上的前端工程师课程走了一遍，整理了一些平时不太注意到的、或是个人印象不够深刻的JavaScript相关知识，希望可以巩固一下自己的印象。也能保证自己随时可以查看这些笔记。 关于大小写JS是大小写敏感的 document.write()直接向HTML输出流写内容，也将就是直接在网页中输出内容。如果要使用write方法输出一个HTML标签，则要使用&quot;&quot;将标签扩起来。 confirm对话框alert()对话框经常被用于调试程序，它包含一个确定按钮。而confirm对话框包括一个确定按钮和一个取消按钮，通常用于允许用户做选择的动作，语法为confirm(str);。confirm的返回值，当用户点击“确定”按钮时，返回true；当用户点击“取消”按钮时，返回false。可以定义一个变量来接收confirm的返回值。 prompt消息对话框除了上述两种对话框，还有一种prompt消息对话框。它通常用于询问一些需要与用户交互的信息。弹出的消息对话框包括一个确定按钮，一个取消按钮和一个文本输入框。语法为prompt(str1, str2);，其中str1是要显示在消息对话框中的文本，对用户来说是不可修改的；str2是文本框中的内容，用户是可以修改的。prompt的返回值，如果用户点击确定按钮，那么文本框中的内容将作为函数返回值；如果用户点击取消按钮，则返回null。 window.open()可以查找一个已经存在或者新建的浏览器窗口。语法window.open([URL], [窗口名称], [参数字符串]) window.close()用于关闭窗口。直接调用则关闭本窗口，使用&lt;窗口对象&gt;.close()则可以关闭指定的窗口。窗口对象可以是在打开窗口时建立一个变量进行存储。 Object.innerHTML用于获取或是替换HTML元素的内容。Object是获取的元素对象，比如通过document.getElementById(&quot;ID&quot;)获取的元素。 改变HTML样式使用Object.style.property = new style;来改变HTML元素的样式。注意，property是CSS样式属性，new style是属性的新值。 显示和隐藏语法：Object.style.display = value 控制类名（className属性）className属性设置或返回元素的class属性。语法：Object.className = classname 创建数组var arrayname = new Array()可以用来创建一个数组。创建的新数组是空数组，没有值，如输出，则显示undefined。并且，虽然创建数组时，指定了长度，但实际上数组都是变长的，也就是说即使指定了长度，仍然可以将元素存储在规定长度以外。 函数传参js属于弱类型语言，所以在定义方法传入参数的时候并不需要指定其类型。 事件 鼠标点击事件onmouseclick 鼠标经过事件onmouseover 鼠标移开事件onmouseout 光标聚焦事件onfocus 失去焦点事件onblur 内容选中事件onselect（当文本框或者文本域中的文字被选中时触发） 文本框内容改变事件onchange 加载事件onload（该事件在页面加载完成后立即发生，如果不使用js代码则写在body标签中） 卸载事件onunload（用户退出页面时触发，比如页面关闭、页面刷新等） 时间 Date日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000秒）。定义时间对象的语法为：var Udate = new Date() 日期对象提供了以下方法： 返回/设置年份方法get/setFullYear() getDay()返回星期（返回是0-6的数字，其中0表示星期天） get/setTime()返回/设置时间方法（单位为毫秒数，计算从1970年1月1日零时到日期对象所指的日期的毫秒数，即时间戳） 字符串对象 .length可以获取字符串对象的长度 toLowerCase()方法可以将所有大写字母都转为小写字母 toUpperCase()方法则可以将所有小写字母转换为大写字母 charAt()方法返回指定位置的字符 indexOf方法返回指定的字符串首次出现的位置 split()方法分割字符串为字符串数组并返回（两个参数，第一个参数separator必需，用来指定分隔符；第二个参数limit可选，用来指定分割次数） substring()方法用于提取字符串中介于两个指定下标之间的字符（指定开始位置的参数必需，指定结束位置的参数可选） substr()方法从字符串中提取从startPos位置开始指定书目的字符串，语法：stringObj.substr(startPos,length)，其中length可选，默认值到字符串结尾 Math对象 ceil()函数用于对一个数向上取整，返回的是一个大于或等于x并且与x最接近的整数，语法Math.ceil(x) 向下取整函数floor()，语法Math.floor(x)，返回的是一个小于或等于x并且与x最接近的整数 四舍五入函数round()，语法Math.round() 随机数random()，可以返回一个大于等于0但小于1的随机数，语法Math.random() 数组对象 concat()方法用于连接两个或多个数组，语法：arrayObject.concat(array1,array2...arrayN)此方法返回一个新数组，不改变原来的数组 join()方法用于把数组中的所有元素都放入一个字符串，元素是通过指定的分隔符进行分隔的，语法arrayObject.join(分隔符)，该方法返回一个字符串 reverse()方法用于颠倒数组中元素的顺序，该方法会改变原来的数组而不会创建新数组 slice()方法可以从已有的数组中返回选定的元素，语法arrayObject.slice(start,end)，其中start参数必需，end参数可选，默认到数组结束，该方法返回一个新的数组，包括从start到end（不包括end）的arrayObject中的元素，不会修改原有数组 sort()方法使数组中的元素按照一定的顺序排列，语法arrayObject.sort(方法函数名)，如果不规定方法函数，则按unicode码顺序排列，如果指定方法函数，则按方法函数所指定的排序方法进行排序，这个方法函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字，比较函数应该具有两个参数a和b，其返回值如下： 若返回值&lt;=-1，则表示a在排序后的序列中出现b之前 若返回值&gt;-1&amp;&amp;&lt;1，则表示a和b具有相同的排序顺序 若返回值&gt;=1，则表示a在排序后的序列中出现在b之后 计时器 计时器有两种： 一次性计时器，仅在指定的延迟时间之后触发一次 间隔性触发计时器，每隔一定的时间间隔就触发一次 setInterval()计时器执行时，从载入页面后每隔指定的时间执行代码，语法setInterval(代码, 交互时间);，其中，交互事件的单位是毫秒。 clearInterval()方法用于取消由setInterval()设置的交互时间，语法clearInterval(id_of_setInterval)，传入的id_of_setInterval是由setInterval()返回的ID值，可以使用一个变量来接收这个值。 setTimeout()计时器，在载入后延迟指定时间后，去执行一次表达式并且只执行一次，语法setTimeout(代码, 延迟时间);，其中延迟时间以毫秒为单位。 clearTimeout()计时器，和setTimeout()计时器一起使用，用于停止计时器，语法clearTimeout(id_of_setTimeout)，其中传入的id_of_setTimeout是由setTimeout()返回的ID值，可以使用一个变量来接收这个值。 History对象 history对象记录了用户曾经浏览过的页面（URL），并可以实现与浏览器前进和后退相似的功能。 注意：从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签乃至每个框架，都有自己的history对象与特定的window对象关联。 语法window.history.[属性|方法]，其中window可以省略。 属性：length，返回浏览器历史列表中的URL总数量。 方法： back()，用于加载history列表中的前一个URL。back()相当于go(-1)。 forward()，用于加载history列表中的后一个URL。forward()相当于go(1)。 go()，用于加载history列表中某个具体的页面，语法window.history.go(number);，其中number是指要访问的URL在history的URL列表中的相对位置，比如返回当前页面之后浏览过的第三个历史页面，number为3；返回当前页面之前浏览过的第二个历史页面，number为-2。 Location对象 location对象用于获取或设置窗体的URL，并且可以用于解析URL。 语法location.[属性|方法] location对象属性示意图： location对象方法： assign()，用于加载新的文档 reload()，重新加载当前文档 replace()，用新的文档替换当前文档 Navigator对象 navigator对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 语法navigator.属性 属性如下 userAgent 用于返回用户代理头的字符串表示，就是包括浏览器版本信息等的字符串 语法navigator.userAgent screen对象 screen对象用于获取用户的屏幕信息。 语法window.screen.属性 属性如下： window.screen对象还包含有关用户屏幕的信息 screen.height返回屏幕分辨率的高 screen.width返回屏幕分辨率的宽 注意，单位以像素计，window这个前缀可以省略。 availwidth和availHeight属性是可用的宽度和高度，会减去界面特性，如任务栏。 文件对象模型DOM getElementsByName()方法返回带有指定名称的节点对象的集合。 语法：document.getElement**s**ByName(name) 与getElementById()不同的地方在于这个方法使通过元素的name属性查询元素而不是通过id属性。 因为文档中的name属性有可能不唯一，所以这个方法返回的是元素的数组而不是一个元素。 getElementsByTagName()方法返回带有指定标签名的节点对象的集合，返回元素的顺序是它们在文档中的顺序。 语法document.getElement**s**ByTagName(Tagname) Tagname是标签的名称，如p，a，img等标签名。 getAttribute()方法通过元素节点的属性名称获取属性的值。 语法elementNode.getAttribute(name) elementNode是通过上述几个方法获取到的元素节点。 setAttribute()方法增加一个指定名称和值的性属性，或者把一个现有的属性设定为指定的值。 语法elementNode.setAttribute(name,value) 类似getAttribute()方法，此方法也是只能通过元素节点对象调用的函数。 节点属性： 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称，是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue ：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 nodeType ：节点的类型，是只读的。以下常用的几种结点类型 元素 -&gt; 1 属性 -&gt; 2 文本 -&gt; 3 注释 -&gt; 8 文档 -&gt; 9 childNodes用于访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，具有length属性。 语法elementNode.childNodes 如果选定的节点没有子节点，则该属性返回不包含节点的NodeList。 firstChild属性返回‘childNodes’数组的第一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.firstChild firstChild属性与elementNode.childNodes[0]效果相同。 lastChild属性返回‘childNodes’数组的最后一个子节点，如果选定的节点没有子节点，则该属性返回NULL。 语法node.lastChild lastChild属性与elementNode.childNodes[elementNode.childNodes.length-1]效果相同。 parentNode用于获取指定节点的父节点 语法elementNode.parentNode 父节点只能有一个 访问兄弟节点 nextSibling属性可以返回某个节点之后紧跟的节点（处于同一树层级中） 语法nodeObject.nextSibling 如果无此节点，则该属性返回null previousSibling属性可以返回某个节点之前紧跟的节点（处于同一树层级中） 语法nodeObject.previousSibling 如果无此节点，则该属性返回null 插入节点 appendChild()用于在指定节点的最后一个子节点列表之后添加一个新的子节点 语法appendChild(newnode) 例子： 1234var otest = document.getElementById(&quot;test&quot;);var newnode = document.createElement(&quot;p&quot;);newnode.innerHTML = &quot;This is a new p&quot;;otest.appendChild(newnode); 注意：应当由父节点来调用这个方法 insertBefore()方法用于在已有的子节点之前插入一个新的子节点 语法insertBefore(newnode,node); 例子： 1234var otest = document.getElementById(&quot;test&quot;); var newnode = document.createElement(&quot;li&quot;);newnode.innerHTML = &quot;PHP&quot;;otest.insertBefore(newnode,otest.firstChild); 注意：应当是父节点来调用这个方法，并定义在某个子节点之前插入新节点 删除节点 removeChild()方法用于从子节点列表中删除某个节点，如果删除成功，此方法返回被删除的节点，如果删除失败则返回NULL。 语法nodeObject.removeChild(node); 注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值，代码如下: 123var otest = document.getElementById(&quot;div1&quot;);var x = otest.removeChild(otest.childNodes[1]);x = null; 替换元素节点 replaceChild方法实现子节点（对象）的替换，返回被替换对象的引用。 语法node.replaceChild(newnode,oldnode) 注意，两个参数都是必须的，当oldnode被替换时，所有与之相关的属性内容都将被移除，并且newnode必须先被建立。 需要父节点调用这个方法，因此可以使用oldnode.parentNode.replaceChild(newnode,oldnode);来进行替换。 创建元素节点 createElement()方法可以创建元素节点，此方法可以返回一个element对象。 语法document.createElement(tagName); createTextNode()方法创建新的文本节点，返回新创建的Text节点。 语法document.createTextNode(data); 参数：data是字符串值，可以规定此节点的文本。 注意：innerHTML和createTextNode都可以把一段内容添加到一个节点中，区别是如果这段内容中有html标签（如例子中的）时表现就不同了，在createTextNode中会当作文本处理，不会被浏览器解析，但用innerHTML就会被当作HTML代码处理（如你的例子中Hello会被加粗显示）。 例子： 1234var element = document.createElement(&quot;p&quot;);var textnode = document.createTextNode(&quot;I love Javascript!&quot;);element.appendChild(textnode);document.body.appendChild(element); 浏览器窗口可视区域大小 获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法： 对于IE9+、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： 直接求 document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者Document对象的body属性对应HTML文档的标签 document.body.clientHeight document.body.clientWidth 在不同浏览器都实用的 JavaScript 方案： 12var w= document.documentElement.clientWidth(或 document.body.clientWidth);var h= document.documentElement.clientHeight(或 document.body.clientHeight); 网页尺寸 scrollHeight和scrollWidth，分别用于获取网页内容的高度和宽度 针对IE、Opera:scrollHeight 是网页内容实际高度，可以小于 clientHeight。 针对NS、FF:scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 浏览器兼容写法 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写。并且，scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 offsetHeight和offsetWidth，分别用于获取网页内容的高度和宽度（包括滚动条和等边线，会随窗口的显示大小改变） 值：offsetHeight = clientHeight + 滚动条 + 边框。 浏览器兼容性1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; height、clientHeight、scrollHeight、offsetHeight区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技巧整理]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于Node.js Node.js适合高并发、低负载、弱逻辑的项目，适合做如dataAPI或聊天系统等实时性要求比较高的项目。 关于HTML 渲染顺序 HTML文档是从上向下渲染的，因此同一区块有些不重要的内容可以适当往后放，让重要内容先被加载出来（本条是对于结构来讲，也就是对于HTML语言来讲，不涉及表现CSS或行为JS）。 结构与表现分离 前端开发时要注意结构与表现分离，在编写前端页面的过程中，要先从结构考虑，争取做到结构最简，避免有过多不必要的div。当结构编写完后，再考虑表现，也就是CSS样式。通过这种结构与表现分离的思想，争取做到修改业务逻辑时，只需要改动样式，而不需要改动结构。 如何让一段文本向右移动？ 当然可以采取margin或padding的形式将文字元素推到右边，但这样做会造成外部容器的宽度发生变化，就需要再次修改外部容器的宽度。此时，最理想的操作方法应该是使用text-indent属性，来设置文本缩进，它不会影响外部容器的宽度，也可以设置百分比，简洁易用。 背景图片 元素的背景，比如导航栏圆角背景，可以将普通状态下的背景（如灰色）与hover状态下的背景（如橙色）做在同一张图上，上下排列并掌握好宽和高。这样可以给默认状态下的导航栏菜单项（即display属性值为block的a标签）设置这张背景图，通过长宽来确保背景为灰色。当该菜单项处于hover状态或选中状态时，添加class并设置该菜单项的background-position属性，来使背景图向上移动，显示出之前拼接好的橙色背景来。 导航栏的制作 导航栏的结构均为&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;这样的无序列表，如果是竖向导航栏则无需float，如果是横向导航栏则可以设置li标签的float属性的值为left或right。 js代码中的window.onload 是为了让dom加载完毕之后再执行以下代码。jquery的$(function)(){}相当于js中的window.onload，并且比window.onload性能要好。 关于语义 &lt;q&gt;&lt;/q&gt;标签会在html文档中显示为双引号，但使用标签的主要目的并不是为了显示双引号，这样还不如直接输入双引号。它的目的是它的语义：引用别人的话。还有一个引用标签&lt;blockquote&gt;&lt;/blockquote&gt;，浏览器对它的解释是缩进样式，表示引入长文本。 一些HTML标签 &lt;hr /&gt;标签用于添加一条水平横线。 &lt;em&gt;&lt;/em&gt;标签用于斜体。 &lt;address&gt;&lt;/address&gt;用于显示地址，浏览器默认样式是斜体，当然也可用通过css来修改。 插入代码使用&lt;code&gt;标签如：&lt;code&gt;代码语言&lt;/code&gt; &lt;pre&gt;&lt;/pre&gt;标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。可以使用这个标签来包裹大段代码。 可以对&lt;table&gt;标签进行一些优化，&lt;caption&gt;表格标题&lt;/caption&gt;可以指定表格的标题，&lt;table summary=&quot;表格简介文本&quot;&gt;，这里的简介不会在浏览器显示出来，是为了增加表格的可读性（语义化）。 &lt;a&gt;除了常见的功能之外，标签还有一个功能是可以用来链接Email地址，使用mailto可以使访问者便捷的向网站管理者发送电子邮件，这样点击a链接时会打开电子邮件应用，并自动填写收件人等设置好的信息。具体用法如图 img标签可以通过title属性指定鼠标滑过图片时显示的文本。图片格式可以是gif，png，jpg，jpeg等。 在&lt;select&gt;标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。 表单的重置按钮，可以通过设置input标签的type值为reset来实现。 label标签：label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。语法：&lt;label for=&quot;控件id名称&quot;&gt;。例子： 123456789&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;br /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;female&quot; /&gt; &lt;label for=&quot;email&quot;&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt;&lt;/form&gt; 可以为span标签添加属性white-space:pre;，这个样式表示空白会被浏览器保留。 css几种设置方法的优先级 12345671. 内联样式表的权值最高 10002. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 CSS 优先级法则： 123456789A 选择器都有一个权值，权值越大越优先B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式D 继承的CSS 样式不如后来指定的CSS 样式E 在同一组属性设置中标有“!important”规则的优先级最大 ID选择器只能在文档中使用一次。可以使用类选择器词列表方法为一个元素同时设置多个样式，ID选择器是不可以的。 子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。二者的区别在于：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通配选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素。 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（,）。 有些特殊的情况需要为某些样式设置具有最高权值，这时候我们可以使用!important来解决。如：p{color:red!important;}。注意：!important要写在分号的前面。 text-decoration可以用于设下划线、删除线等文字样式。 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;}。注意：2em的意思就是文字的2倍大小。em 就是一个全角占位符，则2em 就是2个全角位置。但是，建议不要使用em作为中文站点的文字单位，会导致文字变形十分严重的。 line-height也是段落排版中一个常用的属性，指定行间距（行高）。 如果想在网页排版中设置文字间隔或者字母间隔就可以使用letter-spacing 来实现。如果想设置英文单词之间的间距可以使用 word-spacing 来实现。 html的标签元素大体被分为三种不同类型：块状元素、内联元素(又叫行内元素)和内联块状元素。它们的区别：块状元素都自带换行效果；内联元素都是定义行内小区域且不换行，但如果没有内容就没有意义，不占空间；内联块状元素除了不换行，即使没有内容也会占空间。 块级元素特点：（display:block; 所有块级元素都具备盒子模型的特征） 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素特点：（display:inline;） 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素特点：（inline-block;） 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型 流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。第二点：在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed) absolute表里如一，移动了就是移动了。relative只是表面显示移动了，但实际还在文档流中原有位置，别的元素无法占据。 水平居中：如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素(块状元素的宽度width为固定值)和不定宽块状元素(块状元素的宽度width不固定)。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的，元素的“上下 margin” 是可以随意设置的。不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）： 加入 table 标签。这是利用table标签的长度自适应性——即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置。 设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的。 垂直居中 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。但这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 父元素高度确定的多行文本、图片等的竖直居中的方法有两种：方法一：css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。方法二：在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 隐性改变display类型：只要html代码中出现position : absolute或float:left或float:right其中之一，则元素的display显示类型就会自动变为inline-block，就可以设置宽和高了，并且默认宽度不占满父元素。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js学习笔记-入门篇]]></title>
    <url>%2F2018%2F03%2F25%2FVue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于“渐进式”的理解想要理解渐进式的概念，首先要理解什么是框架。框架的存在是为了帮助我们应对复杂度，而框架本身也会带来一定的复杂度，所以就可以抽象出一个问题，即所要解决的问题的内在复杂度，与所使用的工具的复杂度进行对比。不难理解，工具复杂度是为了处理内在复杂度所做的投资，所以如果使用一个过于简陋的工具应对一个复杂的问题，就会遇到工具太弱而使得生产力受影响的问题；同样的，如果你想要解决的问题并不复杂，但你却用了很复杂的框架，那么就会遇到工具复杂度所带来的副作用，这样不仅会使工具失去了本身所带来的优势，还会增加各种问题，例如培训成本、上手成本、以及实际开发效率等。 综上所诉，做得少的框架可以给你更多的灵活性，但你需要做更多的选择；做得多的框架有更强的侵入性，学习成本更高，灵活性更低。而我们目前需要的可能是一个能够根据项目需要自由“伸缩”的框架，这种自由“伸缩”的概念，就是渐进式的概念，渐进式的框架不需要做太多职责之外的事情，你完全可以根据你的需要来选择让框架完成什么功能。 使用vue无需关心DOM操作，所有的DOM操作都交给vue来完成，你编写的代码只需要关注逻辑层面即可。 数据双向绑定示例如下，input表单中的值如果改变，data中的message也会跟着改变，而如果data中的message改变了，则input中的值也会改变。html代码：1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/input&gt;&lt;/div&gt; js代码：12345678&lt;script&gt;new Vue(&#123; el: &apos;#app&apos; data:&#123; message: &quot;Hello World!&quot; &#125;&#125;);&lt;/script&gt; 数据双向绑定有个好处，如果input表单的值发生变化，则h1标签中的值会同步更新。而这个过程要用jQuery等框架实现并不容易。tips:可以使用下列语句打印data中的message内容，也会随input框中内容的变化实时更新。其中|是个过滤器，用于控制文本以json格式输出。123&lt;pre&gt; &#123;&#123; $data | json &#125;&#125;&lt;/pre&gt; v-show与v-if的区别v-show实际上是控制DOM元素的display属性，而v-if如果不为真，则直接不渲染该元素。在查看源代码时可以看出这个区别。 vue中的事件vue中的事件使用v-on绑定，比如表单绑定提交事件可以写为v-on:submit=&quot;functionName/表达式（使用的变量要在data中声明）&quot;或@submit=&quot;functionName对应的js代码如下：123456789new Vue(&#123; el: &quot;#...&quot; methods:&#123; functionName: function()&#123; ... //这里可以使用this.变量名来获取data中的数据 &#125; &#125;&#125;); *注意：默认情况下点击提交可能会跳转到一个页面，可以在上述代码中向函数传入一个e作为参数，使用e.preventDefault();阻止表单的默认提交行为。也可以简写在html中v-on:submit.prevent=&quot;functionName&quot; Vue的组件组件可以扩展 HTML 元素，封装可重用的代码。Vue中的组件化使得你可以创造自己的html标签，从而方便重用。要注册一个全局组件，可以使用 Vue.component(tagName, options)。例如，想要在html中使用一个&lt;test&gt;&lt;/test&gt;标签，则需要以下js代码：12345&lt;script&gt; Vue.component(&apos;test&apos;,&#123; template: &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos; &#125;);&lt;/script&gt; 此时浏览器会将template中的内容替换到&lt;test&gt;&lt;/test&gt;的位置。template中的内容可以在html代码中指定一个&lt;template&gt;&lt;/template&gt;标签，并赋予id，在template处指定值为#id。props指定了组件的属性，自定义组件中如果要使用某个属性并赋值，需要在props声明。注意：vue中的组件是不允许有大写字母存在的，如果你的组件使用了驼峰式命名，如myCounter，则使用这个组件的时候标签会自动变成&lt;my-counter&gt;&lt;/my-counter&gt;。 示例：使用同一段代码来实现一个点赞及不喜欢的计数功能：注意：此示例中标签是包裹在一个id为app的div中的，因此必须要实例化Vue并指明el的值为#app，否则没有效果。即官方文档中说的注意确保在初始化根实例。并且，组件应该在初始化根实例之前被注册。 vue的两个彩蛋 在cdn中搜索vue并复制vue的非压缩版本，在浏览器中的console窗口中，如果你的代码有错误，则会有十分友好的提示。开发过程中最好不要使用压缩版本，不然就失去了所有常见错误的警告。 vue-devtoos，一款chrome插件，需要在有服务器的情况下使用，本地服务器也可以，它会显示出vue本来的样子，结构清晰，对vue的开发也会有一定的帮助。 computed可以用于一些需要处理代码逻辑或业务逻辑的输出，或者是一些需要经过多方判断最终输出到屏幕的数据。如果与input进行了数据绑定那么也是可以实时更新的。示例如下： 循环输出使用v-for来循环输出data中的json数组中的数据。 举例：12345&lt;ul&gt; &lt;li v-class=&quot;task.completed ? &apos;completed&apos; : &apos;&apos;&quot; v-for=&quot;task in tasks&quot; &gt;&#123;&#123; task.body &#125;&#125;&lt;/li&gt; 或者写为以下格式也可以根据json数据中的complete字段来指定元素的样式 &lt;li :class=&quot;&#123;&apos;completed&apos;:task.completed&#125;&gt;&lt;/li&gt;&quot;&lt;/ul&gt; tips：v-class可以简写为:class。如果直接写:class=&quot;completed&quot;是不起作用的，需要在data中对complete进行声明或者写为:class=&quot;[&#39;completed&#39;, &#39;something&#39;]&quot;。js代码：1234567data:&#123; tasks:[ &#123;body: &apos;go to the movie&apos;, completed: false&#125;, &#123;body: &apos;learn vue.js by video&apos;, completed: true&#125;, &#123;body: &apos;go to the shop&apos;, completed: false&#125; ]&#125; 12345&lt;style&gt; .completed&#123; text-decoration: line--through; &#125;&lt;/style&gt; 一些建议自定义标签尽量添加一些前缀或后缀，或者使用多个单词，因为html一般使用单个单词作为标签，这样可以最大程度的避免重复的可能，也避免了需要修改代码的可能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基础学习笔记]]></title>
    <url>%2F2018%2F03%2F22%2FMarkDown%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文源于Markdown官方文档，自行整理后发布，首发于CSDN，Markdown常用语法学习笔记 标题（1）atx形式： # 表示一级标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 ## 表示二级标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 …… ######表示六级标题，即HTML语言中的&lt;h6&gt;&lt;/h6&gt;标签 （2）Setext形式： = 底线 表示最高阶标题，即HTML语言中的&lt;h1&gt;&lt;/h1&gt;标签 - 底线 表示二阶标题，即HTML语言中的&lt;h2&gt;&lt;/h2&gt;标签 段落一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，例如只有空白和tab）。 注意，一个以上空行的意思是，当前行输入完毕换行后，再次按下回车键换行，这样即为一个以上空行。显示上看起来是两行文字之间留出一行了空白行。 段落即为HTML语言中的&lt;p&gt;&lt;/p&gt; 区块&gt; 表示区块，即首行缩进一个单位长度（通常为四个空格的长度），即HTML语言中的&lt;blockquote&gt;&lt;/blockquote&gt; 列表* 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; + 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; - 无序列表，对应HTML语言中的&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt; 1. 有序列表，数字加英文句点，对应HTML语言中的&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 注意： 你在列表标记上使用的数字并不会影响HTML的输出结果。如果你使用懒惰的写法，建议第一个项目最好从1.开始，因为Markdown未来有可能会支持有序列表的start属性。 如果在插入列表时，在列表的两项之中插入了空行，则该项内容会用&lt;p&gt;标签包裹起来，你也可以在一项中插入多个段落，只要正确的保证了空行，并且最好开头能够空出四个空格或一个tab，或者是添加一个&gt;使它变成区块，这样和列表显示起来比较整齐。 链接Markdown支持两种形式的链接语法：行内和参考两种形式。 （1）行内形式： 格式：This is an [example link](www.example.com) 解释：在HTML语言中即为，将example link包裹在&lt;a&gt;标签中，并且href地址为www.example.com。 格式：This is an [example link](www.example.com &quot;With a title&quot;) 解释：基本同上，区别是指定了该a标签的title属性值为With a title。 （2）参考形式： 参考形式的链接可以让你为链接定一个名称，之后在其他地方统一定义链接的内容。 格式：This is an [example link][1], and [the second example link][2]. [1]: www.example.com [2]: www.example2.com &quot;title&quot; 解释基本同上，需要注意的地方是，[1]不一定非要使用数字，可以使用字母、数字和空格或其组合，但是不分大小写。 图片图片的语法和链接很像，也分为行内形式和参考形式两种。 （1）行内形式（title是选择性的）： 1![alt text](/path/to/image.jpg &quot;Title&quot;) （2）参考形式：123![alt text][id][id]: /path/to/image.jpg &quot;Title&quot; 上面两种形式都会输出HTML为：&lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot;&gt; 代码Markdown文档中如果输入HTML代码，是会直接生效的。如果想要显示出一一段代码来而不是让它被解析运行，就使用` `（反引号，英文模式下按键盘左上角的波浪号键，注意不能跨行）将代码部分包裹起来，这样就可以显示出原原本本的代码了。 分割线可以在一行中使用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或减号中间插入空格。如： * * * - - - ****** ------ 强调使用星号*和底线_作为标记强调字符的符号，被一个*或_包围的内容会以标签的形式显示，即斜体。被两个*或_包围的内容将会以标签的形式显示，即加粗。 注意，如果*或_的两边有空白，则会显示成普通的星号或底线。如果想要在文字前后直接插入普通的星号或底线，则需要用到转义字符\。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2FHello-World%2F</url>
    <content type="text"><![CDATA[Update in 2018.03.25更新了搜索功能，博客基本功能全部配置完毕。绑定了域名fnine59.top，以后可以通过fnine59.top或www.fnine59.top访问本站。 Update in 2018.03.22程序员面对任何一门新技术，第一句话似乎永远都是Hello World。 从大约3月18号左右开始着手准备这个项目，Hexo基于Git和Nodejs，所以先是花了一两天左右，利用课余时间学习了Git。到最后真正用于搭建这个网站的时间差不多也就一个下午。 这个网站目前还有些功能没有完善起来，会进一步改善的。 欢迎留言，欢迎联系我❤]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  Object对象概述JavaScript原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。 JavaScript的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Objec">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript标准参考教程》阅读笔记之《标准库》">
<meta property="og:url" content="http://fnine59.top/2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/index.html">
<meta property="og:site_name" content="59&#39;s Personal Blog">
<meta property="og:description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  Object对象概述JavaScript原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。 JavaScript的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Objec">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-25T06:08:11.140Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《JavaScript标准参考教程》阅读笔记之《标准库》">
<meta name="twitter:description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  Object对象概述JavaScript原生提供Object对象（注意起首的O是大写），本章介绍该对象原生的各种方法。 JavaScript的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 Objec">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fnine59.top/2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/"/>





  <title>《JavaScript标准参考教程》阅读笔记之《标准库》 | 59's Personal Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/Fnine59"><img style="position: absolute; top: 0; right: 0; 
	border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"
	alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">59's Personal Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just coding.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fnine59.top/2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fnine59">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="59's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《JavaScript标准参考教程》阅读笔记之《标准库》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T23:58:20+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript标准教程笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript标准教程笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/" class="leancloud_visitors" data-flag-title="《JavaScript标准参考教程》阅读笔记之《标准库》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，<a href="https://github.com/ruanyf/jstutorial" target="_blank" rel="noopener">github地址</a></p>
</blockquote>
<h1 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法。</p>
<p><strong>JavaScript的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例</strong>。</p>
<p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p>
<h3 id="Object对象本身的方法"><a href="#Object对象本身的方法" class="headerlink" title="Object对象本身的方法"></a>Object对象本身的方法</h3><p>所谓“本身的方法”就是<strong>直接定义在<code>Object</code>对象的方法</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.print = function (o) &#123; console.log(o) &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>print</code>方法就是直接定义在<code>Object</code>对象上。</p>
<h3 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h3><p>所谓实例方法就是<strong>定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法</strong>。它可以被<code>Object</code>实例直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.print = function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = new Object();</span><br><span class="line">obj.print() // Object</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.prototype</code>定义了一个<code>print</code>方法，然后生成一个<code>Object</code>的实例<code>obj</code>。<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法，可以直接使用<code>obj.print</code>调用<code>print</code>方法。也就是说，<code>obj</code>对象的<code>print</code>方法实质上就是调用<code>Object.prototype.print</code>方法。</p>
<p>关于原型对象<code>object.prototype</code>的详细解释，参见《面向对象编程》章节。这里只要知道，<strong>凡是定义在<code>Object.prototype</code>对象上面的属性和方法，将被所有实例对象共享就可以了。</strong></p>
<p>以下先介绍<code>Object</code>作为函数的用法，然后再介绍<code>Object</code>对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h2><p><strong><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</strong></p>
<p><strong>如果参数为空（或者为<code>undefined</code>和<code>null</code>），Object()返回一个空对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object();</span><br><span class="line">// 等同于</span><br><span class="line">var obj = Object(undefined);</span><br><span class="line">var obj = Object(null);</span><br><span class="line"></span><br><span class="line">obj instanceof Object // true</span><br></pre></td></tr></table></figure>
<p>上面代码的含义，是将<code>undefined</code>和<code>null</code>转为对象，结果得到了一个空对象<code>obj</code>。</p>
<p><strong><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。</strong><code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例。</p>
<p><strong>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例（</strong>参见《原始类型的包装对象》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object(1);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof Number // true</span><br><span class="line"></span><br><span class="line">var obj = Object(&apos;foo&apos;);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof String // true</span><br><span class="line"></span><br><span class="line">var obj = Object(true);</span><br><span class="line">obj instanceof Object // true</span><br><span class="line">obj instanceof Boolean // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。</p>
<p><strong>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">var obj = Object(arr); // 返回原数组</span><br><span class="line">obj === arr // true</span><br><span class="line"></span><br><span class="line">var value = &#123;&#125;;</span><br><span class="line">var obj = Object(value) // 返回原对象</span><br><span class="line">obj === value // true</span><br><span class="line"></span><br><span class="line">var fn = function () &#123;&#125;;</span><br><span class="line">var obj = Object(fn); // 返回原函数</span><br><span class="line">obj === fn // true</span><br></pre></td></tr></table></figure>
<p>上面的代码中使用严格相等运算符对对象进行判断，我们知道严格相等运算符比较两个原始类型时比较的是它们的值，而比较两个对象时比较的是它们的引用地址，因此上面的代码中返回了<code>true</code>就可以说明，如果<code>Object</code>方法的参数是一个对象，则它总是返回<strong>原</strong>对象。</p>
<p>利用这一点，可以写一个<strong>判断变量是否为对象的函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isObject(value) &#123;</span><br><span class="line">  return value === Object(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObject([]) // true</span><br><span class="line">isObject(true) // false</span><br></pre></td></tr></table></figure>
<h2 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h2><p><strong><code>Object</code>不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用<code>new</code>命令。</strong></p>
<p><code>Object</code>构造函数的<strong>首要用途，是直接通过它来生成新对象。</strong></p>
<p>注意，<strong>通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = {}</code>是等价的</strong>。或者说，后者只是前者的一种简便写法。</p>
<p><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象（详见《包装对象》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">var o2 = new Object(o1);</span><br><span class="line">o1 === o2 // true</span><br><span class="line"></span><br><span class="line">var obj = new Object(123);</span><br><span class="line">obj instanceof Number // true</span><br></pre></td></tr></table></figure>
<p>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<strong><code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</strong></p>
<h2 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h2><p><strong>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法。</strong></p>
<h3 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h3><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都<strong>用来遍历对象的属性。</strong></p>
<p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象<strong><font color="red">自身的（而不是继承的）</font></strong>所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj) // [&quot;p1&quot;, &quot;p2&quot;]</span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象<strong>自身</strong>的所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj) // [&quot;p1&quot;, &quot;p2&quot;]</span><br></pre></td></tr></table></figure>
<p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<strong><code>Object.keys</code>方法只返回可枚举的属性（详见《对象属性的描述对象》一章），<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</span><br><span class="line"></span><br><span class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</span><br><span class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组的<code>length</code>属性是不可枚举的属性，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中。</p>
<p>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p1: 123,</span><br><span class="line">  p2: 456</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj).length // 2</span><br><span class="line">Object.getOwnPropertyNames(obj).length // 2</span><br></pre></td></tr></table></figure>
<p>一般情况下，<strong>几乎总是使用<code>Object.keys</code>方法，遍历数组的属性。</strong></p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>除了上面提到的两个方法，<code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍。</p>
<h4 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h4><blockquote>
<p><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。<br><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。<br><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</p>
</blockquote>
<h4 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a>控制对象状态的方法</h4><blockquote>
<p><code>Object.preventExtensions()</code>：防止对象扩展。<br><code>Object.isExtensible()</code>：判断对象是否可扩展。<br><code>Object.seal()</code>：禁止对象配置。<br><code>Object.isSealed()</code>：判断一个对象是否可配置。<br><code>Object.freeze()</code>：冻结一个对象。<br><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</p>
</blockquote>
<h4 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a>原型链相关方法</h4><blockquote>
<p><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。<br><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</p>
</blockquote>
<h2 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h2><p><strong>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法。</strong></p>
<p><code>Object</code>实例对象的方法，主要有以下六个。</p>
<p><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。<br><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。<br><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。<br><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。<br><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。<br><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</p>
<p>本节介绍前四个方法，另外两个方法将在后文相关章节介绍。</p>
<h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.valueOf() === obj // true</span><br></pre></td></tr></table></figure>
<p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的。</p>
<p><strong><code>valueOf</code>方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法</strong>（详见《数据类型转换》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">1 + obj // &quot;1[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.valueOf = function () &#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">1 + obj // 3</span><br></pre></td></tr></table></figure>
<p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>。这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>。</p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p><code>toString</code>方法的作用是<strong>返回一个对象的字符串形式，默认情况下返回类型字符串。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = new Object();</span><br><span class="line">o1.toString() // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">var o2 = &#123;a:1&#125;;</span><br><span class="line">o2.toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p>
<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">obj.toString = function () &#123;</span><br><span class="line">  return &apos;hello&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + &apos; &apos; + &apos;world&apos; // &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>。</p>
<p>数组、字符串、函数、<code>Date</code> 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].toString() // &quot;1,2,3&quot;</span><br><span class="line"></span><br><span class="line">&apos;123&apos;.toString() // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  return 123;</span><br><span class="line">&#125;).toString()</span><br><span class="line">// &quot;function () &#123;</span><br><span class="line">//   return 123;</span><br><span class="line">// &#125;&quot;</span><br><span class="line"></span><br><span class="line">(new Date()).toString()</span><br><span class="line">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组、字符串、函数、<code>Date</code> 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法。</p>
<h3 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h3><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中<strong>第二个<code>Object</code>表示该值的构造函数。这是一个十分有用的判断数据类型的方法。</strong></p>
<p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以<strong>为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(value)</span><br></pre></td></tr></table></figure>
<p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。</p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数值：返回[object Number]。</span><br><span class="line">字符串：返回[object String]。</span><br><span class="line">布尔值：返回[object Boolean]。</span><br><span class="line">undefined：返回[object Undefined]。</span><br><span class="line">null：返回[object Null]。</span><br><span class="line">数组：返回[object Array]。</span><br><span class="line">arguments 对象：返回[object Arguments]。</span><br><span class="line">函数：返回[object Function]。</span><br><span class="line">Error 对象：返回[object Error]。</span><br><span class="line">Date 对象：返回[object Date]。</span><br><span class="line">RegExp 对象：返回[object RegExp]。</span><br><span class="line">其他对象：返回[object Object]。</span><br></pre></td></tr></table></figure>
<p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2) // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;&apos;) // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>
<p>利用这个特性，<strong>可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var type = function (o)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); // &quot;object&quot;</span><br><span class="line">type([]); // &quot;array&quot;</span><br><span class="line">type(5); // &quot;number&quot;</span><br><span class="line">type(null); // &quot;null&quot;</span><br><span class="line">type(); // &quot;undefined&quot;</span><br><span class="line">type(/abcd/); // &quot;regex&quot;</span><br><span class="line">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>
<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var type = function (o)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[&apos;Null&apos;,</span><br><span class="line"> &apos;Undefined&apos;,</span><br><span class="line"> &apos;Object&apos;,</span><br><span class="line"> &apos;Array&apos;,</span><br><span class="line"> &apos;String&apos;,</span><br><span class="line"> &apos;Number&apos;,</span><br><span class="line"> &apos;Boolean&apos;,</span><br><span class="line"> &apos;Function&apos;,</span><br><span class="line"> &apos;RegExp&apos;</span><br><span class="line">].forEach(function (t) &#123;</span><br><span class="line">  type[&apos;is&apos; + t] = function (o) &#123;</span><br><span class="line">    return type(o) === t.toLowerCase();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.isObject(&#123;&#125;) // true</span><br><span class="line">type.isNumber(NaN) // true</span><br><span class="line">type.isRegExp(/abc/) // true</span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h3><p><strong><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.toString(obj) // &quot;[object Object]&quot;</span><br><span class="line">obj.toLocaleString(obj) // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了<code>toLocaleString</code>方法。</p>
<blockquote>
<p>Array.prototype.toLocaleString()<br>Number.prototype.toLocaleString()<br>Date.prototype.toLocaleString()</p>
</blockquote>
<p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">date.toString() // &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;</span><br><span class="line">date.toLocaleString() // &quot;1/01/2018, 12:01:33 PM&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p><code>Object.prototype.hasOwnProperty</code>方法<strong>接受一个字符串作为参数，返回一个布尔值，表示<font color="red">该实例对象自身是否具有该属性。</font></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: 123</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&apos;p&apos;) // true</span><br><span class="line">obj.hasOwnProperty(&apos;toString&apos;) // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code>。</p>
<h1 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(2);</span><br><span class="line">arr.length // 2</span><br><span class="line">arr // [ empty  x 2 ] // 这里是empty代表是空位，虽然浏览器控制台输出为undefined，但它与undefined是不同的</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Array</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值。</p>
<p>如果没有使用<code>new</code>，运行结果也是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(2);</span><br><span class="line">// 等同于</span><br><span class="line">var arr = Array(2);</span><br></pre></td></tr></table></figure>
<p><code>Array</code>构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 无参数时，返回一个空数组</span><br><span class="line">new Array() // []</span><br><span class="line"></span><br><span class="line">// 单个正整数参数，表示返回的新数组的长度</span><br><span class="line">new Array(1) // [ empty ]</span><br><span class="line">new Array(2) // [ empty x 2 ]</span><br><span class="line"></span><br><span class="line">// 非正整数的数值作为参数，会报错</span><br><span class="line">new Array(3.2) // RangeError: Invalid array length</span><br><span class="line">new Array(-3) // RangeError: Invalid array length</span><br><span class="line"></span><br><span class="line">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span><br><span class="line">// 则该参数是返回的新数组的成员</span><br><span class="line">new Array(&apos;abc&apos;) // [&apos;abc&apos;]</span><br><span class="line">new Array([1]) // [Array[1]]，创建了一个包含了一个元素的数组，该元素是个数组包含了一个元素1</span><br><span class="line"></span><br><span class="line">// 多参数时，所有参数都是返回的新数组的成员</span><br><span class="line">new Array(1, 2) // [1, 2]</span><br><span class="line">new Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Array</code>作为构造函数，行为很不一致。因此，<strong>不建议使用它生成新数组，直接使用数组字面量是更好的做法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var arr = new Array(1, 2);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var arr = [1, 2];</span><br></pre></td></tr></table></figure>
<p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然可以取到<code>length</code>属性，但是取不到键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(3);</span><br><span class="line">var b = [undefined, undefined, undefined];</span><br><span class="line"></span><br><span class="line">a.length // 3</span><br><span class="line">b.length // 3</span><br><span class="line"></span><br><span class="line">a[0] // undefined</span><br><span class="line">b[0] // undefined</span><br><span class="line"></span><br><span class="line">0 in a // false</span><br><span class="line">0 in b // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>是一个长度为<code>3</code>的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组。<strong>读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键位都是空的，<code>b</code>的键位是有值的。</strong></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><strong><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。</strong>它可以弥补<code>typeof</code>运算符的不足。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">typeof arr // &quot;object&quot;</span><br><span class="line">Array.isArray(arr) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h3><p><code>valueOf</code>方法是一个<strong>所有对象都拥有</strong>的方法，<strong>表示对该对象求值</strong>。不同对象的<code>valueOf</code>方法不尽一致，<strong>数组的<code>valueOf</code>方法返回数组本身。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.valueOf() // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p><code>toString</code>方法也是对象的通用方法，<strong>数组的<code>toString</code>方法返回数组的字符串形式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.toString() // &quot;1,2,3&quot;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, [4, 5, 6]];</span><br><span class="line">arr.toString() // &quot;1,2,3,4,5,6&quot;</span><br></pre></td></tr></table></figure>
<h3 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h3><p><code>push</code>方法<strong>用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line">arr.push(1) // 1</span><br><span class="line">arr.push(&apos;a&apos;) // 2</span><br><span class="line">arr.push(true, &#123;&#125;) // 4</span><br><span class="line">arr // [1, &apos;a&apos;, true, &#123;&#125;]</span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。</p>
<p><code>pop</code>方法<strong>用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">arr.pop() // &apos;c&apos;</span><br><span class="line">arr // [&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].pop() // undefined</span><br></pre></td></tr></table></figure>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.push(1, 2);</span><br><span class="line">arr.push(3);</span><br><span class="line">arr.pop();</span><br><span class="line">arr // [1, 2]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组。</p>
<h3 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h3><p><code>shift</code>方法<strong>用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.shift() // &apos;a&apos;</span><br><span class="line">a // [&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p><code>shift</code>方法可以遍历并清空一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var list = [1, 2, 3, 4, 5, 6];</span><br><span class="line">var item;</span><br><span class="line"></span><br><span class="line">while (item = list.shift()) &#123; // 当list中没有元素的时候，使用list.shift()返回undefined</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list // []</span><br></pre></td></tr></table></figure>
<p><code>push</code>和<code>shift</code>结合使用，就构成了“先进先出”的队列结构（queue）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.push(1, 2);</span><br><span class="line">arr.push(3);</span><br><span class="line">arr.shift();</span><br><span class="line">arr // [2, 3]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>3</code>是最后进入数组的，也是最后离开数组；<code>1</code>是最先进入数组的，也最先离开数组。</p>
<p><code>unshift</code>方法<strong>用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.unshift(&apos;x&apos;); // 4</span><br><span class="line">a // [&apos;x&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p><code>unshift</code>方法可以接受多个参数，这些参数都会添加到目标数组头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;c&apos;, &apos;d&apos; ];</span><br><span class="line">arr.unshift(&apos;a&apos;, &apos;b&apos;) // 4</span><br><span class="line">arr // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]</span><br></pre></td></tr></table></figure>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><code>join</code>方法<strong>以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">a.join(&apos; &apos;) // &apos;1 2 3 4&apos;</span><br><span class="line">a.join(&apos; | &apos;) // &quot;1 | 2 | 3 | 4&quot;</span><br><span class="line">a.join() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[undefined, null].join(&apos;#&apos;)</span><br><span class="line">// &apos;#&apos;</span><br><span class="line"></span><br><span class="line">[&apos;a&apos;,, &apos;b&apos;].join(&apos;-&apos;)</span><br><span class="line">// &apos;a--b&apos;</span><br></pre></td></tr></table></figure>
<p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.join.call(&apos;hello&apos;, &apos;-&apos;)</span><br><span class="line">// &quot;h-e-l-l-o&quot;</span><br><span class="line"></span><br><span class="line">var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;;</span><br><span class="line">Array.prototype.join.call(obj, &apos;-&apos;)</span><br><span class="line">// &apos;a-b&apos;</span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat</code>方法<strong>用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&apos;hello&apos;].concat([&apos;world&apos;])</span><br><span class="line">// [&quot;hello&quot;, &quot;world&quot;]</span><br><span class="line"></span><br><span class="line">[&apos;hello&apos;].concat([&apos;world&apos;], [&apos;!&apos;])</span><br><span class="line">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]</span><br><span class="line"></span><br><span class="line">[].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)</span><br><span class="line">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span><br><span class="line"></span><br><span class="line">[2].concat(&#123;a: 1&#125;)</span><br><span class="line">// [2, &#123;a: 1&#125;]</span><br></pre></td></tr></table></figure>
<p>除了数组作为参数，<strong><code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(4, 5, 6)</span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p><strong>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1 &#125;;</span><br><span class="line">var oldArray = [obj];</span><br><span class="line"></span><br><span class="line">var newArray = oldArray.concat();</span><br><span class="line"></span><br><span class="line">obj.a = 2;</span><br><span class="line">newArray[0].a // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。</p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p><code>reverse</code>方法<strong>用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br><span class="line">a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice</code>方法<strong>用于提取目标数组的一部分，返回一个新数组，原数组不变。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>
<p><strong>它的第一个参数为起始位置（从<code>0</code>开始），第二个参数为终止位置（但<font color="red">该位置的元素本身不包括在内</font>）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(1) // [&quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(1, 2) // [&quot;b&quot;]</span><br><span class="line">a.slice(2, 6) // [&quot;c&quot;]</span><br><span class="line">a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>最后一个例子<code>slice</code>没有参数，实际上等于返回一个原数组的拷贝。</strong></p>
<p><strong>如果<code>slice</code>方法的参数是负数，则表示倒数计算的位置。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]</span><br><span class="line">a.slice(-2, -1) // [&quot;b&quot;]</span><br><span class="line">a.slice(-3, -1) // [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">a.slice(-1) // [&quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置。</p>
<p><strong>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.slice(4) // []</span><br><span class="line">a.slice(2, 1) // []</span><br></pre></td></tr></table></figure>
<p><strong><code>slice</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</span><br><span class="line">// [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));</span><br><span class="line">Array.prototype.slice.call(arguments);</span><br></pre></td></tr></table></figure>
<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice</code>方法，就可以把它们转为真正的数组。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice</code>方法<strong>用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>
<p><strong><code>splice</code>的第一个参数是删除的起始位置（从<code>0</code>开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class="line">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码从原数组<code>4</code>号位置，删除了两个数组成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class="line">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></pre></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员。</p>
<p>起始位置如果是负数，就表示从倒数位置开始删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line">a.splice(-4, 2) // [&quot;c&quot;, &quot;d&quot;]</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">a.splice(-4, 6) // [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">a.splice(-4, 4) // [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员。</p>
<p>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 1, 1];</span><br><span class="line"></span><br><span class="line">a.splice(1, 0, 2) // []</span><br><span class="line">a // [1, 2, 1, 1]</span><br></pre></td></tr></table></figure>
<p>上面代码表示在数组<code>a</code>下标为<code>1</code>的位置插入一个新元素<code>2</code>。</p>
<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3, 4];</span><br><span class="line">a.splice(2) // [3, 4]</span><br><span class="line">a // [1, 2]</span><br></pre></td></tr></table></figure>
<p>上面的代码表示从数组<code>a</code>下标为<code>2</code>的地方开始连带它之后的元素为一个数组，<code>a</code>中只剩余它之前的元素。</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p><code>sort</code>方法<strong>对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;].sort()</span><br><span class="line">// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">[4, 3, 2, 1].sort()</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">[11, 101].sort()</span><br><span class="line">// [101, 11]</span><br><span class="line"></span><br><span class="line">[10111, 1101, 111].sort()</span><br><span class="line">// [10111, 1101, 111]</span><br></pre></td></tr></table></figure>
<p>上面代码的最后两个例子，需要特殊注意。<strong><code>sort</code>方法不是按照大小排序，而是按照字典顺序。也就是说，<font color="red">数值会被先转成字符串，再按照字典顺序进行比较</font></strong>，所以<code>101</code>排在<code>11</code>的前面。</p>
<p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[10111, 1101, 111].sort(function (a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;)</span><br><span class="line">// [111, 1101, 10111]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。<strong>如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; name: &quot;张三&quot;, age: 30 &#125;,</span><br><span class="line">  &#123; name: &quot;李四&quot;, age: 24 &#125;,</span><br><span class="line">  &#123; name: &quot;王五&quot;, age: 28  &#125;</span><br><span class="line">].sort(function (o1, o2) &#123;</span><br><span class="line">  return o1.age - o2.age;</span><br><span class="line">&#125;)</span><br><span class="line">// [</span><br><span class="line">//   &#123; name: &quot;李四&quot;, age: 24 &#125;,</span><br><span class="line">//   &#123; name: &quot;王五&quot;, age: 28  &#125;,</span><br><span class="line">//   &#123; name: &quot;张三&quot;, age: 30 &#125;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法<strong>将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">numbers.map(function (n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br><span class="line">// [2, 3, 4]</span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，<strong>原数组没有变化</strong>。</p>
<p><code>map</code>方法接受一个函数作为参数。<strong>该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(function(elem, index, arr) &#123;</span><br><span class="line">  return elem * index;</span><br><span class="line">&#125;);</span><br><span class="line">// [0, 2, 6]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>map</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）。</p>
<p><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量（详见《this 变量》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">[1, 2].map(function (e) &#123;</span><br><span class="line">  return this[e];</span><br><span class="line">&#125;, arr)</span><br><span class="line">// [&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>map</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组。</p>
<p><strong>如果数组有空位，<code>map</code>方法的回调函数在这个位置不会执行，<font color="red">会跳过数组的空位</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = function (n) &#123; return &apos;a&apos; &#125;;</span><br><span class="line"></span><br><span class="line">[1, undefined, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class="line">[1, null, 2].map(f) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class="line">[1, , 2].map(f) // [&quot;a&quot;, , &quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><font color="red"><code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位。</font></strong></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p><strong><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法。</strong></p>
<p><code>forEach</code>的用法与<code>map</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(element, index, array) &#123;</span><br><span class="line">  console.log(&apos;[&apos; + index + &apos;] = &apos; + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[2, 5, 9].forEach(log);</span><br><span class="line">// [0] = 2</span><br><span class="line">// [1] = 5</span><br><span class="line">// [2] = 9</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map</code>方法。</p>
<p><code>forEach</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var out = [];</span><br><span class="line"></span><br><span class="line">[1, 2, 3].forEach(function(elem) &#123;</span><br><span class="line">  this.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"></span><br><span class="line">out // [1, 4, 9]</span><br></pre></td></tr></table></figure>
<p>上面代码中，空数组<code>out</code>是<code>forEach</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>。</p>
<p>注意，<strong><code>forEach</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr[i] === 2) break;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach</code>方法做不到这一点。</p>
<p><strong><code>forEach</code>方法也会跳过数组的<font color="red">空位</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var log = function (n) &#123;</span><br><span class="line">  console.log(n + 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[1, undefined, 2].forEach(log)</span><br><span class="line">// 2</span><br><span class="line">// NaN</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">[1, null, 2].forEach(log)</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">[1, , 2].forEach(log)</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法<strong>用于过滤数组成员，满足条件的成员组成一个新数组返回。</strong></p>
<p><strong>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].filter(function (elem) &#123;</span><br><span class="line">  return (elem &gt; 3);</span><br><span class="line">&#125;)</span><br><span class="line">// [4, 5]</span><br></pre></td></tr></table></figure>
<p>上面代码将大于<code>3</code>的数组成员，作为一个新数组返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0, 1, &apos;a&apos;, false];</span><br><span class="line"></span><br><span class="line">arr.filter(Boolean)</span><br><span class="line">// [1, &quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员。</p>
<p><code>filter</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].filter(function (elem, index, arr) &#123;</span><br><span class="line">  return index % 2 === 0;</span><br><span class="line">&#125;);</span><br><span class="line">// [1, 3, 5]</span><br></pre></td></tr></table></figure>
<p>上面代码返回索引值为偶数，也就是奇数位置的成员组成的新数组。</p>
<p><code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; MAX: 3 &#125;;</span><br><span class="line">var myFilter = function (item) &#123;</span><br><span class="line">  if (item &gt; this.MAX) return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var arr = [2, 8, 3, 4, 1, 3, 2, 9];</span><br><span class="line">arr.filter(myFilter, obj) // [8, 4, 9]</span><br></pre></td></tr></table></figure>
<p>上面代码中，过滤器<code>myFilter</code>内部有<code>this</code>变量，它可以被<code>filter</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员。</p>
<h3 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h3><p>这两个方法<strong>类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</strong></p>
<p><strong>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</strong></p>
<p><strong><code>some</code>方法是<font color="red">只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code></font>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.some(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &gt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果数组<code>arr</code>有一个成员大于等于<code>3</code>，<code>some</code>方法就返回<code>true</code>。</p>
<p><strong><code>every</code>方法是<font color="red">所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code></font>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.every(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &gt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>并非所有成员大于等于<code>3</code>，所以返回<code>false</code>。</p>
<p>注意，<strong>对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEven(x) &#123; alert(&quot;test!&quot;); return x % 2 === 0 &#125;</span><br><span class="line"></span><br><span class="line">[].some(isEven) // false</span><br><span class="line">[].every(isEven) // true</span><br></pre></td></tr></table></figure>
<p>上面的代码中，那句alert不会执行，因此可以得知无论返回<code>true</code>还是<code>false</code>回调函数都不会执行。</p>
<p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<h3 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h3><p><code>reduce</code>方法和<code>reduceRight</code>方法<strong>依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].reduce(function (a, b) &#123;</span><br><span class="line">  console.log(a, b);</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;)</span><br><span class="line">// 1 2</span><br><span class="line">// 3 3</span><br><span class="line">// 6 4</span><br><span class="line">// 10 5</span><br><span class="line">//最后结果：15</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法求出数组所有成员的和。第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p>
<p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数。</p>
<blockquote>
<p>累积变量，默认为数组的第一个成员<br>当前变量，默认为数组的第二个成员<br>当前位置（从0开始）<br>原数组</p>
</blockquote>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<p>如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].reduce(function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;, 10);</span><br><span class="line">// 25</span><br></pre></td></tr></table></figure>
<p>上面代码指定参数<code>a</code>的初值为<code>10</code>，所以数组从<code>10</code>开始累加，最终结果为<code>25</code>。注意，<strong><font color="red">这时<code>b</code>是从数组的第一个成员开始遍历</font>。</strong></p>
<p>上面的<strong>第二个参数相当于设定了默认值，处理空数组时尤其有用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(prev, cur) &#123;</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[].reduce(add)</span><br><span class="line">// TypeError: Reduce of empty array with no initial value</span><br><span class="line">[].reduce(add, 1)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。</p>
<p>下面是一个<code>reduceRight</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function substract(prev, cur) &#123;</span><br><span class="line">  return prev - cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[3, 2, 1].reduce(substract) // 0</span><br><span class="line">[3, 2, 1].reduceRight(substract) // -4</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>。</p>
<p><strong>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作</strong>。比如，找出字符长度最长的数组成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function findLongest(entries) &#123;</span><br><span class="line">  return entries.reduce(function (longest, entry) &#123;</span><br><span class="line">    return entry.length &gt; longest.length ? entry : longest;</span><br><span class="line">  &#125;, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLongest([&apos;aaa&apos;, &apos;bb&apos;, &apos;c&apos;]) // &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。</p>
<h3 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h3><p><code>indexOf</code>方法<strong>返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.indexOf(&apos;b&apos;) // 1</span><br><span class="line">a.indexOf(&apos;y&apos;) // -1</span><br></pre></td></tr></table></figure>
<p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].indexOf(&apos;a&apos;, 1) // -1</span><br></pre></td></tr></table></figure>
<p>上面代码从<code>1</code>号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到。</p>
<p><code>lastIndexOf</code>方法<strong>返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [2, 5, 9, 2];</span><br><span class="line">a.lastIndexOf(2) // 3</span><br><span class="line">a.lastIndexOf(7) // -1</span><br></pre></td></tr></table></figure>
<p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN) // -1</span><br><span class="line">[NaN].lastIndexOf(NaN) // -1</span><br></pre></td></tr></table></figure>
<p>这是<strong>因为这两个方法内部，<font color="red">使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值</font>。</strong></p>
<h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var users = [</span><br><span class="line">  &#123;name: &apos;tom&apos;, email: &apos;tom@example.com&apos;&#125;,</span><br><span class="line">  &#123;name: &apos;peter&apos;, email: &apos;peter@example.com&apos;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">.map(function (user) &#123;</span><br><span class="line">  return user.email;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(function (email) &#123;</span><br><span class="line">  return /^t/.test(email);</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(console.log);</span><br><span class="line">// &quot;tom@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址。</p>
<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象是 JavaScript 语言最主要的数据类型，<strong>三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</strong></p>
<p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v1 = new Number(123);</span><br><span class="line">var v2 = new String(&apos;abc&apos;);</span><br><span class="line">var v3 = new Boolean(true);</span><br></pre></td></tr></table></figure>
<p>上面代码中，基于原始类型的值，生成了三个对应的包装对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof v1 // &quot;object&quot;</span><br><span class="line">typeof v2 // &quot;object&quot;</span><br><span class="line">typeof v3 // &quot;object&quot;</span><br><span class="line"></span><br><span class="line">v1 === 123 // false</span><br><span class="line">v2 === &apos;abc&apos; // false</span><br><span class="line">v3 === true // false</span><br></pre></td></tr></table></figure>
<p>包装对象的最大目的，首先是<strong>使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法</strong>。</p>
<p><code>Number</code>、<code>String</code>和<code>Boolean</code><strong>如果不作为构造函数调用（即调用时不加<code>new</code>），常常用于将任意类型的值转为数值、字符串和布尔值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number(123) // 123</span><br><span class="line">String(&apos;abc&apos;) // &quot;abc&quot;</span><br><span class="line">Boolean(true) // true</span><br></pre></td></tr></table></figure>
<p>上面这种数据类型的转换，详见《数据类型转换》一节。</p>
<p>总结一下，<strong>这三个对象<font color="red">作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值</font></strong>。</p>
<h2 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h2><p>包装对象的实例可以使用<code>Object</code>对象提供的原生方法，主要是<code>valueOf</code>方法和<code>toString</code>方法。</p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p><code>valueOf</code>方法返回包装对象实例对应的原始类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).valueOf()  // 123</span><br><span class="line">new String(&apos;abc&apos;).valueOf() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).valueOf() // true</span><br></pre></td></tr></table></figure>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p><code>toString</code>方法返回对应的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Number(123).toString() // &quot;123&quot;</span><br><span class="line">new String(&apos;abc&apos;).toString() // &quot;abc&quot;</span><br><span class="line">new Boolean(true).toString() // &quot;true&quot;</span><br></pre></td></tr></table></figure>
<h2 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h2><p>原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p>
<p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.length // 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫<strong>原始类型与实例对象的自动转换</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str.length // 3</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var strObj = new String(str)</span><br><span class="line">// String &#123;</span><br><span class="line">//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;</span><br><span class="line">// &#125;</span><br><span class="line">strObj.length // 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>的包装对象提供了多个属性。</p>
<p><strong>自动转换生成的包装对象是<font color="red">只读</font>的，无法修改。所以，字符串无法添加新属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello World&apos;;</span><br><span class="line">s.x = 123;</span><br><span class="line">s.x // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code>。</p>
<p>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，<strong>下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性</strong>。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义（参见《面向对象编程》章节）。</p>
<h2 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>三种包装对象除了提供很多原生的实例方法（详见后文的介绍），还<strong>可以在原型上添加自定义方法和属性，供原始类型的值直接调用</strong>。</p>
<p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&apos;abc&apos;.double()</span><br><span class="line">// abcabc</span><br><span class="line"></span><br><span class="line">Number.prototype.double = function () &#123;</span><br><span class="line">  return this.valueOf() + this.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(123).double()</span><br><span class="line">// 246</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>123</code>外面必须要加上圆括号，否则后面的点运算符（.）会被解释成小数点。</p>
<p>但是，这种自定义方法和属性的机制，<strong>只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">s.p = 123;</span><br><span class="line">s.p // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码直接对字符串<code>abc</code>添加属性，结果无效。主要原因是上面说的，这里的包装对象是自动生成的，赋值后自动销毁，所以<strong>最后一行实际上调用的是一个新的包装对象</strong>。</p>
<h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Boolean</code>对象是 JavaScript 的三个包装对象之一。<strong>作为构造函数，它主要用于生成布尔值的包装对象实例</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var b = new Boolean(true);</span><br><span class="line"></span><br><span class="line">typeof b // &quot;object&quot;</span><br><span class="line">b.valueOf() // true</span><br></pre></td></tr></table></figure>
<p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>。</p>
<p>注意，<strong><font color="red"><code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code></font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (new Boolean(false)) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // true</span><br><span class="line"></span><br><span class="line">if (new Boolean(false).valueOf()) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // 无输出</span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到<code>true</code>，是<strong>因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（<font color="red">因为所有对象对应的布尔值都是<code>true</code></font>）</strong>。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>。</p>
<h3 id="Boolean-函数的类型转换作用"><a href="#Boolean-函数的类型转换作用" class="headerlink" title="Boolean 函数的类型转换作用"></a>Boolean 函数的类型转换作用</h3><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(&apos;&apos;) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line"></span><br><span class="line">Boolean(1) // true</span><br><span class="line">Boolean(&apos;false&apos;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean(function () &#123;&#125;) // true</span><br><span class="line">Boolean(/foo/) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中几种得到<code>true</code>的情况，都值得认真记住。</p>
<p>顺便提一下，使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!!undefined // false</span><br><span class="line">!!null // false</span><br><span class="line">!!0 // false</span><br><span class="line">!!&apos;&apos; // false</span><br><span class="line">!!NaN // false</span><br><span class="line">!!1 // true</span><br><span class="line">!!&apos;false&apos; // true</span><br><span class="line">!![] // true</span><br><span class="line">!!&#123;&#125; // true</span><br><span class="line">!!function()&#123;&#125; // true</span><br><span class="line">!!/foo/ // true</span><br></pre></td></tr></table></figure>
<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (Boolean(false)) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // 无输出</span><br><span class="line"></span><br><span class="line">if (new Boolean(false)) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // true</span><br><span class="line"></span><br><span class="line">if (Boolean(null)) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // 无输出</span><br><span class="line"></span><br><span class="line">if (new Boolean(null)) &#123;</span><br><span class="line">  console.log(&apos;true&apos;);</span><br><span class="line">&#125; // true</span><br></pre></td></tr></table></figure>
<h1 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><code>Number</code>对象是<strong>数值对应的包装对象，<font color="red">可以作为构造函数使用，也可以作为工具函数使用</font></strong>。</p>
<p><strong>作为构造函数时，它用于生成值为数值的<font color="red">对象</font>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var n = new Number(1);</span><br><span class="line">typeof n // &quot;object&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象。</p>
<p><strong>作为工具函数时，它可以将任何类型的值转为数值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(true) // 1</span><br></pre></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>转为数值<code>1</code>。<code>Number</code>作为工具函数的用法，详见《数据类型转换》一章。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>Number</code>对象拥有以下一些属性。</p>
<blockquote>
<p><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。<br><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。<br><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。<br><code>Number.MAX_VALUE</code>：表示最大的正数，相应的，最小的负数为<code>-Number.MAX_VALUE</code>。<br><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近<code>0</code>的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近<code>0</code>的负数为<code>-Number.MIN_VALUE</code>。<br><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。<br><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Number.POSITIVE_INFINITY // Infinity</span><br><span class="line">Number.NEGATIVE_INFINITY // -Infinity</span><br><span class="line">Number.NaN // NaN</span><br><span class="line"></span><br><span class="line">Number.MAX_VALUE</span><br><span class="line">// 1.7976931348623157e+308</span><br><span class="line">Number.MAX_VALUE &lt; Infinity</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">Number.MIN_VALUE</span><br><span class="line">// 5e-324</span><br><span class="line">Number.MIN_VALUE &gt; 0</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">Number.MAX_SAFE_INTEGER // 9007199254740991</span><br><span class="line">Number.MIN_SAFE_INTEGER // -9007199254740991</span><br></pre></td></tr></table></figure>
<h2 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h2><p><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关。</p>
<h3 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h3><p><code>Number</code>对象部署了自己的<code>toString</code>方法，<strong>用来将一个数值转为字符串形式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(10).toString() // &quot;10&quot;</span><br></pre></td></tr></table></figure>
<p><strong><code>toString</code>方法可以接受一个参数，表示输出的进制</strong>。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(10).toString(2) // &quot;1010&quot;</span><br><span class="line">(10).toString(8) // &quot;12&quot;</span><br><span class="line">(10).toString(16) // &quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。<font color="red">如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错</font>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.toString(2)</span><br><span class="line">// SyntaxError: Unexpected token ILLEGAL</span><br></pre></td></tr></table></figure>
<p>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还<strong>可以在<code>10</code>后面加两个点，<font color="red">JavaScript 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性</font>，从而得到正确结果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10..toString(2)</span><br><span class="line">// &quot;1010&quot;</span><br><span class="line"></span><br><span class="line">// 其他方法还包括</span><br><span class="line">10 .toString(2) // &quot;1010&quot;</span><br><span class="line">10.0.toString(2) // &quot;1010&quot;</span><br></pre></td></tr></table></figure>
<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10.5.toString() // &quot;10.5&quot;</span><br><span class="line">10.5.toString(2) // &quot;1010.1&quot;</span><br><span class="line">10.5.toString(8) // &quot;12.4&quot;</span><br><span class="line">10.5.toString(16) // &quot;a.8&quot;</span><br></pre></td></tr></table></figure>
<p>通过方括号运算符也可以调用<code>toString</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10[&apos;toString&apos;](2) // &quot;1010&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong><code>toString</code>方法<font color="red">只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法</font></strong>。</p>
<h3 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h3><p><code>toFixed</code>方法<strong>先将一个数转为指定位数的小数，然后返回这个小数对应的字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(10).toFixed(2) // &quot;10.00&quot;</span><br><span class="line">10.005.toFixed(2) // &quot;10.01&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>10</code>和<code>10.005</code>转成<code>2</code>位小数，其中<code>10</code>必须放在括号里，否则后面的点会被处理成小数点。</p>
<p><strong><code>toFixed</code>方法的参数为小数位数，<font color="red">有效范围为<code>0</code>到<code>20</code></font>，超出这个范围将抛出 <code>RangeError</code> 错误。</strong></p>
<h3 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h3><p><code>toExponential</code>方法<strong>用于将一个数转为科学计数法形式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(10).toExponential()  // &quot;1e+1&quot;</span><br><span class="line">(10).toExponential(1) // &quot;1.0e+1&quot;</span><br><span class="line">(10).toExponential(2) // &quot;1.00e+1&quot;</span><br><span class="line"></span><br><span class="line">(1234).toExponential()  // &quot;1.234e+3&quot;</span><br><span class="line">(1234).toExponential(1) // &quot;1.2e+3&quot;</span><br><span class="line">(1234).toExponential(2) // &quot;1.23e+3&quot;</span><br></pre></td></tr></table></figure>
<p><code>toExponential</code>方法的<strong>参数是小数点后有效数字的位数，范围为<code>0</code>到<code>20</code>，超出这个范围，会抛出一个 <code>RangeError</code> 错误</strong>。</p>
<h3 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h3><p><code>toPrecision</code>方法用于将一个数转为指定位数的有效数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(12.34).toPrecision(1) // &quot;1e+1&quot;</span><br><span class="line">(12.34).toPrecision(2) // &quot;12&quot;</span><br><span class="line">(12.34).toPrecision(3) // &quot;12.3&quot;</span><br><span class="line">(12.34).toPrecision(4) // &quot;12.34&quot;</span><br><span class="line">(12.34).toPrecision(5) // &quot;12.340&quot;</span><br></pre></td></tr></table></figure>
<p><code>toPrecision</code>方法的参数为有效数字的位数，范围是<code>1</code>到<code>21</code>，超出这个范围会抛出<code>RangeError</code>错误。</p>
<p><code>toPrecision</code>方法<strong>用于四舍五入时不太可靠</strong>，跟浮点数不是精确储存有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(12.35).toPrecision(3) // &quot;12.3&quot;</span><br><span class="line">(12.25).toPrecision(3) // &quot;12.3&quot;</span><br><span class="line">(12.15).toPrecision(3) // &quot;12.2&quot;</span><br><span class="line">(12.45).toPrecision(3) // &quot;12.4&quot;</span><br></pre></td></tr></table></figure>
<h2 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>与其他对象一样，<strong><code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.add = function (x) &#123;</span><br><span class="line">  return this + x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">8[&apos;add&apos;](2) // 10</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法。在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就可以调用<code>add</code>方法了。由于<code>add</code>方法返回的还是数值，所以可以链式运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.subtract = function (x) &#123;</span><br><span class="line">  return this - x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(8).add(2).subtract(4)</span><br><span class="line">// 6</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用。</p>
<p>我们还可以部署更复杂的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.iterate = function () &#123;</span><br><span class="line">  var result = [];</span><br><span class="line">  for (var i = 0; i &lt;= this; i++) &#123;</span><br><span class="line">    result.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(8).iterate()</span><br><span class="line">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，将一个数值自动遍历为一个数组。</p>
<p>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，<strong>数值本身是无法自定义属性的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n = 1;</span><br><span class="line">n.x = 1;</span><br><span class="line">n.x // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是<strong>因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来</strong>。</p>
<h1 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p><code>String</code>对象<strong>是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;abc&apos;;</span><br><span class="line">var s2 = new String(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">typeof s1 // &quot;string&quot;</span><br><span class="line">typeof s2 // &quot;object&quot;</span><br><span class="line"></span><br><span class="line">s2.valueOf() // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>s1</code>是字符串，<code>s2</code>是对象。由于<code>s2</code>是字符串对象，<code>s2.valueOf</code>方法返回的就是它所对应的原始字符串。</p>
<p><strong>字符串对象是一个类似数组的对象</strong>（很像数组，但不是数组）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new String(&apos;abc&apos;)</span><br><span class="line">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br><span class="line"></span><br><span class="line">(new String(&apos;abc&apos;))[1] // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值。</p>
<p>除了用作构造函数，<strong><code>String</code>对象还可以当作工具方法使用，将任意类型的值转为字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(true) // &quot;true&quot;</span><br><span class="line">String(5) // &quot;5&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码将布尔值<code>ture</code>和数值5，分别转换为字符串。</p>
<h2 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p><code>String</code>对象提供的<strong>静态方法（即<font color="red">定义在对象本身，而不是定义在对象实例的方法</font>）</strong>，主要是<code>String.fromCharCode()</code>。该方法的<strong>参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode() // &quot;&quot;</span><br><span class="line">String.fromCharCode(97) // &quot;a&quot;</span><br><span class="line">String.fromCharCode(104, 101, 108, 108, 111)</span><br><span class="line">// &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p>
<p>注意，该方法不支持 Unicode 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 <code>65535</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(0x20BB7)</span><br><span class="line">// &quot;ஷ&quot;</span><br><span class="line">String.fromCharCode(0x20BB7) === String.fromCharCode(0x0BB7)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就<strong>会忽略多出的位</strong>（即忽略<code>0x20BB7</code>里面的<code>2</code>）。</p>
<p>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(0xD842, 0xDFB7)</span><br><span class="line">// &quot;𠮷&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 UTF-16 编码方法决定。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h3><p>字符串实例的<code>length</code>属性返回字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.length // 3</span><br></pre></td></tr></table></figure>
<h2 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h3><p><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new String(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">s.charAt(1) // &quot;b&quot;</span><br><span class="line">s.charAt(s.length - 1) // &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>这个方法完全可以用数组下标替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charAt(1) // &quot;b&quot;</span><br><span class="line">&apos;abc&apos;[1] // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charAt(-1) // &quot;&quot;</span><br><span class="line">&apos;abc&apos;.charAt(3) // &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="String-prototype-charCodeAt"><a href="#String-prototype-charCodeAt" class="headerlink" title="String.prototype.charCodeAt()"></a>String.prototype.charCodeAt()</h3><p><code>charCodeAt</code>方法<strong>返回字符串指定位置的 Unicode 码点（十进制表示）</strong>，相当于<code>String.fromCharCode()</code>的逆操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charCodeAt(1) // 98</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 Unicode 码点是<code>98</code>。</p>
<p><strong>如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charCodeAt() // 97</span><br></pre></td></tr></table></figure>
<p><strong>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.charCodeAt(-1) // NaN</span><br><span class="line">&apos;abc&apos;.charCodeAt(4) // NaN</span><br></pre></td></tr></table></figure>
<p>注意，<code>charCodeAt</code>方法返回的 Unicode 码点不会大于<code>65536</code>（<code>0xFFFF</code>），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 <code>65536</code>的字符（四个字节的字符），必需连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符。</p>
<h3 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h3><p><code>concat</code>方法<strong>用于连接两个字符串，返回一个新字符串，不改变原字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;abc&apos;;</span><br><span class="line">var s2 = &apos;def&apos;;</span><br><span class="line"></span><br><span class="line">s1.concat(s2) // &quot;abcdef&quot;</span><br><span class="line">s1 // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>该方法可以接受多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;.concat(&apos;b&apos;, &apos;c&apos;) // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var one = 1;</span><br><span class="line">var two = 2;</span><br><span class="line">var three = &apos;3&apos;;</span><br><span class="line"></span><br><span class="line">&apos;&apos;.concat(one, two, three) // &quot;123&quot;</span><br><span class="line">one + two + three // &quot;33&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串。</p>
<h3 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h3><p><code>slice</code>方法<strong>用于从原字符串取出子字符串并返回，不改变原字符串</strong>。它的<strong>第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（<font color="red">不含该位置</font>）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.slice(0, 4) // &quot;Java&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>省略第二个参数，则表示子字符串一直到原字符串结束</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.slice(4) // &quot;Script&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.slice(-6) // &quot;Script&quot;</span><br><span class="line">&apos;JavaScript&apos;.slice(0, -6) // &quot;Java&quot;</span><br><span class="line">&apos;JavaScript&apos;.slice(-2, -1) // &quot;p&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>第一个参数大于第二个参数，<code>slice</code>方法返回一个空字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.slice(2, 1) // &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3><p><code>substring</code>方法<strong>用于从原字符串取出子字符串并返回，不改变原字符串</strong>，跟<code>slice</code>方法很相像。它的<strong>第一个参数表示子字符串的开始位置，第二个位置表示结束位置（<font color="red">返回结果不含该位置</font>）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substring(0, 4) // &quot;Java&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>省略第二个参数，则表示子字符串一直到原字符串的结束</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substring(4) // &quot;Script&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>第二个参数大于第一个参数，<font color="red"><code>substring</code>方法会自动更换两个参数的位置</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substring(10, 4) // &quot;Script&quot;</span><br><span class="line">// 等同于</span><br><span class="line">&apos;JavaScript&apos;.substring(4, 10) // &quot;Script&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果。</p>
<p>如果<strong>参数是负数，<code>substring</code>方法会<font color="red">自动将负数转为<code>0</code></font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;Javascript&apos;.substring(-3) // &quot;JavaScript&quot;</span><br><span class="line">&apos;JavaScript&apos;.substring(4, -3) // &quot;Java&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>&#39;JavaScript&#39;.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>。</p>
<p><strong>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code></strong>。</p>
<h3 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h3><p><code>substr</code>方法<strong>用于从原字符串取出子字符串并返回，不改变原字符串</strong>，跟<code>slice</code>和<code>substring</code>方法的作用相同。</p>
<p><code>substr</code>方法的<strong>第一个参数是子字符串的开始位置（从<code>0</code>开始计算），第二个参数是子字符串的长度</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substr(4, 6) // &quot;Script&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>省略第二个参数，则表示子字符串一直到原字符串的结束。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substr(4) // &quot;Script&quot;</span><br></pre></td></tr></table></figure>
<p>如果<strong>第一个参数是负数，表示倒数计算的字符位置</strong>。如果<strong>第二个参数是负数，将被自动转为<code>0</code>，因此会返回空字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;JavaScript&apos;.substr(-6) // &quot;Script&quot;</span><br><span class="line">&apos;JavaScript&apos;.substr(4, -1) // &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串。</p>
<h3 id="String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>String.prototype.indexOf()，String.prototype.lastIndexOf()</h3><p><code>indexOf</code>方法<strong>用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;hello world&apos;.indexOf(&apos;o&apos;) // 4</span><br><span class="line">&apos;JavaScript&apos;.indexOf(&apos;script&apos;) // -1</span><br></pre></td></tr></table></figure>
<p><code>indexOf</code>方法还可以<strong>接受第二个参数，表示从该位置开始向后匹配</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;hello world&apos;.indexOf(&apos;o&apos;, 6) // 7</span><br></pre></td></tr></table></figure>
<p><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的<strong>区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;hello world&apos;.lastIndexOf(&apos;o&apos;) // 7</span><br></pre></td></tr></table></figure>
<p>另外，<code>lastIndexOf</code>的<strong>第二个参数表示从该位置起向前匹配</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;hello world&apos;.lastIndexOf(&apos;o&apos;, 6) // 4</span><br></pre></td></tr></table></figure>
<h3 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h3><p><code>trim</code>方法<strong>用于去除字符串两端的空格，返回一个新字符串，不改变原字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;  hello world  &apos;.trim()</span><br><span class="line">// &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>该方法去除的不仅是<strong>空格</strong>，还包括<strong>制表符（<code>\t</code>、<code>\v</code>）</strong>、<strong>换行符（<code>\n</code>）</strong>和<strong>回车符（<code>\r</code>）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\r\nabc \t&apos;.trim() // &apos;abc&apos;</span><br></pre></td></tr></table></figure>
<h3 id="String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>String.prototype.toLowerCase()，String.prototype.toUpperCase()</h3><p><strong><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写</strong>。它们都<strong>返回一个新字符串，不改变原字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;Hello World&apos;.toLowerCase()</span><br><span class="line">// &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">&apos;Hello World&apos;.toUpperCase()</span><br><span class="line">// &quot;HELLO WORLD&quot;</span><br></pre></td></tr></table></figure>
<h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p><code>match</code>方法<strong>用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;) // [&quot;at&quot;]</span><br><span class="line">&apos;cat, bat, sat, fat&apos;.match(&apos;xt&apos;) // null</span><br></pre></td></tr></table></figure>
<p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var matches = &apos;cat, bat, sat, fat&apos;.match(&apos;at&apos;);</span><br><span class="line">matches.index // 1</span><br><span class="line">matches.input // &quot;cat, bat, sat, fat&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，如果<code>match</code>没有找到匹配，返回了<code>null</code>，则调用<code>.index</code>和<code>.input</code>会抛出<code>TypeError</code>错误。</p>
<p><code>match</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一章。</p>
<h3 id="String-prototype-search-，String-prototype-replace"><a href="#String-prototype-search-，String-prototype-replace" class="headerlink" title="String.prototype.search()，String.prototype.replace()"></a>String.prototype.search()，String.prototype.replace()</h3><p><code>search</code>方法的用法基本等同于<code>match</code>，但是<strong>返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat, bat, sat, fat&apos;.search(&apos;at&apos;) // 1</span><br></pre></td></tr></table></figure>
<p><code>search</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<p><code>replace</code>方法<strong>用于替换匹配的子字符串，一般情况下只替换第一个匹配（<font color="red">除非使用带有g修饰符的正则表达式</font>）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot;</span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p><code>split</code>方法<strong>按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split(&apos;&apos;) // [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>如果<strong>省略参数，则返回数组的唯一成员就是原字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split() // [&quot;a|b|c&quot;]</span><br></pre></td></tr></table></figure>
<p>注意，<strong>分割规则为空字符串和省略参数是不一样的。</strong></p>
<p>如果<strong>满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a||c&apos;.split(&apos;|&apos;) // [&apos;a&apos;, &apos;&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>如果<strong>满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;|b|c&apos;.split(&apos;|&apos;) // [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&apos;a|b|&apos;.split(&apos;|&apos;) // [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>
<p><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 0) // []</span><br><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 1) // [&quot;a&quot;]</span><br><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 2) // [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 3) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&apos;a|b|c&apos;.split(&apos;|&apos;, 4) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数。</p>
<p><code>split</code>方法还可以使用正则表达式作为参数，详见《正则表达式》一节。</p>
<h3 id="String-prototype-localeCompare"><a href="#String-prototype-localeCompare" class="headerlink" title="String.prototype.localeCompare()"></a>String.prototype.localeCompare()</h3><p><code>localeCompare</code>方法<strong>用于比较两个字符串。它返回一个整数，如果小于<code>0</code>，表示第一个字符串小于第二个字符串；如果等于<code>0</code>，表示两者相等；如果大于<code>0</code>，表示第一个字符串大于第二个字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;apple&apos;.localeCompare(&apos;banana&apos;) // -1</span><br><span class="line">&apos;apple&apos;.localeCompare(&apos;apple&apos;) // 0</span><br></pre></td></tr></table></figure>
<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，<strong><font color="red">正常情况下，大写的英文字母小于小写字母</font>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;B&apos; &gt; &apos;a&apos; // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code>B</code>的码点是<code>66</code>，而<code>a</code>的码点是<code>97</code>。</p>
<p>但是，<font color="red"><code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面</font>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;B&apos;.localeCompare(&apos;a&apos;) // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>localeCompare</code>方法返回整数<code>1</code>，表示<code>B</code>较大。</p>
<p><code>localeCompare</code>还可以有<strong>第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;ä&apos;.localeCompare(&apos;z&apos;, &apos;de&apos;) // -1</span><br><span class="line">&apos;ä&apos;.localeCompare(&apos;z&apos;, &apos;sv&apos;) // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>。</p>
<h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><p><strong><code>Math</code>是 JavaScript 的原生对象，提供各种数学功能</strong>。该对象<strong><font color="red">不是构造函数，不能生成实例，所有的属性和方法都必须在<code>Math</code>对象上调用</font></strong>。</p>
<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p><code>Math</code>对象的静态属性，<strong>提供</strong>以下<strong>一些数学常数</strong>。</p>
<blockquote>
<p><code>Math.E</code>：常数<code>e</code>。<br><code>Math.LN2</code>：2 的自然对数。<br><code>Math.LN10</code>：10 的自然对数。<br><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。<br><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。<br><code>Math.PI</code>：常数 Pi。<br><code>Math.SQRT1_2</code>：0.5 的平方根。<br><code>Math.SQRT2</code>：2 的平方根。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.E // 2.718281828459045</span><br><span class="line">Math.LN2 // 0.6931471805599453</span><br><span class="line">Math.LN10 // 2.302585092994046</span><br><span class="line">Math.LOG2E // 1.4426950408889634</span><br><span class="line">Math.LOG10E // 0.4342944819032518</span><br><span class="line">Math.PI // 3.141592653589793</span><br><span class="line">Math.SQRT1_2 // 0.7071067811865476</span><br><span class="line">Math.SQRT2 // 1.4142135623730951</span><br></pre></td></tr></table></figure>
<p>这些属性都是只读的，不能修改。</p>
<h2 id="静态方法-2"><a href="#静态方法-2" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Math</code>对象提供以下一些静态方法。</p>
<blockquote>
<p><code>Math.abs()</code>：绝对值<br><code>Math.ceil()</code>：向上取整，比如2.3会取3<br><code>Math.floor()</code>：向下取整，比如2.8会取2<br><code>Math.max()</code>：最大值<br><code>Math.min()</code>：最小值<br><code>Math.pow()</code>：指数运算<br><code>Math.sqrt()</code>：平方根<br><code>Math.log()</code>：自然对数<br><code>Math.exp()</code>：e的指数<br><code>Math.round()</code>：四舍五入<br><code>Math.random()</code>：随机数</p>
</blockquote>
<h3 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h3><p><code>Math.abs</code>方法<strong>返回参数值的绝对值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(1) // 1</span><br><span class="line">Math.abs(-1) // 1</span><br></pre></td></tr></table></figure>
<h3 id="Math-max-，Math-min"><a href="#Math-max-，Math-min" class="headerlink" title="Math.max()，Math.min()"></a>Math.max()，Math.min()</h3><p><code>Math.max</code>方法<strong>返回参数之中最大的那个值，<code>Math.min</code>返回最小的那个值。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.max(2, -1, 5) // 5</span><br><span class="line">Math.min(2, -1, 5) // -1</span><br><span class="line">Math.min() // Infinity</span><br><span class="line">Math.max() // -Infinity</span><br></pre></td></tr></table></figure>
<h3 id="Math-floor-，Math-ceil"><a href="#Math-floor-，Math-ceil" class="headerlink" title="Math.floor()，Math.ceil()"></a>Math.floor()，Math.ceil()</h3><p><code>Math.floor</code>方法<strong>返回<font color="red">小于</font>参数值的最大整数（地板值）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(3.2) // 3</span><br><span class="line">Math.floor(-3.2) // -4</span><br></pre></td></tr></table></figure>
<p><code>Math.ceil</code>方法返回<font color="red">大于</font>参数值的最小整数（天花板值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(3.2) // 4</span><br><span class="line">Math.ceil(-3.2) // -3</span><br></pre></td></tr></table></figure>
<p>这两个方法可以结合起来，实现一个<strong>总是返回数值的整数部分的函数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ToInteger(x) &#123;</span><br><span class="line">  x = Number(x);</span><br><span class="line">  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToInteger(3.2) // 3</span><br><span class="line">ToInteger(3.5) // 3</span><br><span class="line">ToInteger(3.8) // 3</span><br><span class="line">ToInteger(-3.2) // -3</span><br><span class="line">ToInteger(-3.5) // -3</span><br><span class="line">ToInteger(-3.8) // -3</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>不管正数或负数</strong>，<code>ToInteger</code>函数<strong>总是返回一个数值的整数部分</strong>。</p>
<h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h3><p><code>Math.round</code>方法<strong>用于四舍五入</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.round(0.1) // 0</span><br><span class="line">Math.round(0.5) // 1</span><br><span class="line">Math.round(0.6) // 1</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.floor(x + 0.5)</span><br></pre></td></tr></table></figure>
<p>注意，<strong>它对负数的处理（主要是对<code>0.5</code>的处理）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.round(-1.1) // -1</span><br><span class="line">Math.round(-1.5) // -1</span><br><span class="line">Math.round(-1.6) // -2</span><br></pre></td></tr></table></figure>
<h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h3><p><code>Math.pow</code>方法<strong>返回以第一个参数为底数、第二个参数为幂的指数值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 2 ** 2</span><br><span class="line">Math.pow(2, 2) // 4</span><br><span class="line">// 等同于 2 ** 3</span><br><span class="line">Math.pow(2, 3) // 8</span><br></pre></td></tr></table></figure>
<p>下面是计算圆面积的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var radius = 20;</span><br><span class="line">var area = Math.PI * Math.pow(radius, 2);</span><br></pre></td></tr></table></figure>
<h3 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h3><p><code>Math.sqrt</code>方法<strong>返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(4) // 2</span><br><span class="line">Math.sqrt(-4) // NaN</span><br></pre></td></tr></table></figure>
<h3 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h3><p><code>Math.log</code>方法<strong>返回以<code>e</code>为底的自然对数值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.log(Math.E) // 1</span><br><span class="line">Math.log(10) // 2.302585092994046</span><br></pre></td></tr></table></figure>
<p>如果要计算以<code>10</code>为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以<code>2</code>为底的对数，可以除以<code>Math.LN2</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.log(100)/Math.LN10 // 2</span><br><span class="line">Math.log(8)/Math.LN2 // 3</span><br></pre></td></tr></table></figure>
<h3 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h3><p><code>Math.exp</code>方法<strong>返回常数<code>e</code>的参数次方</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(1) // 2.718281828459045</span><br><span class="line">Math.exp(3) // 20.085536923187668</span><br></pre></td></tr></table></figure>
<h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p><code>Math.random()</code><strong>返回<code>0</code>到<code>1</code>之间的一个伪随机数，<font color="red">可能等于<code>0</code>，但是一定小于<code>1</code></font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random() // 0.7151307314634323</span><br></pre></td></tr></table></figure>
<p>任意范围的随机数生成函数如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomArbitrary(1.5, 6.5)</span><br><span class="line">// 2.4942810038223864</span><br></pre></td></tr></table></figure>
<p>上面的代码中，假设<code>max-min=a</code>，<code>a</code>即为<code>min</code>到<code>max</code>的距离，用<code>a</code>乘以<code>Math.random()</code>会得到<code>0~a</code>范围内的随机数，再加上<code>min</code>将这个范围进行偏移，就得到了<code>min~(a+min)</code>也就是<code>min~max</code>之间的随机数了。</p>
<p>任意范围的随机整数生成函数如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomInt(1, 6) // 5</span><br></pre></td></tr></table></figure>
<p>返回随机字符的例子如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function random_str(length) &#123;</span><br><span class="line">  var ALPHABET = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;;</span><br><span class="line">  ALPHABET += &apos;abcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">  ALPHABET += &apos;0123456789-_&apos;;</span><br><span class="line">  var str = &apos;&apos;;</span><br><span class="line">  for (var i=0; i &lt; length; ++i) &#123;</span><br><span class="line">    var rand = Math.floor(Math.random() * ALPHABET.length);</span><br><span class="line">    str += ALPHABET.substring(rand, rand + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">random_str(6) // &quot;NdQKOr&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p><code>Math</code>对象还提供一系列三角函数方法。</p>
<blockquote>
<p>Math.sin()：返回参数的正弦（参数为弧度值）<br>Math.cos()：返回参数的余弦（参数为弧度值）<br>Math.tan()：返回参数的正切（参数为弧度值）<br>Math.asin()：返回参数的反正弦（返回值为弧度值）<br>Math.acos()：返回参数的反余弦（返回值为弧度值）<br>Math.atan()：返回参数的反正切（返回值为弧度值）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(0) // 0</span><br><span class="line">Math.cos(0) // 1</span><br><span class="line">Math.tan(0) // 0</span><br><span class="line"></span><br><span class="line">Math.sin(Math.PI / 2) // 1</span><br><span class="line"></span><br><span class="line">Math.asin(1) // 1.5707963267948966</span><br><span class="line">Math.acos(1) // 0</span><br><span class="line">Math.atan(1) // 0.7853981633974483</span><br></pre></td></tr></table></figure>
<h1 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h1><p><code>Date</code>对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>
<h2 id="普通函数的用法"><a href="#普通函数的用法" class="headerlink" title="普通函数的用法"></a>普通函数的用法</h2><p><strong><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date()</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date(2000, 1, 1)</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码说明，<strong><font color="red">无论有没有参数，直接调用<code>Date</code>总是返回当前时间</font></strong>。</p>
<h2 id="构造函数的用法"><a href="#构造函数的用法" class="headerlink" title="构造函数的用法"></a>构造函数的用法</h2><p><code>Date</code>还<strong>可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例</strong>。<strong>如果不加参数，实例代表的就是当前时间</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date();</span><br></pre></td></tr></table></figure>
<p><code>Date</code>实例有一个独特的地方。<strong>其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对<code>Date</code>实例求值，返回的是一个字符串，代表该实例对应的时间。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date();</span><br><span class="line"></span><br><span class="line">today</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">today.toString()</span><br><span class="line">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>today</code>是<code>Date</code>的实例，直接求值等同于调用<code>toString</code>方法。</p>
<p><strong>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 参数为时间零点开始计算的毫秒数</span><br><span class="line">new Date(1378218728000)</span><br><span class="line">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">// 参数为日期字符串</span><br><span class="line">new Date(&apos;January 6, 2013&apos;);</span><br><span class="line">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">// 参数为多个整数，</span><br><span class="line">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="line">new Date(2013, 0, 1, 0, 0, 0, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>关于<code>Date</code>构造函数的参数，有几点说明。</p>
<p>第一点，<strong>参数可以是负整数，代表1970年元旦之前的时间</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(-1378218728000)</span><br><span class="line">// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>第二点，<strong>只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Date(&apos;2013-2-15&apos;)</span><br><span class="line">new Date(&apos;2013/2/15&apos;)</span><br><span class="line">new Date(&apos;02/15/2013&apos;)</span><br><span class="line">new Date(&apos;2013-FEB-15&apos;)</span><br><span class="line">new Date(&apos;FEB, 15, 2013&apos;)</span><br><span class="line">new Date(&apos;FEB 15, 2013&apos;)</span><br><span class="line">new Date(&apos;Feberuary, 15, 2013&apos;)</span><br><span class="line">new Date(&apos;Feberuary 15, 2013&apos;)</span><br><span class="line">new Date(&apos;15 Feb 2013&apos;)</span><br><span class="line">new Date(&apos;15, Feberuary, 2013&apos;)</span><br><span class="line">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面多种日期字符串的写法，返回的都是同一个时间。</p>
<p>第三，<strong>参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(2013)</span><br><span class="line">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>2013</code>被解释为毫秒数，而不是年份。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Date(2013, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line">new Date(2013, 0, 1)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line">new Date(2013, 0, 1, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line">new Date(2013, 0, 1, 0, 0, 0, 0)</span><br><span class="line">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点。</p>
<p>最后，各个参数的取值范围如下。</p>
<blockquote>
<p>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表<code>1910</code>年。如果是负数，表示公元前。<br>月：<code>0</code>表示一月，依次类推，<code>11</code>表示<code>12</code>月。<br>日：<code>1</code>到<code>31</code>。<br>小时：<code>0</code>到<code>23</code>。<br>分钟：<code>0</code>到<code>59</code>。<br>秒：<code>0</code>到<code>59</code><br>毫秒：<code>0</code>到<code>999</code>。</p>
</blockquote>
<p>注意，<strong>月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code></strong>。</p>
<p>这些<strong>参数如果超出了正常范围，会被自动折算</strong>。比如，如果月设为<code>15</code>，就折算为下一年的<code>4</code>月。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Date(2013, 15)</span><br><span class="line">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span><br><span class="line">new Date(2013, 0, 0)</span><br><span class="line">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天。</p>
<p><strong>参数还可以使用负数，表示扣去的时间</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Date(2013, -1)</span><br><span class="line">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span><br><span class="line">new Date(2013, 0, -1)</span><br><span class="line">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间。对月使用<code>-1</code>表示扣去一个月，对日使用<code>-1</code>表示扣去一天。</p>
<h2 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h2><p><strong>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。</strong>所以，<strong>两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Date(2000, 2, 1);</span><br><span class="line">var d2 = new Date(2000, 3, 1);</span><br><span class="line"></span><br><span class="line">d2 - d1</span><br><span class="line">// 2678400000</span><br><span class="line">d2 + d1</span><br><span class="line">// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="静态方法-3"><a href="#静态方法-3" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p><strong><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</strong>，相当于 Unix 时间戳乘以<code>1000</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date.now() // 1364026285194</span><br></pre></td></tr></table></figure>
<h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p>
<p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析，请看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date.parse(&apos;Aug 9, 1995&apos;)</span><br><span class="line">Date.parse(&apos;January 26, 2011 13:51:50&apos;)</span><br><span class="line">Date.parse(&apos;Mon, 25 Dec 1995 13:30:00 GMT&apos;)</span><br><span class="line">Date.parse(&apos;Mon, 25 Dec 1995 13:30:00 +0430&apos;)</span><br><span class="line">Date.parse(&apos;2011-10-10&apos;)</span><br><span class="line">Date.parse(&apos;2011-10-10T14:48:00&apos;)</span><br></pre></td></tr></table></figure>
<p>上面的日期字符串都可以解析。</p>
<p>如果解析失败，返回<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date.parse(&apos;xxx&apos;) // NaN</span><br></pre></td></tr></table></figure>
<h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p><strong><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">Date.UTC(2011, 0, 1, 2, 3, 4, 567)</span><br><span class="line">// 1293847384567</span><br></pre></td></tr></table></figure>
<p><strong>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从<code>0</code>开始计算，日期从<code>1</code>开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间</strong>。</p>
<h2 id="实例方法-4"><a href="#实例方法-4" class="headerlink" title="实例方法"></a>实例方法</h2><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>
<blockquote>
<p><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。<br><code>get</code>类：获取<code>Date</code>对象的日期和时间。<br><code>set</code>类：设置<code>Date</code>对象的日期和时间。</p>
</blockquote>
<h3 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h3><p><strong><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于<code>getTime</code>方法</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line"></span><br><span class="line">d.valueOf() // 1362790014817</span><br><span class="line">d.getTime() // 1362790014817</span><br></pre></td></tr></table></figure>
<p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var start = new Date();</span><br><span class="line">// ...</span><br><span class="line">var end = new Date();</span><br><span class="line">var elapsed = end - start;</span><br></pre></td></tr></table></figure>
<h3 id="to-类方法"><a href="#to-类方法" class="headerlink" title="to 类方法"></a>to 类方法</h3><h4 id="Date-prototype-toString"><a href="#Date-prototype-toString" class="headerlink" title="Date.prototype.toString()"></a>Date.prototype.toString()</h4><p><code>toString</code>方法返回一个完整的日期字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br><span class="line">d</span><br><span class="line">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<p>因为<strong><code>toString</code>是默认的调用方法</strong>，所以如果直接读取<code>Date</code>实例，就相当于调用这个方法。</p>
<h4 id="Date-prototype-toUTCString"><a href="#Date-prototype-toUTCString" class="headerlink" title="Date.prototype.toUTCString()"></a>Date.prototype.toUTCString()</h4><p><code>toUTCString</code>方法返回对应的 UTC 时间，也就是比北京时间晚<code>8</code>个小时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toUTCString()</span><br><span class="line">// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Date-prototype-toISOString"><a href="#Date-prototype-toISOString" class="headerlink" title="Date.prototype.toISOString()"></a>Date.prototype.toISOString()</h4><p><code>toISOString</code>方法返回对应时间的 ISO8601 写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toISOString()</span><br><span class="line">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></pre></td></tr></table></figure>
<p>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间。</p>
<h4 id="Date-prototype-toJSON"><a href="#Date-prototype-toJSON" class="headerlink" title="Date.prototype.toJSON()"></a>Date.prototype.toJSON()</h4><p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，<strong>与<code>toISOString</code>方法的返回结果完全相同</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toJSON()</span><br><span class="line">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Date-prototype-toDateString"><a href="#Date-prototype-toDateString" class="headerlink" title="Date.prototype.toDateString()"></a>Date.prototype.toDateString()</h4><p><code>toDateString</code>方法返回日期字符串（<strong>不含小时、分和秒</strong>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line">d.toDateString() // &quot;Tue Jan 01 2013&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Date-prototype-toTimeString"><a href="#Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toTimeString()"></a>Date.prototype.toTimeString()</h4><p><code>toTimeString</code>方法返回时间字符串（<strong>不含年月日</strong>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line">d.toTimeString() // &quot;00:00:00 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Date-prototype-toLocaleDateString"><a href="#Date-prototype-toLocaleDateString" class="headerlink" title="Date.prototype.toLocaleDateString()"></a>Date.prototype.toLocaleDateString()</h4><p><code>toLocaleDateString</code>方法返回一个字符串，代表<strong>日期的当地写法</strong>（不含小时、分和秒）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="line">// 英文版浏览器为&quot;1/1/2013&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Date-prototype-toLocaleTimeString"><a href="#Date-prototype-toLocaleTimeString" class="headerlink" title="Date.prototype.toLocaleTimeString()"></a>Date.prototype.toLocaleTimeString()</h4><p><code>toLocaleTimeString</code>方法返回一个字符串，代表<strong>时间的当地写法</strong>（不含年月日）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></pre></td></tr></table></figure>
<h3 id="get-类方法"><a href="#get-类方法" class="headerlink" title="get 类方法"></a>get 类方法</h3><p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值。</p>
<blockquote>
<p><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法。<br><code>getDate()</code>：返回实例对象对应每个月的几号（<strong>从<code>1</code>开始</strong>）。<br><code>getDay()</code>：返回星期几，星期日为<code>0</code>，星期一为<code>1</code>，以此类推。<br><code>getYear()</code>：返回距离<code>1900</code>的年数。<br><code>getFullYear()</code>：返回四位的年份。<br><code>getMonth()</code>：返回月份（<code>0</code>表示1月，<code>11</code>表示12月）。<br><code>getHours()</code>：返回小时（<code>0</code>-<code>23</code>）。<br><code>getMilliseconds()</code>：返回毫秒（<code>0</code>-<code>999</code>）。<br><code>getMinutes()</code>：返回分钟（<code>0</code>-<code>59</code>）。<br><code>getSeconds()</code>：返回秒（<code>0</code>-<code>59</code>）。<br><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以<strong>分钟</strong>表示，返回结果考虑到了夏令时因素。</p>
</blockquote>
<p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样。</p>
<blockquote>
<p>分钟和秒：0 到 59<br>小时：0 到 23<br>星期：0（星期天）到 6（星期六）<br>日期：1 到 31<br>月份：0（一月）到 11（十二月）<br>年份：距离1900年的年数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(&apos;January 6, 2013&apos;);</span><br><span class="line"></span><br><span class="line">d.getDate() // 6</span><br><span class="line">d.getMonth() // 0</span><br><span class="line">d.getYear() // 113</span><br><span class="line">d.getFullYear() // 2013</span><br><span class="line">d.getTimezoneOffset() // -480</span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少<code>480</code>分钟，即当前时区比 UTC 早<code>8</code>个小时。</p>
<p>下面是一个例子，计算本年度还剩下多少天。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function leftDays() &#123;</span><br><span class="line">  var today = new Date();</span><br><span class="line">  var endYear = new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999);</span><br><span class="line">  var msPerDay = 24 * 60 * 60 * 1000;</span><br><span class="line">  return Math.round((endYear.getTime() - today.getTime()) / msPerDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p>
<blockquote>
<p><code>getUTCDate()</code><br><code>getUTCFullYear()</code><br><code>getUTCMonth()</code><br><code>getUTCDay()</code><br><code>getUTCHours()</code><br><code>getUTCMinutes()</code><br><code>getUTCSeconds()</code><br><code>getUTCMilliseconds()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(&apos;January 6, 2013&apos;);</span><br><span class="line"></span><br><span class="line">d.getDate() // 6</span><br><span class="line">d.getUTCDate() // 5</span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5。</p>
<h3 id="set-类方法"><a href="#set-类方法" class="headerlink" title="set 类方法"></a>set 类方法</h3><p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面。</p>
<blockquote>
<p><code>setDate(date)</code>：设置实例对象对应的每个月的几号（<code>1</code>-<code>31</code>），返回改变后毫秒时间戳。<br><code>setYear(year)</code>: 设置距离<code>1900</code>年的年数。<br><code>setFullYear(year [, month, date])</code>：设置四位年份。<br><code>setHours(hour [, min, sec, ms])</code>：设置小时（<code>0</code>-<code>23</code>）。<br><code>setMilliseconds()</code>：设置毫秒（<code>0</code>-<code>999</code>）。<br><code>setMinutes(min [, sec, ms])</code>：设置分钟（<code>0</code>-<code>59</code>）。<br><code>setMonth(month [, date])</code>：设置月份（<code>0</code>-<code>11</code>）。<br><code>setSeconds(sec [, ms])</code>：设置秒（<code>0</code>-<code>59</code>）。<br><code>setTime(milliseconds)</code>：设置毫秒时间戳。</p>
</blockquote>
<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从<code>0</code>开始算的，即<code>0</code>是1月，<code>11</code>是12月。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date (&apos;January 6, 2013&apos;);</span><br><span class="line"></span><br><span class="line">d // Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line">d.setDate(9) // 1357660800000</span><br><span class="line">d // Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p><strong><code>set*</code>方法的参数都会自动折算</strong>。以<code>setDate</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Date(&apos;January 6, 2013&apos;);</span><br><span class="line"></span><br><span class="line">d1.setDate(32) // 1359648000000</span><br><span class="line">d1 // Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">var d2 = new Date (&apos;January 6, 2013&apos;);</span><br><span class="line"></span><br><span class="line">d.setDate(-1) // 1356796800000</span><br><span class="line">d // Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line"></span><br><span class="line">// 将日期向后推1000天</span><br><span class="line">d.setDate(d.getDate() + 1000);</span><br><span class="line">// 将时间设为6小时后</span><br><span class="line">d.setHours(d.getHours() + 6);</span><br><span class="line">// 将年份设为去年</span><br><span class="line">d.setFullYear(d.getFullYear() - 1);</span><br></pre></td></tr></table></figure>
<p><code>set*</code>系列方法除了<code>setTime()</code>和<code>setYear()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p>
<blockquote>
<p><code>setUTCDate()</code><br><code>setUTCFullYear()</code><br><code>setUTCHours()</code><br><code>setUTCMilliseconds()</code><br><code>setUTCMinutes()</code><br><code>setUTCMonth()</code><br><code>setUTCSeconds()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(&apos;January 6, 2013&apos;);</span><br><span class="line">d.getUTCHours() // 16</span><br><span class="line">d.setUTCHours(22) // 1357423200000</span><br><span class="line">d // Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>
<p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。</p>
<h1 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p><strong>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法</strong>，有点像字符串的模板，<strong>常常用来按照“给定模式”匹配文本</strong>。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>
<p>新建正则表达式有两种方法。<strong>一种是使用字面量，以斜杠表示开始和结束</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /xyz/;</span><br></pre></td></tr></table></figure>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(&apos;xyz&apos;);</span><br></pre></td></tr></table></figure>
<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。<strong>它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以<font color="red">前者的效率较高</font>。而且，前者比较便利和直观，所以<font color="red">实际应用中，基本上都采用字面量定义正则表达式</font></strong>。</p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);</span><br><span class="line">// 等价于</span><br><span class="line">var regex = /xyz/i;</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h2 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h2><p>正则对象的实例属性分成两类。</p>
<p>一类是<strong>修饰符相关，返回一个布尔值，表示对应的修饰符是否设置</strong>。</p>
<blockquote>
<p><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。<br><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。<br><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</p>
</blockquote>
<p>上面三个属性都是只读的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r = /abc/igm;</span><br><span class="line"></span><br><span class="line">r.ignoreCase // true</span><br><span class="line">r.global // true</span><br><span class="line">r.multiline // true</span><br></pre></td></tr></table></figure>
<p>另一类是<strong>与修饰符无关的属性</strong>，主要是下面两个。</p>
<blockquote>
<p><code>RegExp.prototype.lastIndex</code>：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在设置了<code>g</code>修饰符、进行连续搜索时有意义，详细介绍请看后文。<br><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = /abc/igm;</span><br><span class="line"></span><br><span class="line">r.lastIndex // 0</span><br><span class="line">r.source // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<h2 id="实例方法-5"><a href="#实例方法-5" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h3><p>正则实例对象的<strong><code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cat/.test(&apos;cats and dogs&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p><strong>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都<font color="red">从上一次结束的位置开始向后匹配</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var r = /x/g;</span><br><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line"></span><br><span class="line">r.lastIndex // 0</span><br><span class="line">r.test(s) // true</span><br><span class="line"></span><br><span class="line">r.lastIndex // 2</span><br><span class="line">r.test(s) // true</span><br><span class="line"></span><br><span class="line">r.lastIndex // 4</span><br><span class="line">r.test(s) // false</span><br></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p><strong>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r = /x/g;</span><br><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line"></span><br><span class="line">r.lastIndex = 4;</span><br><span class="line">r.test(s) // false</span><br></pre></td></tr></table></figure>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回<code>false</code>。</p>
<p><strong><code>lastIndex</code>属性只对同一个正则表达式有效</strong>，所以下面这样写是错误的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">while (/a/g.test(&apos;babaa&apos;)) count++;</span><br></pre></td></tr></table></figure>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于<code>0</code>。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(&apos;&apos;).test(&apos;abc&apos;)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<h3 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h3><p>正则实例对象的<strong><code>exec</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line">var r1 = /x/;</span><br><span class="line">var r2 = /y/;</span><br><span class="line"></span><br><span class="line">r1.exec(s) // [&quot;x&quot;]</span><br><span class="line">r2.exec(s) // null</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加<code>1</code>。因为除了和圆括号匹配的值之外，还有一个整体匹配的结果。如果整体不匹配那么直接返回<code>null</code>，并且不会出现括号内不匹配但整体匹配了的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line">var r = /_(x)/;</span><br><span class="line"></span><br><span class="line">r.exec(s) // [&quot;_x&quot;, &quot;x&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>exec</code>方法，返回一个数组。<strong>第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</strong></p>
<p><code>exec</code>方法的返回数组还包含以下两个属性：</p>
<blockquote>
<p><code>input</code>：整个原字符串。<br><code>index</code>：整个模式匹配成功的开始位置（从<code>0</code>开始计数）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var r = /a(b+)a/;</span><br><span class="line">var arr = r.exec(&apos;_abbba_aba_&apos;);</span><br><span class="line"></span><br><span class="line">arr // [&quot;abbba&quot;, &quot;bbb&quot;]</span><br><span class="line"></span><br><span class="line">arr.index // 1</span><br><span class="line">arr.input // &quot;_abbba_aba_&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>index</code>属性等于<code>1</code>，是因为从原字符串的第二个位置开始匹配成功。</p>
<p><strong>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var reg = /a/g;</span><br><span class="line">var str = &apos;abc_abc_abc&apos;</span><br><span class="line"></span><br><span class="line">var r1 = reg.exec(str);</span><br><span class="line">r1 // [&quot;a&quot;]</span><br><span class="line">r1.index // 0</span><br><span class="line">reg.lastIndex // 1</span><br><span class="line"></span><br><span class="line">var r2 = reg.exec(str);</span><br><span class="line">r2 // [&quot;a&quot;]</span><br><span class="line">r2.index // 4</span><br><span class="line">reg.lastIndex // 5</span><br><span class="line"></span><br><span class="line">var r3 = reg.exec(str);</span><br><span class="line">r3 // [&quot;a&quot;]</span><br><span class="line">r3.index // 8</span><br><span class="line">reg.lastIndex // 9</span><br><span class="line"></span><br><span class="line">var r4 = reg.exec(str);</span><br><span class="line">r4 // null</span><br><span class="line">reg.lastIndex // 0</span><br></pre></td></tr></table></figure>
<p>上面代码连续用了四次<code>exec</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var reg = /a/g;</span><br><span class="line">var str = &apos;abc_abc_abc&apos;</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">  var match = reg.exec(str);</span><br><span class="line">  if (!match) break;</span><br><span class="line">  console.log(&apos;#&apos; + match.index + &apos;:&apos; + match[0]);</span><br><span class="line">&#125;</span><br><span class="line">// #0:a</span><br><span class="line">// #4:a</span><br><span class="line">// #8:a</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要<code>exec</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>
<p><strong>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配</strong>。</p>
<h2 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h2><p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<blockquote>
<p><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。<br><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。<br><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。<br><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</p>
</blockquote>
<h3 id="String-prototype-match-1"><a href="#String-prototype-match-1" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p>字符串实例对象的<strong><code>match</code>方法对字符串进行正则匹配，返回匹配结果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;_x_x&apos;;</span><br><span class="line">var r1 = /x/;</span><br><span class="line">var r2 = /y/;</span><br><span class="line"></span><br><span class="line">s.match(r1) // [&quot;x&quot;]</span><br><span class="line">s.match(r2) // null</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p><strong>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;abba&apos;;</span><br><span class="line">var r = /a/g;</span><br><span class="line"></span><br><span class="line">s.match(r) // [&quot;a&quot;, &quot;a&quot;]</span><br><span class="line">r.exec(s) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效</font>，匹配总是从字符串的第一个字符开始</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = /a|b/g;</span><br><span class="line">r.lastIndex = 7;</span><br><span class="line">&apos;xaxb&apos;.match(r) // [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">r.lastIndex // 0</span><br></pre></td></tr></table></figure>
<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h3 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h3><p>字符串对象的<strong><code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;_x_x&apos;.search(/x/)</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3><p>字符串对象的<strong><code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(search, replacement)</span><br></pre></td></tr></table></figure>
<p>正则表达式<strong>如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值，即<font color="red"><code>g</code>表示全局替换</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;aaa&apos;.replace(&apos;a&apos;, &apos;b&apos;) // &quot;baa&quot;</span><br><span class="line">&apos;aaa&apos;.replace(/a/, &apos;b&apos;) // &quot;baa&quot;</span><br><span class="line">&apos;aaa&apos;.replace(/a/g, &apos;b&apos;) // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>b</code>都被替换掉了。</p>
<p><strong><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;  #id div.class  &apos;;</span><br><span class="line"></span><br><span class="line">str.replace(/^\s+|\s+$/g, &apos;&apos;)</span><br><span class="line">// &quot;#id div.class&quot;</span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<blockquote>
<p><code>$&amp;</code>：匹配的子字符串。<br><code>$`</code>：匹配结果前面的文本。<br><code>$’</code>：匹配结果后面的文本。<br><code>$n</code>：匹配成功的第n组内容，n是从1开始的自然数。<br><code>$$</code>：指代美元符号$。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;hello world&apos;.replace(/(\w+)\s(\w+)/, &apos;$2 $1&apos;)</span><br><span class="line">// &quot;world hello&quot;</span><br><span class="line"></span><br><span class="line">&apos;abc&apos;.replace(&apos;b&apos;, &apos;[$`-$&amp;-$\&apos;]&apos;)</span><br><span class="line">// &quot;a[a-b-c]c&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;3 and 5&apos;.replace(/[0-9]+/g, function (match) &#123;</span><br><span class="line">  return 2 * match;</span><br><span class="line">&#125;)</span><br><span class="line">// &quot;6 and 10&quot;</span><br><span class="line"></span><br><span class="line">var a = &apos;The quick brown fox jumped over the lazy dog.&apos;;</span><br><span class="line">var pattern = /quick|brown|lazy/ig;</span><br><span class="line"></span><br><span class="line">a.replace(pattern, function replacer(match) &#123;</span><br><span class="line">  return match.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">// The QUICK BROWN fox jumped over the LAZY dog.</span><br></pre></td></tr></table></figure>
<p>作为<code>replace</code>方法<strong>第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串</strong>。下面是一个网页模板替换的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var prices = &#123;</span><br><span class="line">  &apos;p1&apos;: &apos;$1.99&apos;,</span><br><span class="line">  &apos;p2&apos;: &apos;$9.99&apos;,</span><br><span class="line">  &apos;p3&apos;: &apos;$5.00&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var template = &apos;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&apos;</span><br><span class="line">  + &apos;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&apos;</span><br><span class="line">  + &apos;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&apos;;</span><br><span class="line"></span><br><span class="line">template.replace(</span><br><span class="line">  /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g,</span><br><span class="line">  function(match, $1, $2, $3, $4)&#123;</span><br><span class="line">    return $1 + $2 + $3 + prices[$2] + $4;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h3 id="String-prototype-split-1"><a href="#String-prototype-split-1" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p>字符串对象的<strong><code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(separator, [limit])</span><br></pre></td></tr></table></figure>
<p>该方法<strong>接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 非正则分隔</span><br><span class="line">&apos;a,  b,c, d&apos;.split(&apos;,&apos;)</span><br><span class="line">// [ &apos;a&apos;, &apos;  b&apos;, &apos;c&apos;, &apos; d&apos; ]</span><br><span class="line"></span><br><span class="line">// 正则分隔，去除多余的空格</span><br><span class="line">&apos;a,  b,c, d&apos;.split(/, */)</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]</span><br><span class="line"></span><br><span class="line">// 指定返回数组的最大成员</span><br><span class="line">&apos;a,  b,c, d&apos;.split(/, */, 2)</span><br><span class="line">[ &apos;a&apos;, &apos;b&apos; ]</span><br></pre></td></tr></table></figure>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。上面的第二段代码，是因为匹配到了<code>,</code>，并且<code>,</code>后跟着的是<code>0</code>个或多个空格，因此能够将逗号+空格的字符匹配出来并作为分割符来分割字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">&apos;aaa*a*&apos;.split(/a*/)</span><br><span class="line">// [ &apos;&apos;, &apos;*&apos;, &apos;*&apos; ]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">&apos;aaa**a*&apos;.split(/a*/)</span><br><span class="line">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码的分割规则是<code>0</code>次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是<code>0</code>个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>
<p><strong>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;aaa*a*&apos;.split(/(a*)/)</span><br><span class="line">// [ &apos;&apos;, &apos;aaa&apos;, &apos;*&apos;, &apos;a&apos;, &apos;*&apos; ]</span><br></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了括号，第一个组匹配是aaa，第二个组匹配是a，它们都作为数组成员返回。</p>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h3><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dog/.test(&apos;old dog&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p><strong>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”</strong>（metacharacters），主要有以下几个。</p>
<h4 id="点字符（"><a href="#点字符（" class="headerlink" title="点字符（.)"></a>点字符（.)</h4><p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c.t/</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意<font color="red">一个</font>字符的情况，只要这三个字符在同一行</strong>，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是<strong>不匹配<code>coot</code></strong>。</p>
<h4 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h4><blockquote>
<p><code>^</code> 表示字符串的开始位置<br><code>$</code> 表示字符串的结束位置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// test必须出现在开始位置</span><br><span class="line">/^test/.test(&apos;test123&apos;) // true</span><br><span class="line"></span><br><span class="line">// test必须出现在结束位置</span><br><span class="line">/test$/.test(&apos;new test&apos;) // true</span><br><span class="line"></span><br><span class="line">// 从开始位置到结束位置只有test</span><br><span class="line">/^test$/.test(&apos;test&apos;) // true</span><br><span class="line">/^test$/.test(&apos;test test&apos;) // false</span><br><span class="line">/^test$/.test(&apos;testtest&apos;) // false</span><br></pre></td></tr></table></figure>
<h4 id="选择符（-）"><a href="#选择符（-）" class="headerlink" title="选择符（|）"></a>选择符（|）</h4><p><strong>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR）</strong>，即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/11|22/.test(&apos;911&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p><strong>多个选择符可以联合使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 匹配fred、barney、betty之中的一个</span><br><span class="line">/fred|barney|betty/</span><br></pre></td></tr></table></figure>
<p><strong>选择符会包括它前后的多个字符</strong>，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。<strong>如果想修改这个行为，可以使用圆括号</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a( |\t)b/.test(&apos;a\tb&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p><strong>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠进行转义</strong>。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/1+1/.test(&apos;1+1&apos;)</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">/1\+1/.test(&apos;1+1&apos;)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p><strong>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\</code>。需要特别注意的是，<font color="red">如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(new RegExp(&apos;1\+1&apos;)).test(&apos;1+1&apos;)</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">(new RegExp(&apos;1\\+1&apos;)).test(&apos;1+1&apos;)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。字符串中使用了一个<code>\</code>将<code>+</code>转义为<code>+</code>本身，此时再放入构造函数中的字符串即为<code>1\+1</code>，就能够正常将加号转义。</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<blockquote>
<p><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是<code>A</code>-<code>Z</code>之中任一个英文字母，用来匹配控制字符。<br><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。<br><code>\n</code> 匹配换行键。<br><code>\r</code> 匹配回车键。<br><code>\t</code> 匹配制表符 tab（U+0009）。<br><code>\v</code> 匹配垂直制表符（U+000B）。<br><code>\f</code> 匹配换页符（U+000C）。<br><code>\0</code> 匹配<code>null</code>字符（U+0000）。<br><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。<br><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</p>
</blockquote>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p><strong>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内</strong>，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.test(&apos;hello world&apos;) // false</span><br><span class="line">/[abc]/.test(&apos;apple&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<h4 id="脱字符（-）"><a href="#脱字符（-）" class="headerlink" title="脱字符（^）"></a>脱字符（^）</h4><p><strong>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配</strong>。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.test(&apos;hello world&apos;) // true</span><br><span class="line">/[^abc]/.test(&apos;bbc&apos;) // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>hello world</code>不包含字母<code>a</code>、<code>b</code>、<code>c</code>中的任一个，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的字母，所以返回<code>false</code>。</p>
<p><strong>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Please yes\nmake my day!&apos;;</span><br><span class="line"></span><br><span class="line">s.match(/yes.*day/) // null</span><br><span class="line">s.match(/yes[^]*day/) // [ &apos;yes\nmake my day&apos;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<p>注意，<strong><font color="red">脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义</font></strong>。</p>
<h4 id="连字符（-）"><a href="#连字符（-）" class="headerlink" title="连字符（-）"></a>连字符（-）</h4><p>某些情况下，<strong>对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围</strong>。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a-z/.test(&apos;b&apos;) // false</span><br><span class="line">/[a-z]/.test(&apos;b&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义</strong>，所以不匹配字符<code>b</code>。<strong><font color="red">只有当连字号用在方括号之中，才表示连续的字符序列</font></strong>。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9.,]</span><br><span class="line">[0-9a-fA-F]</span><br><span class="line">[a-zA-Z0-9-]</span><br><span class="line">[1-31]</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code></font>。</strong></p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;\u0130\u0131\u0132&quot;;</span><br><span class="line">/[\u0128-\uFFFF]/.test(str)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，<strong>不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[A-z]/.test(&apos;\\&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于反斜杠（‘\’）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h3 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h3><p>预定义模式指的是某些常见模式的简写方式。</p>
<blockquote>
<p><code>\d</code> 匹配<code>0-9</code>之间的任一数字，相当于<code>[0-9]</code>。<br><code>\D</code> 匹配所有<code>0-9</code>以外的字符，相当于<code>[^0-9]</code>。<br><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。<br><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。<br><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。<br><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。<br><code>\b</code> 匹配词的边界。<br><code>\B</code> 匹配非词边界，即在词的内部。</p>
</blockquote>
<p>下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// \s 的例子</span><br><span class="line">/\s\w*/.exec(&apos;hello world&apos;) // [&quot; world&quot;]</span><br><span class="line"></span><br><span class="line">// \b 的例子</span><br><span class="line">/\bworld/.test(&apos;hello world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;hello-world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;helloworld&apos;) // false</span><br><span class="line"></span><br><span class="line">// \B 的例子</span><br><span class="line">/\Bworld/.test(&apos;hello-world&apos;) // false</span><br><span class="line">/\Bworld/.test(&apos;helloworld&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。由上面的代码可以看出<code>-</code>也算是词的边界。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;</span><br><span class="line"></span><br><span class="line">/.*/.exec(html)[0]</span><br><span class="line">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;</span><br><span class="line"></span><br><span class="line">/[\S\s]*/.exec(html)[0]</span><br><span class="line">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">/.*\s.*/.exec(html)[0]</span><br><span class="line">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h3 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h3><p><strong>模式的精确匹配次数，使用大括号（<code>{}</code>）表示。<code>{n}</code>表示恰好重复<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lo&#123;2&#125;k/.test(&apos;look&apos;) // true</span><br><span class="line">/lo&#123;2,5&#125;k/.test(&apos;looook&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间。</p>
<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p><strong>量词符用来设定某个模式出现的次数</strong>。</p>
<blockquote>
<p><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。<br><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。<br><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// t 出现0次或1次</span><br><span class="line">/t?est/.test(&apos;test&apos;) // true</span><br><span class="line">/t?est/.test(&apos;est&apos;) // true</span><br><span class="line"></span><br><span class="line">// t 出现1次或多次</span><br><span class="line">/t+est/.test(&apos;test&apos;) // true</span><br><span class="line">/t+est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t+est/.test(&apos;est&apos;) // false</span><br><span class="line"></span><br><span class="line">// t 出现0次或多次</span><br><span class="line">/t*est/.test(&apos;test&apos;) // true</span><br><span class="line">/t*est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;tttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;est&apos;) // true</span><br></pre></td></tr></table></figure>
<h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>上一小节的<strong>三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为<font color="red">贪婪模式</font>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>如果想<strong>将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+?/) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为<strong><font color="red">非贪婪模式，一旦条件满足，就不再往下匹配</font></strong>。</p>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）。</p>
<blockquote>
<p><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>
</blockquote>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部</strong>。</p>
<p><strong>修饰符可以单个使用，也可以多个一起使用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单个修饰符</span><br><span class="line">var regex = /test/i;</span><br><span class="line"></span><br><span class="line">// 多个修饰符</span><br><span class="line">var regex = /test/ig;</span><br></pre></td></tr></table></figure>
<h4 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h4><p><strong>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<font color="red"><code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果</font>，主要用于搜索和替换</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/g;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // false</span><br><span class="line">regex.test(str); // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。等到下一次匹配时又会变为<code>true</code>，因为此时<code>lastIndex</code>的值被重置为<code>0</code>，即再次从头开始匹配。</p>
<h4 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h4><p><strong>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写</strong>（ignorecase）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(&apos;ABC&apos;) // false</span><br><span class="line">/abc/i.test(&apos;ABC&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<h4 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h4><p><strong><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（\n）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.test(&apos;hello world\n&apos;) // false</span><br><span class="line">/world$/m.test(&apos;hello world\n&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面的代码中，字符串结尾处有一个换行符。<strong>如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^b/m.test(&apos;a\nb&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>b</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h3 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p><strong>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred+/.test(&apos;fredd&apos;) // true</span><br><span class="line">/(fred)+/.test(&apos;fredfred&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abcabc&apos;.match(/(.)b(.)/);</span><br><span class="line">m</span><br><span class="line">// [&apos;abc&apos;, &apos;a&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，<strong>使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容，而只捕获匹配整个表达式的内容</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abcabc&apos;.match(/(.)b(.)/g);</span><br><span class="line">m // [&apos;abc&apos;, &apos;abc&apos;]</span><br></pre></td></tr></table></figure>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcabc&apos;;</span><br><span class="line">var reg = /(.)b(.)/g;</span><br><span class="line">while (true) &#123;</span><br><span class="line">  var result = reg.exec(str);</span><br><span class="line">  if (!result) break;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="line">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>上面的代码使用了<code>exec</code>加修饰符<code>g</code>，<code>g</code>表示<code>exec</code>每次执行都从上一次匹配结束的地方继续匹配。<code>exec</code>配合圆括号使用，则返回的结果，如果没有成功匹配则返回<code>null</code>，如果匹配成功了返回一个数组，其中，第一个值为整体匹配的结果，第二个值为第一个括号匹配的结果，第三个值为第二个括号匹配的结果，依次类推。</p>
<p>正则表达式内部，还<strong>可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从<code>1</code>开始的自然数，表示对应顺序的括号</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/y(..)(.)\2\1/.test(&apos;yabccab&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p>括号还可以嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/y((..)\2)\1/.test(&apos;yabababab&apos;) // true</span><br><span class="line"></span><br><span class="line">/y((..)a\2)\1/.test(&apos;yabaababaab&apos;) // true</span><br><span class="line"></span><br><span class="line">/y((..)c)\2\1/.test(&apos;yabcababcab&apos;) // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</strong></p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;</span><br><span class="line"></span><br><span class="line">tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]</span><br><span class="line">// &apos;b&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var html = &apos;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&apos;;</span><br><span class="line">var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;</span><br><span class="line"></span><br><span class="line">var match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[1] // &quot;b&quot;</span><br><span class="line">match[2] // &quot; class=&quot;hello&quot;&quot;</span><br><span class="line">match[3] // &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[1] // &quot;i&quot;</span><br><span class="line">match[2] // &quot;&quot;</span><br><span class="line">match[3] // &quot;world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h4><p><code>(?:x)</code>称为<strong>非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号</strong>。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo){1, 2}/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo){1, 2}/</code>，它的作用与前一个正则是一样的，但是<strong>不会单独输出括号内部的内容</strong>。</p>
<p>请看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abc&apos;.match(/(?:.)b(.)/);</span><br><span class="line">m // [&quot;abc&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 正常匹配</span><br><span class="line">var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;</span><br><span class="line"></span><br><span class="line">url.exec(&apos;http://google.com/&apos;);</span><br><span class="line">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br><span class="line"></span><br><span class="line">// 非捕获组匹配</span><br><span class="line">var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;</span><br><span class="line"></span><br><span class="line">url.exec(&apos;http://google.com/&apos;);</span><br><span class="line">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<h4 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h4><p><code>x(?=y)</code>称为<strong>先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</strong></p>
<p><strong>“先行断言”中，括号里的部分是不会返回的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abc&apos;.match(/b(?=c)/);</span><br><span class="line">m // [&quot;b&quot;]</span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<h4 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h4><p><code>x(?!y)</code>称为<strong>先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(&apos;3.14&apos;)</span><br><span class="line">// [&quot;14&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p><strong>“先行否定断言”中，括号里的部分是不会返回的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abd&apos;.match(/b(?!c)/);</span><br><span class="line">m // [&apos;b&apos;]</span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
<h1 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h1><h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h2><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p>
<p>相比 XML 格式，JSON 格式有两个显著的优点：<strong>书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码</strong>。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p>
<p>每个 JSON 对象就是一个值，可能是一个<strong>数组</strong>或<strong>对象</strong>，也可能是一个<strong>原始类型的值</strong>。总之，<strong>只能是一个值，不能是两个或更多的值。</strong></p>
<p><strong><font color="red">JSON 对值的类型和格式有严格的规定</font></strong>。</p>
<ol>
<li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p>
</li>
<li><p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ol>
<p>以下都是合法的 JSON。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</span><br><span class="line"></span><br><span class="line">&#123; &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 &#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] &#125;</span><br><span class="line"></span><br><span class="line">[ &#123; &quot;name&quot;: &quot;张三&quot;&#125;, &#123;&quot;name&quot;: &quot;李四&quot;&#125; ]</span><br></pre></td></tr></table></figure>
<p>以下都是不合法的 JSON。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &quot;张三&quot;, &apos;age&apos;: 32 &#125;  // 属性名必须使用双引号</span><br><span class="line"></span><br><span class="line">[32, 64, 128, 0xFFF] // 不能使用十六进制值</span><br><span class="line"></span><br><span class="line">&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined &#125; // 不能使用 undefined</span><br><span class="line"></span><br><span class="line">&#123; &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;birthday&quot;: new Date(&apos;Fri, 26 Aug 2011 07:13:10 GMT&apos;),</span><br><span class="line">  &quot;getName&quot;: function () &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; // 属性值不能使用函数和日期对象</span><br></pre></td></tr></table></figure>
<p>注意，<strong><code>null</code>、空数组和空对象都是合法的 JSON 值</strong>。</p>
<h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>
<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>JSON.stringify</code>方法<strong>用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse</code>方法还原。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;abc&apos;) // &quot;&quot;abc&quot;&quot;</span><br><span class="line">JSON.stringify(1) // &quot;1&quot;</span><br><span class="line">JSON.stringify(false) // &quot;false&quot;</span><br><span class="line">JSON.stringify([]) // &quot;[]&quot;</span><br><span class="line">JSON.stringify(&#123;&#125;) // &quot;&#123;&#125;&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify([1, &quot;false&quot;, false])</span><br><span class="line">// &apos;[1,&quot;false&quot;,false]&apos;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; name: &quot;张三&quot; &#125;)</span><br><span class="line">// &apos;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码将各种类型的值，转成 JSON 字符串。</p>
<p>注意，<strong>对于原始类型的字符串，转换结果会带双引号。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;foo&apos;) === &quot;foo&quot; // false</span><br><span class="line">JSON.stringify(&apos;foo&apos;) === &quot;\&quot;foo\&quot;&quot; // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo&quot;\&quot;</code>。<strong>这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(false) // &quot;false&quot;</span><br><span class="line">JSON.stringify(&apos;false&apos;) // &quot;\&quot;false\&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。</p>
<p>如果<strong><font color="red">对象的属性</font>是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify</code>过滤</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: undefined,</span><br><span class="line">  b: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(obj) // &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤。</p>
<p>如果<strong><font color="red">数组的成员</font>是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [undefined, function () &#123;&#125;];</span><br><span class="line">JSON.stringify(arr) // &quot;[null,null]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>。</p>
<p><strong>正则对象会被转成空对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(/foo/) // &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p><code>JSON.stringify</code>方法会<strong>忽略对象的不可遍历属性。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperties(obj, &#123;</span><br><span class="line">  &apos;foo&apos;: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &apos;bar&apos;: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    enumerable: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">JSON.stringify(obj); // &quot;&#123;&quot;foo&quot;:1&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性。</p>
<h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p><code>JSON.stringify</code>方法还可以接受一个数组，作为<strong>第二个参数，指定需要转成字符串的属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  &apos;prop1&apos;: &apos;value1&apos;,</span><br><span class="line">  &apos;prop2&apos;: &apos;value2&apos;,</span><br><span class="line">  &apos;prop3&apos;: &apos;value3&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];</span><br><span class="line"></span><br><span class="line">JSON.stringify(obj, selectedProperties)</span><br><span class="line">// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性。</p>
<p>这个类似白名单的数组，<strong>只对对象的属性有效，对数组无效。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify([&apos;a&apos;, &apos;b&apos;], [&apos;0&apos;])</span><br><span class="line">// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123;0: &apos;a&apos;, 1: &apos;b&apos;&#125;, [&apos;0&apos;])</span><br><span class="line">// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效。</p>
<p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify</code>的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(key, value) &#123;</span><br><span class="line">  if (typeof value === &quot;number&quot;) &#123;</span><br><span class="line">    value = 2 * value;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: 1, b: 2 &#125;, f)</span><br><span class="line">// &apos;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以2，否则就原样返回。</p>
<p>注意，<strong>这个处理函数是递归处理所有的键</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">function f(key, value) &#123;</span><br><span class="line">  console.log(&quot;[&quot;+ key +&quot;]:&quot; + value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(o, f)</span><br><span class="line">// []:[object Object]</span><br><span class="line">// [a]:[object Object]</span><br><span class="line">// [b]:1</span><br><span class="line">// &apos;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>o</code>一共会被<code>f</code>函数处理三次，最后那行是<code>JSON.stringify</code>的输出。第一次键名为空，键值是整个对象<code>o</code>；第二次键名为<code>a</code>，键值是<code>{b: 1}</code>；第三次键名为<code>b</code>，键值为<code>1</code>。</p>
<p>递归处理中，每一次处理的对象，都是前一次返回的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a: 1&#125;;</span><br><span class="line"></span><br><span class="line">function f(key, value) &#123;</span><br><span class="line">  if (typeof value === &apos;object&apos;) &#123;</span><br><span class="line">    return &#123;b: 2&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return value * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(o, f)</span><br><span class="line">// &quot;&#123;&quot;b&quot;: 4&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f</code>函数修改了对象<code>o</code>，接着<code>JSON.stringify</code>方法就递归处理修改后的对象<code>o</code>。</p>
<p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(key, value) &#123;</span><br><span class="line">  if (typeof(value) === &quot;string&quot;) &#123;</span><br><span class="line">    return undefined;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; a: &quot;abc&quot;, b: 123 &#125;, f)</span><br><span class="line">// &apos;&#123;&quot;b&quot;: 123&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了。</p>
<h3 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h3><p><code>JSON.stringify</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。<strong>如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2);</span><br><span class="line">/*</span><br><span class="line">&quot;&#123;</span><br><span class="line">  &quot;p1&quot;: 1,</span><br><span class="line">  &quot;p2&quot;: 2</span><br><span class="line">&#125;&quot;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; p1:1, p2:2 &#125;, null, &apos;|-&apos;);</span><br><span class="line">/*</span><br><span class="line">&quot;&#123;</span><br><span class="line">|-&quot;p1&quot;: 1,</span><br><span class="line">|-&quot;p2&quot;: 2</span><br><span class="line">&#125;&quot;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="参数对象的-toJSON-方法"><a href="#参数对象的-toJSON-方法" class="headerlink" title="参数对象的 toJSON 方法"></a>参数对象的 toJSON 方法</h3><p>如果参数对象有自定义的<code>toJSON</code>方法，那么<code>JSON.stringify</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p>
<p>下面是一个普通的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  firstName: &apos;三&apos;,</span><br><span class="line">  lastName: &apos;张&apos;,</span><br><span class="line"></span><br><span class="line">  get fullName()&#123;</span><br><span class="line">    return this.lastName + this.firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(user)</span><br><span class="line">// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>现在，为这个对象加上<code>toJSON</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">  firstName: &apos;三&apos;,</span><br><span class="line">  lastName: &apos;张&apos;,</span><br><span class="line"></span><br><span class="line">  get fullName()&#123;</span><br><span class="line">    return this.lastName + this.firstName;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toJSON: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: this.lastName + this.firstName</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSON.stringify(user)</span><br><span class="line">// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>JSON.stringify</code>发现参数对象有<code>toJSON</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。</strong></p>
<p><code>Date</code>对象就有一个自己的<code>toJSON</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(&apos;2015-01-01&apos;);</span><br><span class="line">date.toJSON() // &quot;2015-01-01T00:00:00.000Z&quot;</span><br><span class="line">JSON.stringify(date) // &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON</code>方法，将该方法的返回值作为参数。</p>
<p><strong><code>toJSON</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify</code>默认不能转换正则对象，但是设置了<code>toJSON</code>方法以后，就可以转换正则对象了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  reg: /foo/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不设置 toJSON 方法时</span><br><span class="line">JSON.stringify(obj) // &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 设置 toJSON 方法时</span><br><span class="line">RegExp.prototype.toJSON = RegExp.prototype.toString;</span><br><span class="line">JSON.stringify(/foo/) // &quot;&quot;/foo/&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码在正则对象的原型上面部署了<code>toJSON</code>方法，将其指向<code>toString</code>方法，因此遇到转换成JSON时，正则对象就先调用<code>toJSON</code>方法转为字符串，然后再被<code>JSON.stingify</code>方法处理。</p>
<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p><code>JSON.parse</code>方法<strong>用于将 JSON 字符串转换成对应的值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&apos;&#123;&#125;&apos;) // &#123;&#125;</span><br><span class="line">JSON.parse(&apos;true&apos;) // true</span><br><span class="line">JSON.parse(&apos;&quot;foo&quot;&apos;) // &quot;foo&quot;</span><br><span class="line">JSON.parse(&apos;[1, 5, &quot;false&quot;]&apos;) // [1, 5, &quot;false&quot;]</span><br><span class="line">JSON.parse(&apos;null&apos;) // null</span><br><span class="line"></span><br><span class="line">var o = JSON.parse(&apos;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&apos;);</span><br><span class="line">o.name // 张三</span><br></pre></td></tr></table></figure>
<p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse</code>方法将报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&quot;&apos;String&apos;&quot;) // illegal single quotes</span><br><span class="line">// SyntaxError: Unexpected token ILLEGAL</span><br></pre></td></tr></table></figure>
<p>上面代码中，双引号字符串中是一个单引号字符串，<strong>因为单引号字符串不符合 JSON 格式，所以报错</strong>。</p>
<p>为了处理解析错误，可以将<code>JSON.parse</code>方法放在<code>try...catch</code>代码块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  JSON.parse(&quot;&apos;String&apos;&quot;);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;parsing error&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JSON.parse</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify</code>方法类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(key, value) &#123;</span><br><span class="line">  if (key === &apos;a&apos;) &#123;</span><br><span class="line">    return value + 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&apos;, f)</span><br><span class="line">// &#123;a: 11, b: 2&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>JSON.parse</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上<code>10</code>。</p>
<h1 id="console对象"><a href="#console对象" class="headerlink" title="console对象"></a>console对象</h1><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。</p>
<p><code>console</code>的常见用途有两个。</p>
<blockquote>
<p>调试程序，显示网页代码运行时的错误信息。<br>提供了一个命令行接口，用来与网页代码互动。</p>
</blockquote>
<h2 id="浏览器实现"><a href="#浏览器实现" class="headerlink" title="浏览器实现"></a>浏览器实现</h2><p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 <code>Chrome</code>浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p>
<ol>
<li>按 <code>F12</code> 或者<code>Control + Shift + i（PC）</code>/ <code>Alt + Command + i（Mac）</code>。</li>
<li>浏览器菜单选择“工具/开发者工具”。</li>
<li>在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>
</ol>
<p>打开开发者工具以后，顶端有多个面板。</p>
<blockquote>
<p>Elements：查看网页的 HTML 源码和 CSS 代码。<br>Resources：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。<br>Network：查看网页的 HTTP 通信情况。<br>Sources：查看网页加载的脚本源码。<br>Timeline：查看各种网页行为随时间变化的情况。<br>Performance：查看网页的性能情况，比如 CPU 和内存消耗。<br>Console：用来运行 JavaScript 命令。</p>
</blockquote>
<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。</p>
<p><strong><code>Console</code>面板基本上就是一个命令行窗口</strong>，你可以在提示符下，键入各种命令。</p>
<h2 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h2><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>
<h3 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h3><p><code>console.log</code>方法<strong>用于在控制台输出信息</strong>。它<strong>可以接受一个或多个参数，将它们连接起来输出</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;Hello World&apos;)</span><br><span class="line">// Hello World</span><br><span class="line">console.log(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</span><br><span class="line">// a b c</span><br></pre></td></tr></table></figure>
<p><strong><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">console.log(2);</span><br><span class="line">console.log(3);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p><strong>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos; %s + %s = %s&apos;, 1, 1, 2)</span><br><span class="line">//  1 + 1 = 2</span><br></pre></td></tr></table></figure>
<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>
<blockquote>
<p><code>%s</code> 字符串<br><code>%d</code> 整数<br><code>%i</code> 整数<br><code>%f</code> 浮点数<br><code>%o</code> 对象的链接<br><code>%c</code> CSS 格式字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var number = 11 * 9;</span><br><span class="line">var color = &apos;red&apos;;</span><br><span class="line"></span><br><span class="line">console.log(&apos;%d %s balloons&apos;, number, color);</span><br><span class="line">// 99 red balloons</span><br></pre></td></tr></table></figure>
<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行CSS渲染。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  &apos;%cThis text is styled!&apos;,</span><br><span class="line">  &apos;color: red; background: yellow; font-size: 24px;&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码运行后，输出的内容将显示为黄底红字。</p>
<p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos; %s + %s &apos;, 1, 1, &apos;= 2&apos;)</span><br><span class="line">// 1 + 1  = 2</span><br></pre></td></tr></table></figure>
<p><strong>如果参数是一个对象，<code>console.log</code>会显示该对象的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;foo: &apos;bar&apos;&#125;)</span><br><span class="line">// Object &#123;foo: &quot;bar&quot;&#125;</span><br><span class="line">console.log(Date)</span><br><span class="line">// function Date() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码输出Date对象的值，结果为一个<strong>构造函数</strong>。</p>
<p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标，这个蓝色图标在chrome中可能要展开该条信息才能看到。</p>
<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p>
<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&apos;log&apos;, &apos;info&apos;, &apos;warn&apos;, &apos;error&apos;].forEach(function(method) &#123;</span><br><span class="line">  console[method] = console[method].bind(</span><br><span class="line">    console,</span><br><span class="line">    new Date().toISOString()</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;出错了！&quot;);</span><br><span class="line">// 2014-05-18T09:00.000Z 出错了！</span><br></pre></td></tr></table></figure>
<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>
<h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.error(&apos;Error: %s (%i)&apos;, &apos;Server is not responding&apos;, 500)</span><br><span class="line">// Error: Server is not responding (500)</span><br><span class="line">console.warn(&apos;Warning! Too few nodes (%d)&apos;, document.childNodes.length)</span><br><span class="line">// Warning! Too few nodes (1)</span><br></pre></td></tr></table></figure>
<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var languages = [</span><br><span class="line">  &#123; name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.table(languages);</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>language</code>变量，转为表格后会以<code>(index)</code>, <code>name</code>, <code>fileExtension</code>为表头，以每个对象中各个对应的值为表格内容，画出一张表格。</p>
<p>类似的例子如下，可以拿去浏览器中试着运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var languages = &#123;</span><br><span class="line">  csharp: &#123; name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; &#125;,</span><br><span class="line">  fsharp: &#123; name: &quot;F#&quot;, paradigm: &quot;functional&quot; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.table(languages);</span><br></pre></td></tr></table></figure></p>
<h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function greet(user) &#123;</span><br><span class="line">  console.count();</span><br><span class="line">  return &apos;hi &apos; + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;bob&apos;)</span><br><span class="line">// default: 1</span><br><span class="line">// &quot;hi bob&quot;</span><br><span class="line"></span><br><span class="line">greet(&apos;alice&apos;)</span><br><span class="line">// default: 2</span><br><span class="line">// &quot;hi alice&quot;</span><br><span class="line"></span><br><span class="line">greet(&apos;bob&apos;)</span><br><span class="line">// default: 3</span><br><span class="line">// &quot;hi bob&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p>
<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。这个标签的默认值为<code>default</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function greet(user) &#123;</span><br><span class="line">  console.count(user);</span><br><span class="line">  return &quot;hi &quot; + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;bob&apos;)</span><br><span class="line">// bob: 1</span><br><span class="line">// &quot;hi bob&quot;</span><br><span class="line"></span><br><span class="line">greet(&apos;alice&apos;)</span><br><span class="line">// alice: 1</span><br><span class="line">// &quot;hi alice&quot;</span><br><span class="line"></span><br><span class="line">greet(&apos;bob&apos;)</span><br><span class="line">// bob: 2</span><br><span class="line">// &quot;hi bob&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>
<h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;f1: &apos;foo&apos;, f2: &apos;bar&apos;&#125;)</span><br><span class="line">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.dir(&#123;f1: &apos;foo&apos;, f2: &apos;bar&apos;&#125;)</span><br><span class="line">// Object</span><br><span class="line">//   f1: &quot;foo&quot;</span><br><span class="line">//   f2: &quot;bar&quot;</span><br><span class="line">//   __proto__: Object</span><br></pre></td></tr></table></figure>
<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p>
<p><strong>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.dir(document.body)</span><br></pre></td></tr></table></figure></p>
<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.dir(obj, &#123;colors: true&#125;)</span><br></pre></td></tr></table></figure>
<p><strong><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点</strong>，对于DOM节点来说也就相当于<code>log</code>方法的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.dirxml(document.body)</span><br></pre></td></tr></table></figure>
<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.dirxml([1, 2, 3])</span><br><span class="line">// 等同于</span><br><span class="line">console.dir([1, 2, 3])</span><br></pre></td></tr></table></figure>
<h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p><code>console.assert</code>方法主要<strong>用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确</strong>。</p>
<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。<strong>只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数</strong>，否则不会有任何结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.assert(false, &apos;判断条件不成立&apos;)</span><br><span class="line">// Assertion failed: 判断条件不成立</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">try &#123;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    throw new Error(&apos;判断条件不成立&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.assert(list.childNodes.length &lt; 500, &apos;节点个数大于等于500&apos;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>
<h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;Array initialize&apos;);</span><br><span class="line"></span><br><span class="line">var array= new Array(1000000);</span><br><span class="line">for (var i = array.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">  array[i] = new Object();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.timeEnd(&apos;Array initialize&apos;);</span><br><span class="line">// Array initialize: 1914.481ms</span><br></pre></td></tr></table></figure>
<p><strong><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</strong></p>
<h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><strong><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.group(&apos;一级分组&apos;);</span><br><span class="line">console.log(&apos;一级分组的内容&apos;);</span><br><span class="line"></span><br><span class="line">console.group(&apos;二级分组&apos;);</span><br><span class="line">console.log(&apos;二级分组的内容&apos;);</span><br><span class="line"></span><br><span class="line">console.groupEnd(); // 一级分组结束</span><br><span class="line">console.groupEnd(); // 二级分组结束</span><br></pre></td></tr></table></figure>
<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分类”和“二级分类”前面都有一个折叠符号，可以用来折叠本级的内容。</p>
<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，<strong>唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.groupCollapsed(&apos;Fetching Data&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Request Sent&apos;);</span><br><span class="line">console.error(&apos;Error: Server not responding (500)&apos;);</span><br><span class="line"></span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>
<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>
<h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.trace()</span><br><span class="line">// console.trace()</span><br><span class="line">//   (anonymous function)</span><br><span class="line">//   InjectedScript._evaluateOn</span><br><span class="line">//   InjectedScript._evaluateAndWrap</span><br><span class="line">//   InjectedScript.evaluate</span><br></pre></td></tr></table></figure>
<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.clear() // 本句代码将会清空控制台所有输出</span><br></pre></td></tr></table></figure>
<h2 id="命令行-API"><a href="#命令行-API" class="headerlink" title="命令行 API"></a>命令行 API</h2><p>浏览器控制台中，除了使用·console·对象，还可以使用一些控制台自带的命令行方法。</p>
<h3 id=""><a href="#" class="headerlink" title="$_"></a>$_</h3><p><code>$_</code>属性返回上一个表达式的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 + 2</span><br><span class="line">// 4</span><br><span class="line">$_</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>
<h3 id="0-4"><a href="#0-4" class="headerlink" title="$0 - $4"></a>$0 - $4</h3><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>
<h3 id="selector"><a href="#selector" class="headerlink" title="$(selector)"></a>$(selector)</h3><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>
<h3 id="selector-1"><a href="#selector-1" class="headerlink" title="$$(selector)"></a>$$(selector)</h3><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>
<h3 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h3><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x(&quot;//p[a]&quot;)</span><br></pre></td></tr></table></figure>
<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>
<h3 id="inspect-object"><a href="#inspect-object" class="headerlink" title="inspect(object)"></a>inspect(object)</h3><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在Elements面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板Profiles面板中显示，比如<code>inspect(window)</code>。</p>
<h3 id="getEventListeners-object"><a href="#getEventListeners-object" class="headerlink" title="getEventListeners(object)"></a>getEventListeners(object)</h3><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的<strong>成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数</strong>。</p>
<h3 id="keys-object-，values-object"><a href="#keys-object-，values-object" class="headerlink" title="keys(object)，values(object)"></a>keys(object)，values(object)</h3><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>
<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&apos;p1&apos;: &apos;a&apos;, &apos;p2&apos;: &apos;b&apos;&#125;;</span><br><span class="line"></span><br><span class="line">keys(o)</span><br><span class="line">// [&quot;p1&quot;, &quot;p2&quot;]</span><br><span class="line">values(o)</span><br><span class="line">// [&quot;a&quot;, &quot;b&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="monitorEvents-object-events-，unmonitorEvents-object-events"><a href="#monitorEvents-object-events-，unmonitorEvents-object-events" class="headerlink" title="monitorEvents(object[, events]) ，unmonitorEvents(object[, events])"></a>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</h3><p><code>monitorEvents(object[, events])</code>方法<strong>监听特定对象上发生的特定事件</strong>。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法<strong>用于停止监听</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents(window, &quot;resize&quot;);</span><br><span class="line">monitorEvents(window, [&quot;resize&quot;, &quot;scroll&quot;])</span><br></pre></td></tr></table></figure>
<p>上面代码分别表示单个事件和多个事件的监听方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($0, &apos;mouse&apos;);</span><br><span class="line">unmonitorEvents($0, &apos;mousemove&apos;);</span><br></pre></td></tr></table></figure>
<p>上面代码表示如何停止监听。</p>
<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>
<blockquote>
<p>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”<br>key：”keydown”, “keyup”, “keypress”, “textInput”<br>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”<br>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($(&quot;#msg&quot;), &quot;key&quot;);</span><br></pre></td></tr></table></figure>
<p>上面代码表示监听所有key大类的事件。</p>
<h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><p>命令行 API 还提供以下方法。</p>
<blockquote>
<p><code>clear()</code>：清除控制台的历史。<br><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。<br><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。<br><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</p>
</blockquote>
<h2 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h2><p><code>debugger</code>语句<strong>主要用于除错，作用是设置断点</strong>。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。<strong>如果没有除错工具，<code>debugger</code>语句不会产生任何结果</strong>，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  if (i === 2) debugger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>
<h1 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>JavaScript <strong>提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”</strong>（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p>
<p>下面是属性描述对象的一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: false,</span><br><span class="line">  get: undefined,</span><br><span class="line">  set: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>属性描述对象</strong>提供6个元属性。</p>
<p><strong>（1）value</strong></p>
<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>
<p><strong>（2）writable</strong></p>
<p><code>writable</code>是一个布尔值，表示<strong>属性值（<code>value</code>）是否可改变（即是否可写）</strong>，默认为<code>true</code>。</p>
<p><strong>（3）enumerable</strong></p>
<p><code>enumerable</code>是一个布尔值，表示<strong>该属性是否可遍历</strong>，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>
<p><strong>（4）configurable</strong></p>
<p><code>configurable</code>是一个布尔值，<strong>表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</strong></p>
<p><strong>（5）get</strong></p>
<p><strong><code>get</code>是一个函数，表示该属性的取值函数（<code>getter</code>），默认为<code>undefined</code></strong>。</p>
<p><strong>（6）set</strong></p>
<p><strong><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为undefined。</strong></p>
<h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h2><p><code>Object.getOwnPropertyDescriptor</code>方法<strong>可以获取属性描述对象。它的第一个参数是一个对象，第二个参数是一个字符串，对应该对象的某个属性名</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;a&apos; &#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)</span><br><span class="line">// Object &#123; value: &quot;a&quot;,</span><br><span class="line">//   writable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyDescriptor</code>方法获取<code>obj.p</code>的属性描述对象。</p>
<p>注意，<code>Object.getOwnPropertyDescriptor</code>方法<strong>只能用于对象自身的属性，不能用于继承的属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;a&apos; &#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;toString&apos;)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是<code>Obj</code>对象继承的属性，<code>Object.getOwnPropertyDescriptor</code>无法获取。</p>
<h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p><code>Object.getOwnPropertyNames</code>方法<strong>返回一个数组，成员是参数对象<font color="red">自身</font>的全部属性的属性名，<font color="red">不管该属性是否可遍历</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; value: 1, enumerable: true &#125;,</span><br><span class="line">  p2: &#123; value: 2, enumerable: false &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(obj)</span><br><span class="line">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回。</p>
<p>这跟<code>Object.keys</code>的行为不同，<strong><code>Object.keys</code>只返回对象自身的&lt;font color=”red&gt;可遍历属性的全部属性名。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object.keys([]) // []</span><br><span class="line">Object.getOwnPropertyNames([]) // [ &apos;length&apos; ]</span><br><span class="line"></span><br><span class="line">Object.keys(Object.prototype) // []</span><br><span class="line">Object.getOwnPropertyNames(Object.prototype)</span><br><span class="line">// [&apos;hasOwnProperty&apos;,</span><br><span class="line">//  &apos;valueOf&apos;,</span><br><span class="line">//  &apos;constructor&apos;,</span><br><span class="line">//  &apos;toLocaleString&apos;,</span><br><span class="line">//  &apos;isPrototypeOf&apos;,</span><br><span class="line">//  &apos;propertyIsEnumerable&apos;,</span><br><span class="line">//  &apos;toString&apos;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<strong><code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。</strong></p>
<h2 id="Object-defineProperty-，Object-defineProperties"><a href="#Object-defineProperty-，Object-defineProperties" class="headerlink" title="Object.defineProperty()，Object.defineProperties()"></a>Object.defineProperty()，Object.defineProperties()</h2><p><code>Object.defineProperty</code>方法<strong>允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象</strong>，它的用法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(object, propertyName, attributesObject)</span><br></pre></td></tr></table></figure>
<p><code>Object.defineProperty</code>方法接受三个参数，依次如下。</p>
<blockquote>
<p>属性所在的对象<br>属性名（它应该是一个字符串）<br>属性描述对象</p>
</blockquote>
<p>举例来说，定义<code>obj.p</code>可以写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p // 123</span><br><span class="line"></span><br><span class="line">obj.p = 246;</span><br><span class="line">obj.p // 123</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperty</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<strong><code>Object.defineProperty</code>方法的第一个参数是<code>{}</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象</strong>，这是<code>Object.defineProperty</code>的常见写法。</p>
<p><strong>如果属性已经存在，<code>Object.defineProperty</code>方法相当于更新该属性的属性描述对象</strong>。</p>
<p>如果<strong>一次性定义或修改多个属性</strong>，可以使用<code>Object.defineProperties</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; value: 123, enumerable: true &#125;,</span><br><span class="line">  p2: &#123; value: &apos;abc&apos;, enumerable: true &#125;,</span><br><span class="line">  p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;,</span><br><span class="line">    enumerable:true,</span><br><span class="line">    configurable:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p1 // 123</span><br><span class="line">obj.p2 // &quot;abc&quot;</span><br><span class="line">obj.p3 // &quot;123abc&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperties</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了<strong>取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数</strong>。</p>
<p>注意，<strong><font color="red">一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</font></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  get: function() &#123; return 456; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// TypeError: Invalid property.</span><br><span class="line">// A property cannot both have accessors and be writable or have a value</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;</span><br><span class="line">  writable: true,</span><br><span class="line">  get: function() &#123; return 456; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// TypeError: Invalid property descriptor.</span><br><span class="line">// Cannot both specify accessors and a value or writable attribute</span><br></pre></td></tr></table></figure>
<p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错。</p>
<p><strong><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>的第三个参数，是一个属性对象。它的<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;&#125;);</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class="line">// &#123;</span><br><span class="line">//   value: undefined,</span><br><span class="line">//   writable: false,</span><br><span class="line">//   enumerable: false,</span><br><span class="line">//   configurable: false</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，定义<code>obj.p</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值。</p>
<h2 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h2><p>实例对象的<code>propertyIsEnumerable</code>方法返回一个布尔值，用来判断某个属性是否可遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.p = 123;</span><br><span class="line"></span><br><span class="line">obj.propertyIsEnumerable(&apos;p&apos;) // true</span><br><span class="line">obj.propertyIsEnumerable(&apos;toString&apos;) // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>是可遍历的，而继承自原型对象的<code>obj.toString</code>属性是不可遍历的。</p>
<h2 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h2><p>**属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p><code>value</code>属性<strong>是目标属性的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.p = 123;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;p&apos;).value</span><br><span class="line">// 123</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123; value: 246 &#125;);</span><br><span class="line">obj.p // 246</span><br></pre></td></tr></table></figure>
<p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子。</p>
<h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p><code>writable</code>属性<strong>是一个布尔值，决定了目标属性的值（value）是否可以被改变</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class="line">  value: 37,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a // 37</span><br><span class="line">obj.a = 25;</span><br><span class="line">obj.a // 37</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果。</p>
<p>注意，<strong>正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;a&apos;, &#123;</span><br><span class="line">  value: 37,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a = 37;</span><br><span class="line">// Uncaught TypeError: Cannot assign to read only property &apos;a&apos; of object</span><br></pre></td></tr></table></figure>
<p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。</p>
<p>如果<strong>原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proto = Object.defineProperty(&#123;&#125;, &apos;foo&apos;, &#123;</span><br><span class="line">  value: &apos;a&apos;,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj = Object.create(proto);</span><br><span class="line"></span><br><span class="line">obj.foo = &apos;b&apos;;</span><br><span class="line">obj.foo // &apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。</p>
<p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var proto = Object.defineProperty(&#123;&#125;, &apos;foo&apos;, &#123;</span><br><span class="line">  value: &apos;a&apos;,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj = Object.create(proto);</span><br><span class="line">Object.defineProperty(obj, &apos;foo&apos;, &#123;</span><br><span class="line">  value: &apos;b&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.foo // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p><code>enumerable</code>（可遍历性）<strong>返回一个布尔值，表示目标属性是否可遍历</strong>。</p>
<p>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<strong><code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code></strong>。这导致了无论是对象自身的属性还是继承的属性，<code>for...in</code>循环都能够遍历到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">&apos;toString&apos; in obj // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历。</p>
<p>这显然不太合理，后来就引入了“可遍历性”这个概念。<strong>只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类<font color="red">实例对象继承的原生属性，都是不可遍历的</font>，这样就保证了<code>for...in</code>循环的可用性。</strong></p>
<p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性。</p>
<blockquote>
<p><code>for..in</code>循环<br><code>Object.keys</code>方法<br><code>JSON.stringify</code>方法</p>
</blockquote>
<p>因此，<code>enumerable</code>可以用来设置“秘密”属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;x&apos;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  enumerable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.x // 123</span><br><span class="line"></span><br><span class="line">for (var key in obj) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">Object.keys(obj)  // []</span><br><span class="line">JSON.stringify(obj) // &quot;&#123;a:1, b:2, c:3&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.x</code>属性的<code>enumerable</code>为<code>false</code>，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。</p>
<p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法。</p>
<p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>。</p>
<h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p><code>configurable</code>(可配置性）<strong>返回一个布尔值，决定了是否可以修改属性描述对象</strong>。也就是说，<code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;value: 2&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;writable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;enumerable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;configurable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错。</p>
<p>注意，<strong><code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;writable: false&#125;)</span><br><span class="line">// 修改成功</span><br></pre></td></tr></table></figure>
<p>至于<strong><code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var o1 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: true,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o1, &apos;p&apos;, &#123;value: 2&#125;)</span><br><span class="line">// 修改成功</span><br><span class="line"></span><br><span class="line">var o2 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o2, &apos;p&apos;, &#123;value: 2&#125;)</span><br><span class="line">// 修改成功</span><br><span class="line"></span><br><span class="line">var o3 = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o3, &apos;p&apos;, &#123;value: 2&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br></pre></td></tr></table></figure>
<p>另外，<strong><code>configurable</code>为<code>false</code>时，直接目标属性赋值，不报错，但不会成功。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p = 2;</span><br><span class="line">obj.p // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>，对<code>obj.p</code>赋值是不会生效的。如果是严格模式，还会报错。</p>
<p><strong>可配置性决定了目标属性是否可以被删除（delete）。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; value: 1, configurable: true &#125;,</span><br><span class="line">  p2: &#123; value: 2, configurable: false &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">delete obj.p1 // true</span><br><span class="line">delete obj.p2 // false</span><br><span class="line"></span><br><span class="line">obj.p1 // undefined</span><br><span class="line">obj.p2 // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除。</p>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p>
<p><strong>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如某个属性禁止赋值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return &apos;getter&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (value) &#123;</span><br><span class="line">    console.log(&apos;setter: &apos; + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p // &quot;getter&quot;</span><br><span class="line">obj.p = 123 // &quot;setter: 123&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。</p>
<p>JavaScript 还提供了存取器的另一种写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  get p() &#123;</span><br><span class="line">    return &apos;getter&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">  set p(value) &#123;</span><br><span class="line">    console.log(&apos;setter: &apos; + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的写法</strong>与定义属性描述对象是等价的，而且<strong>使用更广泛</strong>。</p>
<p>注意，<strong><font color="red">取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）</font></strong>。</p>
<p>存取器往往用于，属性的值依赖对象内部数据的场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj =&#123;</span><br><span class="line">  $n : 5,</span><br><span class="line">  get next() &#123; return this.$n++ &#125;,</span><br><span class="line">  set next(n) &#123;</span><br><span class="line">    if (n &gt;= this.$n) this.$n = n;</span><br><span class="line">    else throw new Error(&apos;新的值必须大于当前值&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.next // 5</span><br><span class="line"></span><br><span class="line">obj.next = 10;</span><br><span class="line">obj.next // 10</span><br><span class="line"></span><br><span class="line">obj.next = 5;</span><br><span class="line">// Uncaught Error: 新的值必须大于当前值</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>。</p>
<h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var extend = function (to, from) &#123;</span><br><span class="line">  for (var property in from) &#123;</span><br><span class="line">    to[property] = from[property];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123;</span><br><span class="line">  a: 1</span><br><span class="line">&#125;)</span><br><span class="line">// &#123;a: 1&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extend(&#123;&#125;, &#123;</span><br><span class="line">  get a() &#123; return 1 &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// &#123;a: 1&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们<strong>可以通过<code>Object.defineProperty</code>方法来拷贝属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var extend = function (to, from) &#123;</span><br><span class="line">  for (var property in from) &#123;</span><br><span class="line">    if (!from.hasOwnProperty(property)) continue;</span><br><span class="line">    Object.defineProperty(</span><br><span class="line">      to,</span><br><span class="line">      property,</span><br><span class="line">      Object.getOwnPropertyDescriptor(from, property)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;)</span><br><span class="line">// &#123; get a()&#123; return 1 &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>hasOwnProperty</code>表示该实例对象自身是否具有该属性，那一行代码用来过滤掉继承的属性，否则会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象</strong>。</p>
<h2 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h2><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>
<h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p><code>Object.preventExtensions</code>方法<strong>可以使得一个对象无法再添加新的属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;p&apos;, &#123;</span><br><span class="line">  value: &apos;hello&apos;</span><br><span class="line">&#125;);</span><br><span class="line">// TypeError: Cannot define property:p, object is not extensible.</span><br><span class="line"></span><br><span class="line">obj.p = 1;</span><br><span class="line">obj.p // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了。</p>
<h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，<strong>检查是否可以为一个对象添加属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">Object.isExtensible(obj) // true</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">Object.isExtensible(obj) // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了。</p>
<h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p><code>Object.seal</code>方法<strong>使得一个对象既无法添加新属性，也无法删除旧属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;hello&apos; &#125;;</span><br><span class="line">Object.seal(obj);</span><br><span class="line"></span><br><span class="line">delete obj.p;</span><br><span class="line">obj.p // &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">obj.x = &apos;world&apos;;</span><br><span class="line">obj.x // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。</p>
<p><strong><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;a&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// seal方法之前</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)</span><br><span class="line">// Object &#123;</span><br><span class="line">//   value: &quot;a&quot;,</span><br><span class="line">//   writable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   configurable: true</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Object.seal(obj);</span><br><span class="line"></span><br><span class="line">// seal方法之后</span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)</span><br><span class="line">// Object &#123;</span><br><span class="line">//   value: &quot;a&quot;,</span><br><span class="line">//   writable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   configurable: false</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, &apos;p&apos;, &#123;</span><br><span class="line">  enumerable: false</span><br><span class="line">&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错。</p>
<p><strong><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;a&apos; &#125;;</span><br><span class="line">Object.seal(obj);</span><br><span class="line">obj.p = &apos;b&apos;;</span><br><span class="line">obj.p // &apos;b&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定。</p>
<h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h3><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;a&apos; &#125;;</span><br><span class="line"></span><br><span class="line">Object.seal(obj);</span><br><span class="line">Object.isSealed(obj) // true</span><br></pre></td></tr></table></figure>
<p>这时，<code>Object.isExtensible</code>方法也返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &apos;a&apos; &#125;;</span><br><span class="line"></span><br><span class="line">Object.seal(obj);</span><br><span class="line">Object.isExtensible(obj) // false</span><br></pre></td></tr></table></figure>
<h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p><code>Object.freeze</code>方法可以<strong>使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.p = &apos;world&apos;;</span><br><span class="line">obj.p // &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">obj.t = &apos;hello&apos;;</span><br><span class="line">obj.t // undefined</span><br><span class="line"></span><br><span class="line">delete obj.p // false</span><br><span class="line">obj.p // &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p>
<h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p><code>Object.isFrozen</code>方法<strong>用于检查一个对象是否使用了<code>Object.freeze</code>方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj);</span><br><span class="line">Object.isFrozen(obj) // true</span><br></pre></td></tr></table></figure>
<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">Object.isSealed(obj) // true</span><br><span class="line">Object.isExtensible(obj) // false</span><br></pre></td></tr></table></figure>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">if (!Object.isFrozen(obj)) &#123;</span><br><span class="line">  obj.p = &apos;world&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line">var proto = Object.getPrototypeOf(obj);</span><br><span class="line">proto.t = &apos;hello&apos;;</span><br><span class="line">obj.t</span><br><span class="line">// hello</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到。</p>
<p>一种解决方案是，把<code>obj</code>的原型也冻结住。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line">var proto = Object.getPrototypeOf(obj);</span><br><span class="line">Object.preventExtensions(proto);</span><br><span class="line"></span><br><span class="line">proto.t = &apos;hello&apos;;</span><br><span class="line">obj.t // undefined</span><br></pre></td></tr></table></figure></p>
<p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.bar.push(&apos;c&apos;);</span><br><span class="line">obj.bar // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/09/前端小知识点整理/" rel="next" title="前端小知识点整理">
                <i class="fa fa-chevron-left"></i> 前端小知识点整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/18/《JavaScript标准参考教程》阅读笔记之《面向对象编程》/" rel="prev" title="《JavaScript标准参考教程》阅读笔记之《面向对象编程》">
                《JavaScript标准参考教程》阅读笔记之《面向对象编程》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="hypercomments_widget"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Fnine59" />
            
              <p class="site-author-name" itemprop="name">Fnine59</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Fnine59" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5746592281?refer_flag=1005055010_" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fnine59@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Object对象"><span class="nav-number">1.</span> <span class="nav-text">Object对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object对象本身的方法"><span class="nav-number">1.1.1.</span> <span class="nav-text">Object对象本身的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object的实例方法"><span class="nav-number">1.1.2.</span> <span class="nav-text">Object的实例方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">1.2.</span> <span class="nav-text">Object()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-构造函数"><span class="nav-number">1.3.</span> <span class="nav-text">Object 构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-的静态方法"><span class="nav-number">1.4.</span> <span class="nav-text">Object 的静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-keys-，Object-getOwnPropertyNames"><span class="nav-number">1.4.1.</span> <span class="nav-text">Object.keys()，Object.getOwnPropertyNames()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他方法"><span class="nav-number">1.4.2.</span> <span class="nav-text">其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象属性模型的相关方法"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">对象属性模型的相关方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制对象状态的方法"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">控制对象状态的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链相关方法"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">原型链相关方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-的实例方法"><span class="nav-number">1.5.</span> <span class="nav-text">Object 的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-valueOf"><span class="nav-number">1.5.1.</span> <span class="nav-text">Object.prototype.valueOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-toString"><span class="nav-number">1.5.2.</span> <span class="nav-text">Object.prototype.toString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-的应用：判断数据类型"><span class="nav-number">1.5.3.</span> <span class="nav-text">toString() 的应用：判断数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-toLocaleString"><span class="nav-number">1.5.4.</span> <span class="nav-text">Object.prototype.toLocaleString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-hasOwnProperty"><span class="nav-number">1.5.5.</span> <span class="nav-text">Object.prototype.hasOwnProperty()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array-对象"><span class="nav-number">2.</span> <span class="nav-text">Array 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">2.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法"><span class="nav-number">2.2.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-isArray"><span class="nav-number">2.2.1.</span> <span class="nav-text">Array.isArray()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法"><span class="nav-number">2.3.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#valueOf-，toString"><span class="nav-number">2.3.1.</span> <span class="nav-text">valueOf()，toString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push-，pop"><span class="nav-number">2.3.2.</span> <span class="nav-text">push()，pop()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shift-，unshift"><span class="nav-number">2.3.3.</span> <span class="nav-text">shift()，unshift()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-number">2.3.4.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concat"><span class="nav-number">2.3.5.</span> <span class="nav-text">concat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse"><span class="nav-number">2.3.6.</span> <span class="nav-text">reverse()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice"><span class="nav-number">2.3.7.</span> <span class="nav-text">slice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#splice"><span class="nav-number">2.3.8.</span> <span class="nav-text">splice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort"><span class="nav-number">2.3.9.</span> <span class="nav-text">sort()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">2.3.10.</span> <span class="nav-text">map()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach"><span class="nav-number">2.3.11.</span> <span class="nav-text">forEach()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">2.3.12.</span> <span class="nav-text">filter()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#some-，every"><span class="nav-number">2.3.13.</span> <span class="nav-text">some()，every()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce-，reduceRight"><span class="nav-number">2.3.14.</span> <span class="nav-text">reduce()，reduceRight()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#indexOf-，lastIndexOf"><span class="nav-number">2.3.15.</span> <span class="nav-text">indexOf()，lastIndexOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式使用"><span class="nav-number">2.3.16.</span> <span class="nav-text">链式使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包装对象"><span class="nav-number">3.</span> <span class="nav-text">包装对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法-1"><span class="nav-number">3.2.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#valueOf-NaN"><span class="nav-number">3.2.1.</span> <span class="nav-text">valueOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-NaN"><span class="nav-number">3.2.2.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原始类型与实例对象的自动转换"><span class="nav-number">3.3.</span> <span class="nav-text">原始类型与实例对象的自动转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义方法"><span class="nav-number">3.4.</span> <span class="nav-text">自定义方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boolean-对象"><span class="nav-number">3.5.</span> <span class="nav-text">Boolean 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">3.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean-函数的类型转换作用"><span class="nav-number">3.5.2.</span> <span class="nav-text">Boolean 函数的类型转换作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Number对象"><span class="nav-number">4.</span> <span class="nav-text">Number对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">4.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法-2"><span class="nav-number">4.3.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-prototype-toString"><span class="nav-number">4.3.1.</span> <span class="nav-text">Number.prototype.toString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-prototype-toFixed"><span class="nav-number">4.3.2.</span> <span class="nav-text">Number.prototype.toFixed()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-prototype-toExponential"><span class="nav-number">4.3.3.</span> <span class="nav-text">Number.prototype.toExponential()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number-prototype-toPrecision"><span class="nav-number">4.3.4.</span> <span class="nav-text">Number.prototype.toPrecision()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义方法-1"><span class="nav-number">4.4.</span> <span class="nav-text">自定义方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String对象"><span class="nav-number">5.</span> <span class="nav-text">String对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法-1"><span class="nav-number">5.2.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-fromCharCode"><span class="nav-number">5.2.1.</span> <span class="nav-text">String.fromCharCode()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性"><span class="nav-number">5.3.</span> <span class="nav-text">实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-length"><span class="nav-number">5.3.1.</span> <span class="nav-text">String.prototype.length</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法-3"><span class="nav-number">5.4.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-charAt"><span class="nav-number">5.4.1.</span> <span class="nav-text">String.prototype.charAt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-charCodeAt"><span class="nav-number">5.4.2.</span> <span class="nav-text">String.prototype.charCodeAt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-concat"><span class="nav-number">5.4.3.</span> <span class="nav-text">String.prototype.concat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-slice"><span class="nav-number">5.4.4.</span> <span class="nav-text">String.prototype.slice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-substring"><span class="nav-number">5.4.5.</span> <span class="nav-text">String.prototype.substring()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-substr"><span class="nav-number">5.4.6.</span> <span class="nav-text">String.prototype.substr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-indexOf-，String-prototype-lastIndexOf"><span class="nav-number">5.4.7.</span> <span class="nav-text">String.prototype.indexOf()，String.prototype.lastIndexOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-trim"><span class="nav-number">5.4.8.</span> <span class="nav-text">String.prototype.trim()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-toLowerCase-，String-prototype-toUpperCase"><span class="nav-number">5.4.9.</span> <span class="nav-text">String.prototype.toLowerCase()，String.prototype.toUpperCase()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-match"><span class="nav-number">5.4.10.</span> <span class="nav-text">String.prototype.match()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-search-，String-prototype-replace"><span class="nav-number">5.4.11.</span> <span class="nav-text">String.prototype.search()，String.prototype.replace()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-split"><span class="nav-number">5.4.12.</span> <span class="nav-text">String.prototype.split()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-localeCompare"><span class="nav-number">5.4.13.</span> <span class="nav-text">String.prototype.localeCompare()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math对象"><span class="nav-number">6.</span> <span class="nav-text">Math对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态属性"><span class="nav-number">6.1.</span> <span class="nav-text">静态属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法-2"><span class="nav-number">6.2.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-abs"><span class="nav-number">6.2.1.</span> <span class="nav-text">Math.abs()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-max-，Math-min"><span class="nav-number">6.2.2.</span> <span class="nav-text">Math.max()，Math.min()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-floor-，Math-ceil"><span class="nav-number">6.2.3.</span> <span class="nav-text">Math.floor()，Math.ceil()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-round"><span class="nav-number">6.2.4.</span> <span class="nav-text">Math.round()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-pow"><span class="nav-number">6.2.5.</span> <span class="nav-text">Math.pow()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-sqrt"><span class="nav-number">6.2.6.</span> <span class="nav-text">Math.sqrt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-log"><span class="nav-number">6.2.7.</span> <span class="nav-text">Math.log()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-exp"><span class="nav-number">6.2.8.</span> <span class="nav-text">Math.exp()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-random"><span class="nav-number">6.2.9.</span> <span class="nav-text">Math.random()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三角函数方法"><span class="nav-number">6.2.10.</span> <span class="nav-text">三角函数方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Date对象"><span class="nav-number">7.</span> <span class="nav-text">Date对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#普通函数的用法"><span class="nav-number">7.1.</span> <span class="nav-text">普通函数的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的用法"><span class="nav-number">7.2.</span> <span class="nav-text">构造函数的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期的运算"><span class="nav-number">7.3.</span> <span class="nav-text">日期的运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法-3"><span class="nav-number">7.4.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-now"><span class="nav-number">7.4.1.</span> <span class="nav-text">Date.now()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-parse"><span class="nav-number">7.4.2.</span> <span class="nav-text">Date.parse()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-UTC"><span class="nav-number">7.4.3.</span> <span class="nav-text">Date.UTC()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法-4"><span class="nav-number">7.5.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Date-prototype-valueOf"><span class="nav-number">7.5.1.</span> <span class="nav-text">Date.prototype.valueOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#to-类方法"><span class="nav-number">7.5.2.</span> <span class="nav-text">to 类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toString"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">Date.prototype.toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toUTCString"><span class="nav-number">7.5.2.2.</span> <span class="nav-text">Date.prototype.toUTCString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toISOString"><span class="nav-number">7.5.2.3.</span> <span class="nav-text">Date.prototype.toISOString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toJSON"><span class="nav-number">7.5.2.4.</span> <span class="nav-text">Date.prototype.toJSON()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toDateString"><span class="nav-number">7.5.2.5.</span> <span class="nav-text">Date.prototype.toDateString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toTimeString"><span class="nav-number">7.5.2.6.</span> <span class="nav-text">Date.prototype.toTimeString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toLocaleDateString"><span class="nav-number">7.5.2.7.</span> <span class="nav-text">Date.prototype.toLocaleDateString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-prototype-toLocaleTimeString"><span class="nav-number">7.5.2.8.</span> <span class="nav-text">Date.prototype.toLocaleTimeString()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-类方法"><span class="nav-number">7.5.3.</span> <span class="nav-text">get 类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-类方法"><span class="nav-number">7.5.4.</span> <span class="nav-text">set 类方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RegExp对象"><span class="nav-number">8.</span> <span class="nav-text">RegExp对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-4"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性-1"><span class="nav-number">8.2.</span> <span class="nav-text">实例属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法-5"><span class="nav-number">8.3.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-prototype-test"><span class="nav-number">8.3.1.</span> <span class="nav-text">RegExp.prototype.test()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp-prototype-exec"><span class="nav-number">8.3.2.</span> <span class="nav-text">RegExp.prototype.exec()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的实例方法"><span class="nav-number">8.4.</span> <span class="nav-text">字符串的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-match-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">String.prototype.match()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-search"><span class="nav-number">8.4.2.</span> <span class="nav-text">String.prototype.search()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-replace"><span class="nav-number">8.4.3.</span> <span class="nav-text">String.prototype.replace()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-prototype-split-1"><span class="nav-number">8.4.4.</span> <span class="nav-text">String.prototype.split()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配规则"><span class="nav-number">8.5.</span> <span class="nav-text">匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字面量字符和元字符"><span class="nav-number">8.5.1.</span> <span class="nav-text">字面量字符和元字符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#点字符（"><span class="nav-number">8.5.1.1.</span> <span class="nav-text">点字符（.)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位置字符"><span class="nav-number">8.5.1.2.</span> <span class="nav-text">位置字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择符（-）"><span class="nav-number">8.5.1.3.</span> <span class="nav-text">选择符（|）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转义符"><span class="nav-number">8.5.2.</span> <span class="nav-text">转义符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊字符"><span class="nav-number">8.5.3.</span> <span class="nav-text">特殊字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符类"><span class="nav-number">8.5.4.</span> <span class="nav-text">字符类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#脱字符（-）"><span class="nav-number">8.5.4.1.</span> <span class="nav-text">脱字符（^）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连字符（-）"><span class="nav-number">8.5.4.2.</span> <span class="nav-text">连字符（-）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义模式"><span class="nav-number">8.5.5.</span> <span class="nav-text">预定义模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复类"><span class="nav-number">8.5.6.</span> <span class="nav-text">重复类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#量词符"><span class="nav-number">8.5.7.</span> <span class="nav-text">量词符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪婪模式"><span class="nav-number">8.5.8.</span> <span class="nav-text">贪婪模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符"><span class="nav-number">8.5.9.</span> <span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#g-修饰符"><span class="nav-number">8.5.9.1.</span> <span class="nav-text">g 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i-修饰符"><span class="nav-number">8.5.9.2.</span> <span class="nav-text">i 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#m-修饰符"><span class="nav-number">8.5.9.3.</span> <span class="nav-text">m 修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组匹配"><span class="nav-number">8.5.10.</span> <span class="nav-text">组匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-5"><span class="nav-number">8.5.10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非捕获组"><span class="nav-number">8.5.10.2.</span> <span class="nav-text">非捕获组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先行断言"><span class="nav-number">8.5.10.3.</span> <span class="nav-text">先行断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先行否定断言"><span class="nav-number">8.5.10.4.</span> <span class="nav-text">先行否定断言</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON对象"><span class="nav-number">9.</span> <span class="nav-text">JSON对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-格式"><span class="nav-number">9.1.</span> <span class="nav-text">JSON 格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-对象"><span class="nav-number">9.2.</span> <span class="nav-text">JSON 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-stringify"><span class="nav-number">9.3.</span> <span class="nav-text">JSON.stringify()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法"><span class="nav-number">9.3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二个参数"><span class="nav-number">9.3.2.</span> <span class="nav-text">第二个参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三个参数"><span class="nav-number">9.3.3.</span> <span class="nav-text">第三个参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数对象的-toJSON-方法"><span class="nav-number">9.3.4.</span> <span class="nav-text">参数对象的 toJSON 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-parse"><span class="nav-number">9.4.</span> <span class="nav-text">JSON.parse()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#console对象"><span class="nav-number">10.</span> <span class="nav-text">console对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器实现"><span class="nav-number">10.1.</span> <span class="nav-text">浏览器实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#console-对象的静态方法"><span class="nav-number">10.2.</span> <span class="nav-text">console 对象的静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#console-log-，console-info-，console-debug"><span class="nav-number">10.2.1.</span> <span class="nav-text">console.log()，console.info()，console.debug()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-warn-，console-error"><span class="nav-number">10.2.2.</span> <span class="nav-text">console.warn()，console.error()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-table"><span class="nav-number">10.2.3.</span> <span class="nav-text">console.table()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-count"><span class="nav-number">10.2.4.</span> <span class="nav-text">console.count()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-dir-，console-dirxml"><span class="nav-number">10.2.5.</span> <span class="nav-text">console.dir()，console.dirxml()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-assert"><span class="nav-number">10.2.6.</span> <span class="nav-text">console.assert()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-time-，console-timeEnd"><span class="nav-number">10.2.7.</span> <span class="nav-text">console.time()，console.timeEnd()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-group-，console-groupEnd-，console-groupCollapsed"><span class="nav-number">10.2.8.</span> <span class="nav-text">console.group()，console.groupEnd()，console.groupCollapsed()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-trace-，console-clear"><span class="nav-number">10.2.9.</span> <span class="nav-text">console.trace()，console.clear()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行-API"><span class="nav-number">10.3.</span> <span class="nav-text">命令行 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">10.3.1.</span> <span class="nav-text">$_</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-4"><span class="nav-number">10.3.2.</span> <span class="nav-text">$0 - $4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selector"><span class="nav-number">10.3.3.</span> <span class="nav-text">$(selector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selector-1"><span class="nav-number">10.3.4.</span> <span class="nav-text">$$(selector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x-path"><span class="nav-number">10.3.5.</span> <span class="nav-text">$x(path)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inspect-object"><span class="nav-number">10.3.6.</span> <span class="nav-text">inspect(object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getEventListeners-object"><span class="nav-number">10.3.7.</span> <span class="nav-text">getEventListeners(object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keys-object-，values-object"><span class="nav-number">10.3.8.</span> <span class="nav-text">keys(object)，values(object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorEvents-object-events-，unmonitorEvents-object-events"><span class="nav-number">10.3.9.</span> <span class="nav-text">monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他方法-1"><span class="nav-number">10.3.10.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#debugger-语句"><span class="nav-number">10.4.</span> <span class="nav-text">debugger 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性描述对象"><span class="nav-number">11.</span> <span class="nav-text">属性描述对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-6"><span class="nav-number">11.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-getOwnPropertyDescriptor"><span class="nav-number">11.2.</span> <span class="nav-text">Object.getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-getOwnPropertyNames"><span class="nav-number">11.3.</span> <span class="nav-text">Object.getOwnPropertyNames()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-defineProperty-，Object-defineProperties"><span class="nav-number">11.4.</span> <span class="nav-text">Object.defineProperty()，Object.defineProperties()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype-propertyIsEnumerable"><span class="nav-number">11.5.</span> <span class="nav-text">Object.prototype.propertyIsEnumerable()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元属性"><span class="nav-number">11.6.</span> <span class="nav-text">元属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#value"><span class="nav-number">11.6.1.</span> <span class="nav-text">value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writable"><span class="nav-number">11.6.2.</span> <span class="nav-text">writable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enumerable"><span class="nav-number">11.6.3.</span> <span class="nav-text">enumerable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configurable"><span class="nav-number">11.6.4.</span> <span class="nav-text">configurable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存取器"><span class="nav-number">11.7.</span> <span class="nav-text">存取器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的拷贝"><span class="nav-number">11.8.</span> <span class="nav-text">对象的拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制对象状态"><span class="nav-number">11.9.</span> <span class="nav-text">控制对象状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-preventExtensions"><span class="nav-number">11.9.1.</span> <span class="nav-text">Object.preventExtensions()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-isExtensible"><span class="nav-number">11.9.2.</span> <span class="nav-text">Object.isExtensible()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-seal"><span class="nav-number">11.9.3.</span> <span class="nav-text">Object.seal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-isSealed"><span class="nav-number">11.9.4.</span> <span class="nav-text">Object.isSealed()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-freeze"><span class="nav-number">11.9.5.</span> <span class="nav-text">Object.freeze()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-isFrozen"><span class="nav-number">11.9.6.</span> <span class="nav-text">Object.isFrozen()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局限性"><span class="nav-number">11.9.7.</span> <span class="nav-text">局限性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fnine59</span>
  
</div>

  <div class="powered-by">Powerd by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 102854, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 102854, xid: "2018/05/10/《JavaScript标准参考教程》阅读笔记之《标准库》/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/102854/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("QTeKY0jLRTzpECO9LofVA2eq-gzGzoHsz", "ls92zfSW8iXNYPQ5b2COG6L4");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>

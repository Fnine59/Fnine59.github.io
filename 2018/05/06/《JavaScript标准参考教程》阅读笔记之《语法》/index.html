<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  基本语法语句JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 J">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript标准参考教程》阅读笔记之《语法》">
<meta property="og:url" content="http://fnine59.top/2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/index.html">
<meta property="og:site_name" content="59&#39;s Personal Blog">
<meta property="og:description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  基本语法语句JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 J">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-25T06:08:11.137Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《JavaScript标准参考教程》阅读笔记之《语法》">
<meta name="twitter:description" content="整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，github地址  基本语法语句JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 分号前面可以没有任何内容，JavaScript引擎将其视为空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 J">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fnine59.top/2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/"/>





  <title>《JavaScript标准参考教程》阅读笔记之《语法》 | 59's Personal Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/Fnine59"><img style="position: absolute; top: 0; right: 0; 
	border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"
	alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">59's Personal Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just coding.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fnine59.top/2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fnine59">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="59's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《JavaScript标准参考教程》阅读笔记之《语法》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T20:53:23+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript标准教程笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript标准教程笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/" class="leancloud_visitors" data-flag-title="《JavaScript标准参考教程》阅读笔记之《语法》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>整理自阮一峰《JavaScript标准参考教程》，原作者为阮一峰，<a href="https://github.com/ruanyf/jstutorial" target="_blank" rel="noopener">github地址</a></p>
</blockquote>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>
<p>分号前面可以没有任何内容，JavaScript引擎将其视为空语句。</p>
<p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p>
<p>语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>
<p><strong>注意，JavaScript 的变量名区分大小写，<code>A</code>和<code>a</code>是两个不同的变量。</strong></p>
<p>变量的声明和赋值，是分开的两个步骤。如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个 JavaScript 关键字，表示“无定义”。</p>
<p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。</p>
<p>JavaScript 是一种<strong>动态类型语言</strong>，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
<p><strong>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</strong></p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>
<p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量<code>a</code>的值。这时变量<code>a</code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></p>
<p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符。</p>
<p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。</p>
<p>简单说，标识符命名规则如下。</p>
<blockquote>
<p>第一个字符，可以是任意 Unicode字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。<br>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</p>
</blockquote>
<p>注意：中文是合法的标识符，可以用作变量名。</p>
<p><strong>JavaScript有一些保留字，不能用作标识符</strong>：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用<code>//</code>起头；另一种是多行注释，放在<code>/*</code>和<code>*/</code>之间。</p>
<p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p>
<p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算。</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p>
<p><strong>对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope）</strong>。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句包括<code>if</code>和<code>switch</code>。</p>
<h3 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h3><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，往往由一个条件表达式产生，指的是 JavaScript 的两个特殊值，<code>true</code>表示真，<code>false</code>表示伪。</p>
<p><strong>注意，if后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。尤其是赋值表达式不具有比较作用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 2;</span><br><span class="line">if (x = y) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;2&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码的原意是，当<code>x</code>等于<code>y</code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将<code>y</code>赋值给变量<code>x</code>，再判断变量<code>x</code>的值（等于2）的布尔值（结果为<code>true</code>）。</p>
<p>这种错误可以正常生成一个布尔值，因而不会报错。<strong>为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (x = 2) &#123; // 不报错</span><br><span class="line">if (2 = x) &#123; // 报错</span><br></pre></td></tr></table></figure>
<p>至于为什么优先采用“严格相等运算符”（<code>===</code>），而不是“相等运算符”（<code>==</code>），请参考《运算符》章节。</p>
<h3 id="if…else-结构"><a href="#if…else-结构" class="headerlink" title="if…else 结构"></a>if…else 结构</h3><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码。</p>
<p>对同一个变量进行多次判断时，多个<code>if…else</code>语句可以连写在一起。</p>
<p><code>else</code>代码块总是与离自己最近的那个<code>if</code>语句配对。</p>
<h3 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h3><p><code>switch</code>结构会根据<code>switch</code>关键字后紧跟的变量或表达式的值，选择执行相应的<code>case</code>。如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分。需要注意的是，每个case代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构。</p>
<p>多个<code>if…else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构。</p>
<p><code>switch</code>语句部分和<code>case</code>语句部分，都可以使用表达式。</p>
<p>需要注意的是，<strong>switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。</strong></p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 ?:</h3><p>JavaScript还有一个三元运算符（即该运算符需要三个运算子）<code>?:</code>，也可以用于逻辑判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式1 : 表达式2</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。</p>
<p>这个三元运算符可以被视为<code>if…else…</code>的简写形式，因此可以用于多种场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myVar;</span><br><span class="line">console.log(</span><br><span class="line">  myVar ?</span><br><span class="line">  &apos;myVar has a value&apos; :</span><br><span class="line">  &apos;myVar do not has a value&apos;</span><br><span class="line">)</span><br><span class="line">// myVar do not has a value</span><br></pre></td></tr></table></figure>
<p>上面代码利用三元运算符，输出相应的提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;);</span><br></pre></td></tr></table></figure>
<p>上面代码利用三元运算符，在字符串之中插入不同的值。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><code>while</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">while (条件) 语句;</span><br></pre></td></tr></table></figure>
<p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">for (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for语句后面的括号里面，有三个表达式。</p>
<blockquote>
<p>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。<br>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。<br>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</p>
</blockquote>
<p><strong>所有for循环，都可以改写成while循环。</strong></p>
<p><strong>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; )&#123;</span><br><span class="line">  console.log(&apos;Hello World&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。</p>
<h3 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h3><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是<strong>先运行一次循环体，然后判断循环条件。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  语句</span><br><span class="line">while (条件);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">do &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; while (条件);</span><br></pre></td></tr></table></figure>
<p>不管条件是否为真，do…while循环至少运行一次，这是这种结构最大的特点。另外，<strong><code>while</code>语句后面的分号注意不要省略。</strong></p>
<h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p><code>break</code>语句和<code>continue</code>语句都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<p><code>break</code>语句用于<strong>跳出代码块或循环</strong>。<code>for</code>循环也可以使用<code>break</code>语句跳出循环。</p>
<p><code>continue</code>语句用于<strong>立即终止本轮循环</strong>，返回循环结构的头部，开始下一轮循环。</p>
<p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环。</p>
<h3 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h3><p>JavaScript 语言允许，<strong>语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置</strong>，标签的格式如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure></p>
<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br></pre></td></tr></table></figure>
<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p><code>continue</code>语句也可以与标签配合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br><span class="line">// i=2, j=0</span><br><span class="line">// i=2, j=1</span><br><span class="line">// i=2, j=2</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种，具体如下。（ES6 又新增了第七种 Symbol 类型的值）</p>
<blockquote>
<p>数值（number）：整数和小数（比如1和3.14）<br>字符串（string）：文本（比如Hello World）。<br>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）。<br>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。<br>null：表示空值，即此处的值为空。<br>对象（object）：各种值组成的集合。</p>
</blockquote>
<p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。</p>
<p>其中，对象是最复杂的数据类型，又可以分成三个子类型。</p>
<blockquote>
<p>狭义的对象（object）<br>数组（array）<br>函数（function）</p>
</blockquote>
<p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<blockquote>
<p><code>typeof</code>运算符<br><code>instanceof</code>运算符<br><code>Object.prototype.toString</code>方法</p>
</blockquote>
<p><code>instanceof</code>运算符和<code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍<code>typeof</code>运算符。</p>
<p><code>typeof</code>运算符可以返回一个值的数据类型。数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>，函数返回<code>function</code>，<code>undefined</code>返回<code>undefined</code>（利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错），对象返回<code>object</code>，<code>null</code>返回<code>object</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">typeof v</span><br><span class="line">// &quot;undefined&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。实际编程中，这个特点通常用在判断语句，可以提高程序的健壮性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">if (v) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">if (typeof v === &quot;undefined&quot;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">typeof window // &quot;object&quot;</span><br><span class="line">typeof &#123;&#125; // &quot;object&quot;</span><br><span class="line">typeof [] // &quot;object&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，<strong>数组本质上只是一种特殊的对象</strong>。这里顺便提一下，<code>instanceof</code>运算符可以区分数组和对象。<code>instanceof</code>运算符的详细解释，请见《面向对象编程》一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">o instanceof Array // false</span><br><span class="line">a instanceof Array // true</span><br></pre></td></tr></table></figure>
<p>另外，<code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作object的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，实际上在语法效果上几乎没区别。在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) &#123;</span><br><span class="line">  console.log(&apos;undefined is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// undefined is false</span><br><span class="line"></span><br><span class="line">if (!null) &#123;</span><br><span class="line">  console.log(&apos;null is false&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// null is false</span><br><span class="line"></span><br><span class="line">undefined == null</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>含义与用法都差不多，同时设置两个这样的值其实与历史原因有关。<br>1995年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示”无”。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。<br>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为<code>0</code>，很不容易发现错误。<br>因此，他又设计了一个<code>undefined</code>。区别是这样的：<strong><code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code></strong>。</p>
<h3 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h3><p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解。</p>
<p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p>
<p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="line">function f(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">// 对象没有赋值的属性</span><br><span class="line">var o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">// 函数没有返回值时，默认返回 undefined</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">f() // undefined</span><br></pre></td></tr></table></figure>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p>
<p>下列运算符会返回布尔值：</p>
<blockquote>
<p>两元逻辑运算符： &amp;&amp; (And)，|| (Or)<br>前置逻辑运算符： ! (Not)<br>相等运算符：===，!==，==，!=<br>比较运算符：&gt;，&gt;=，&lt;，&lt;=</p>
</blockquote>
<p><strong>如果JavaScript预期某个位置应该是布尔值（比如<code>if</code>后的判断语句），会将该位置上现有的值自动转为布尔值</strong>。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<blockquote>
<p>undefined<br>null<br>false<br>0<br>NaN<br>“”或’’（空字符串）</p>
</blockquote>
<p><strong>注意，空数组（<code>[]</code>）和空对象（<code>{}</code>）对应的布尔值，都是true。</strong></p>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><p>JavaScript内部，<strong>所有数字都是以64位浮点数形式储存</strong>，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 === 1.0 // true</span><br></pre></td></tr></table></figure>
<p>这就是说，JavaScript语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的”位运算“部分。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">0.3 / 0.1</span><br><span class="line">// 2.9999999999999996</span><br><span class="line"></span><br><span class="line">(0.3 - 0.2) === (0.2 - 0.1)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>
<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<blockquote>
<p>第1位：符号位，0表示正数，1表示负数<br>第2位到第12位（共11位）：指数部分<br>第13位到第64位（共52位）：小数部分（即有效数字）</p>
</blockquote>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<p>JavaScript提供的有效数字最长为53个二进制位，即精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，即-2的53次方到2的53次方，都可以精确表示。大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript对15位的十进制数都可以精确处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 53)</span><br><span class="line">// 9007199254740992</span><br><span class="line"></span><br><span class="line">// 多出的三个有效数字，将无法保存</span><br><span class="line">9007199254740992111</span><br><span class="line">// 9007199254740992000</span><br></pre></td></tr></table></figure>
<p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的<code>111</code>）都会无法保存，变成<code>0</code>。</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则<strong> JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</strong></p>
<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 1024) // Infinity</span><br></pre></td></tr></table></figure>
<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, -1075) // 0</span><br></pre></td></tr></table></figure></p>
<p>下面是一个实际的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.5;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; 25; i++) &#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x // 0</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p>
<p>JavaScript提供<strong>Number对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性</strong>，返回可以表示的具体的最大值和最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_VALUE // 1.7976931348623157e+308</span><br><span class="line">Number.MIN_VALUE // 5e-324</span><br></pre></td></tr></table></figure>
<h2 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h2><p>JavaScript的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。数值也可以采用科学计数法表示，例子如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123e3 // 123000</span><br><span class="line">123e-3 // 0.123</span><br><span class="line">-3.1E+12</span><br><span class="line">.1e-23</span><br></pre></td></tr></table></figure>
<p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p>
<p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>
<p><strong>（1）小数点前的数字多于21位。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1234567890123456789012</span><br><span class="line">// 1.2345678901234568e+21</span><br><span class="line"></span><br><span class="line">123456789012345678901</span><br><span class="line">// 123456789012345680000</span><br></pre></td></tr></table></figure>
<p><strong>（2）小数点后的零多于5个。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 小数点后紧跟5个以上的零，</span><br><span class="line">// 就自动转为科学计数法</span><br><span class="line">0.0000003 // 3e-7</span><br><span class="line"></span><br><span class="line">// 否则，就保持原来的字面形式</span><br><span class="line">0.000003 // 0.000003</span><br></pre></td></tr></table></figure>
<h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>使用字面量（literal）直接表示一个数值时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<blockquote>
<p>十进制：没有前导<code>0</code>的数值。<br>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导<code>0</code>、且只用到0-7的八个阿拉伯数字的数值。<br>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。<br>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</p>
</blockquote>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">025 // 21，因为有前导并且后边的阿拉伯数字没有超过8</span><br><span class="line">029 // 29，有前导但是后边的阿拉伯数字超过了8</span><br><span class="line">0xff // 255</span><br><span class="line">0o377 // 255</span><br><span class="line">0b11 // 3</span><br></pre></td></tr></table></figure>
<p>通常来说，有前导<code>0</code>的数值会被视为八进制，但是如果前导<code>0</code>后面有数字8和9，则该数值被视为十进制。</p>
<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报<code>SyntaxError</code>错误。前导<code>0</code>表示八进制，处理时很容易造成混乱。ES5的严格模式和ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p>
<h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><h3 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h3><p>前面说过，JavaScript的64位浮点数之中，有一个二进制位是符号位。这意味着，<strong>任何一个数都有一个对应的负值，就连0也不例外。</strong></p>
<p>JavaScript内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-0 === +0 // true</span><br><span class="line">0 === -0 // true</span><br><span class="line">0 === +0 // true</span><br></pre></td></tr></table></figure>
<p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。<strong>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回<br>的值是不相等的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 / +0) === (1 / -0) // false</span><br></pre></td></tr></table></figure>
<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的（关于Infinity详见下文）。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><code>NaN</code>是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合，比如。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 - &apos;x&apos; // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p>
<p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.acos(2) // NaN</span><br><span class="line">Math.log(-1) // NaN</span><br><span class="line">Math.sqrt(-1) // NaN</span><br></pre></td></tr></table></figure>
<p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p>
<p>需要注意的是，<strong><code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code></strong>，使用<code>typeof</code>运算符可以看得很清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof NaN // &apos;number&apos;</span><br></pre></td></tr></table></figure>
<h4 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h4><p><code>NaN</code>不等于任何值，包括它本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN // false</span><br></pre></td></tr></table></figure></p>
<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN) // -1</span><br></pre></td></tr></table></figure></p>
<p><code>NaN</code>在布尔运算时被当作<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean(NaN) // false</span><br></pre></td></tr></table></figure></p>
<p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NaN + 32 // NaN</span><br><span class="line">NaN - 32 // NaN</span><br><span class="line">NaN * 32 // NaN</span><br><span class="line">NaN / 32 // NaN</span><br></pre></td></tr></table></figure></p>
<h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非<code>0</code>数值除以<code>0</code>，得到<code>Infinity</code>。</p>
<p><strong><code>Infinity</code>有正负之分</strong>，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷，它们是不相等的。</p>
<p>由于数值正向溢出（overflow）、负向溢出（underflow）和被<code>0</code>除，JavaScript都不报错，而是返回<code>Infinity</code>，所以单纯的数学运算几乎没有可能抛出错误。</p>
<p><strong><code>Infinity</code>大于一切数值（除了<code>NaN</code>）</strong>，<strong><code>-Infinity</code>小于一切数值（除了<code>NaN</code>）</strong>。<code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Infinity &gt; 1000 // true</span><br><span class="line">-Infinity &lt; -1000 // true</span><br></pre></td></tr></table></figure></p>
<h4 id="运算规则-1"><a href="#运算规则-1" class="headerlink" title="运算规则"></a>运算规则</h4><p><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">5 * Infinity // Infinity</span><br><span class="line">5 - Infinity // -Infinity</span><br><span class="line">Infinity / 5 // Infinity</span><br><span class="line">5 / Infinity // 0</span><br><span class="line"></span><br><span class="line">// 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。</span><br><span class="line">0 * Infinity // NaN</span><br><span class="line">0 / Infinity // 0</span><br><span class="line">Infinity / 0 // Infinity</span><br><span class="line"></span><br><span class="line">// Infinity加上或乘以Infinity，返回的还是Infinity。</span><br><span class="line">Infinity + Infinity // Infinity</span><br><span class="line">Infinity * Infinity // Infinity</span><br><span class="line"></span><br><span class="line">// Infinity减去或除以Infinity，得到NaN。</span><br><span class="line">Infinity - Infinity // NaN</span><br><span class="line">Infinity / Infinity // NaN</span><br><span class="line"></span><br><span class="line">// Infinity与null计算时，null会转成0，等同于与0的计算。</span><br><span class="line">null * Infinity // NaN</span><br><span class="line">null / Infinity // 0</span><br><span class="line">Infinity / null // Infinity</span><br><span class="line"></span><br><span class="line">// Infinity与undefined计算，返回的都是NaN。</span><br><span class="line">undefined + Infinity // NaN</span><br><span class="line">undefined - Infinity // NaN</span><br><span class="line">undefined * Infinity // NaN</span><br><span class="line">undefined / Infinity // NaN</span><br><span class="line">Infinity / undefined // NaN</span><br></pre></td></tr></table></figure>
<h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>parseInt</code>方法<strong>用于将字符串转为整数</strong>。如果字符串头部有空格，空格会被自动去除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;123&apos;) // 123</span><br></pre></td></tr></table></figure>
<p>如果parseInt的参数不是字符串，则会先转为字符串再转换。字符串转为整数的时候，是一个个字符依次转换，<strong>如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parseInt(1.23) // 1</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;1.23&apos;) // 1</span><br><span class="line"></span><br><span class="line">parseInt(&apos;8a&apos;) // 8</span><br><span class="line">parseInt(&apos;12**&apos;) // 12</span><br><span class="line">parseInt(&apos;12.34&apos;) // 12</span><br><span class="line">parseInt(&apos;15e2&apos;) // 15</span><br><span class="line">parseInt(&apos;15px&apos;) // 15</span><br></pre></td></tr></table></figure>
<p>而如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;abc&apos;) // NaN</span><br><span class="line">parseInt(&apos;.3&apos;) // NaN</span><br><span class="line">parseInt(&apos;&apos;) // NaN</span><br><span class="line">parseInt(&apos;+&apos;) // NaN</span><br><span class="line"></span><br><span class="line">parseInt(&apos;+1&apos;) // 1</span><br></pre></td></tr></table></figure>
<p>所以，<strong><code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</strong></p>
<p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。如果字符串以<code>0</code>开头，将其按照<code>10</code>进制解析。而对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(1000000000000000000000.5) // 1</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;1e+21&apos;) // 1</span><br><span class="line"></span><br><span class="line">parseInt(0.0000008) // 8</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;8e-7&apos;) // 8</span><br></pre></td></tr></table></figure>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1000&apos;) // 1000</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;1000&apos;, 10) // 1000</span><br><span class="line"></span><br><span class="line">parseInt(&apos;1000&apos;, 2) // 8</span><br><span class="line">parseInt(&apos;1000&apos;, 6) // 216</span><br><span class="line">parseInt(&apos;1000&apos;, 8) // 512</span><br></pre></td></tr></table></figure>
<p>上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p>
<p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。<strong>如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;10&apos;, 37) // NaN</span><br><span class="line">parseInt(&apos;10&apos;, 1) // NaN</span><br><span class="line"></span><br><span class="line">parseInt(&apos;10&apos;, 0) // 10</span><br><span class="line">parseInt(&apos;10&apos;, null) // 10</span><br><span class="line">parseInt(&apos;10&apos;, undefined) // 10</span><br></pre></td></tr></table></figure>
<p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。比如要将一个字符串转换为二进制，但是字符串中出现了大于等于2的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1546&apos;, 2) // 1</span><br><span class="line">parseInt(&apos;546&apos;, 2) // NaN</span><br></pre></td></tr></table></figure>
<p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。因此使用的时候一定要十分小心。下面举出几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parseInt(0x11, 36) // 43</span><br><span class="line">parseInt(0x11, 2) // 1</span><br><span class="line"></span><br><span class="line">parseInt(&apos;0x11&apos;, 2) // 0</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">parseInt(String(0x11), 36)</span><br><span class="line">parseInt(String(0x11), 2)</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&apos;17&apos;, 36)</span><br><span class="line">parseInt(&apos;17&apos;, 2)</span><br></pre></td></tr></table></figure>
<p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。</p>
<p>这种处理方式，对于八进制的前缀<code>0</code>，尤其需要注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parseInt(011, 2) // 011首先被转换为字符串9，9不是二进制的有效字符，返回NaN</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">parseInt(String(011), 2)</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">parseInt(String(9), 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parseInt(&apos;011&apos;, 2)  // 011被当作二进制处理，返回3</span><br></pre></td></tr></table></figure>
<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p><code>parseFloat</code>方法<strong>用于将一个字符串转为浮点数</strong>，会自动过滤字符串前导的空格。</p>
<p>如果字符串符合科学计数法，则会进行相应的转换。而<code>parseInt</code>是不会对符合科学记数法的字符串进行转换的。</p>
<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&apos;3.14&apos;) // 3.14</span><br><span class="line"></span><br><span class="line">parseFloat(&apos;314e-2&apos;) // 3.14</span><br><span class="line">parseFloat(&apos;0.0314E+2&apos;) // 3.14</span><br><span class="line"></span><br><span class="line">parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14</span><br><span class="line"></span><br><span class="line">parseFloat([]) // NaN</span><br><span class="line">parseFloat(&apos;FF2&apos;) // NaN</span><br><span class="line">parseFloat(&apos;&apos;) // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码中，尤其值得注意，<strong><code>parseFloat</code>会将空字符串转为<code>NaN</code></strong>。</p>
<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(true)  // NaN</span><br><span class="line">Number(true) // 1</span><br><span class="line"></span><br><span class="line">parseFloat(null) // NaN</span><br><span class="line">Number(null) // 0</span><br><span class="line"></span><br><span class="line">parseFloat(&apos;&apos;) // NaN</span><br><span class="line">Number(&apos;&apos;) // 0</span><br><span class="line"></span><br><span class="line">parseFloat(&apos;123.45#&apos;) // 123.45</span><br><span class="line">Number(&apos;123.45#&apos;) // NaN</span><br></pre></td></tr></table></figure>
<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(123) // false</span><br></pre></td></tr></table></figure>
<p>但是，<code>isNaN</code>只对数值有效，<strong>如果传入其他值，会被先转成数值</strong>。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&apos;Hello&apos;) // true</span><br><span class="line">// 相当于</span><br><span class="line">isNaN(Number(&apos;Hello&apos;)) // true</span><br><span class="line"></span><br><span class="line">isNaN(&#123;&#125;) // true</span><br><span class="line">// 等同于</span><br><span class="line">isNaN(Number(&#123;&#125;)) // true</span><br><span class="line"></span><br><span class="line">isNaN([&apos;xzy&apos;]) // true</span><br><span class="line">// 等同于</span><br><span class="line">isNaN(Number([&apos;xzy&apos;])) // true</span><br></pre></td></tr></table></figure>
<p>但是，<strong>对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNaN([]) // false</span><br><span class="line">isNaN([123]) // false</span><br><span class="line">isNaN([&apos;123&apos;]) // false</span><br></pre></td></tr></table></figure>
<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值。</p>
<p>总结来说，<strong>能被<code>Number</code>转换为数值类型的数据，使用<code>isNaN</code>就是有效的</strong>。因此，使用<code>isNaN</code>之前，最好判断一下数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断<code>NaN</code>更可靠的方法是，利用<strong><code>NaN</code>为唯一不等于自身的值</strong>的这个特点，进行判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isFinite(Infinity) // false</span><br><span class="line">isFinite(-Infinity) // false</span><br><span class="line">isFinite(NaN) // false</span><br><span class="line">isFinite(undefined) // false</span><br><span class="line">isFinite(null) // true</span><br><span class="line">isFinite(-1) // true</span><br></pre></td></tr></table></figure>
<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠<code>\</code>，用来转义。双引号字符串内部使用双引号，也是如此。</p>
<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p>
<p>字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠<code>\</code>。注意，<strong>反斜杠的后面必须是换行符，而不能有其他字符</strong>（比如空格），<strong>否则会报错</strong>。</p>
<p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p>
<p>如果想输出多行字符串，有一种利用多行注释的变通方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123; /*</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">*/&#125;).toString().split(&apos;\n&apos;).slice(1, -1).join(&apos;\n&apos;)</span><br><span class="line">// &quot;line 1</span><br><span class="line">// line 2</span><br><span class="line">// line 3&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>反斜杠（<code>\</code>）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<blockquote>
<p>\0 ：null（\u0000）<br>\b ：后退键（\u0008）<br>\f ：换页符（\u000C）<br>\n ：换行符（\u000A）<br>\r ：回车键（\u000D）<br>\t ：制表符（\u0009）<br>\v ：垂直制表符（\u000B）<br>\’ ：单引号（\u0027）<br>\” ：双引号（\u0022）<br>\ ：反斜杠（\u005C）</p>
</blockquote>
<p>反斜杠还有三种特殊用法。</p>
<ul>
<li><p>\HHH ：反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。</p>
</li>
<li><p>\xHH ：\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。</p>
</li>
<li><p>\uXXXX ：\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。</p>
</li>
</ul>
<p>如果<strong>在非特殊字符前面使用反斜杠，则反斜杠会被省略</strong>。</p>
<h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">s[0] // &quot;h&quot;</span><br><span class="line">s[1] // &quot;e&quot;</span><br><span class="line">s[4] // &quot;o&quot;</span><br><span class="line"></span><br><span class="line">// 直接对字符串使用方括号运算符</span><br><span class="line">&apos;hello&apos;[1] // &quot;e&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是，字符串与数组的相似性仅此而已。实际上，<strong>无法改变字符串之中的单个字符</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">delete s[0];</span><br><span class="line">s // &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">s[1] = &apos;a&apos;;</span><br><span class="line">s // &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">s[5] = &apos;!&apos;;</span><br><span class="line">s // &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p><code>length</code><strong>属性</strong>返回字符串的长度，该属性也是无法改变的。因为是属性所以不用加<code>()</code>。改变length属性不会生效，也不会报错。</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p>
<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f\u006F\u006F = &apos;abc&apos;;</span><br><span class="line">foo // &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p>
<h2 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h2><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<blockquote>
<p>btoa()：任意值转为 Base64 编码<br>atob()：Base64 编码转为原来的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;Hello World!&apos;;</span><br><span class="line">btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;</span><br><span class="line">atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>
<p>注意，这两个方法不适合非 ASCII 码的字符，会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btoa(&apos;你好&apos;)</span><br></pre></td></tr></table></figure></p>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。encodeURIComponent方法不会对 ASCII 字母和数字进行编码，也不会对ASCII 标点符号进行编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function b64Encode(str) &#123;</span><br><span class="line">  return btoa(encodeURIComponent(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b64Decode(str) &#123;</span><br><span class="line">  return decodeURIComponent(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span><br><span class="line">b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot;</span><br></pre></td></tr></table></figure></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p>
<p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: &apos;Hello&apos;,</span><br><span class="line">  bar: &apos;World&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，大括号就定义了一个对象，它被赋值给变量·obj·，所以变量·obj·就指向一个对象。</p>
<h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p><strong>对象的所有键名都是字符串</strong>（ES6又引入了Symbol值也可以作为键值），所以<strong>加不加引号都可以</strong>。<strong>如果键名是数值，会被自动转为字符串。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  1: &apos;a&apos;,</span><br><span class="line">  3.2: &apos;b&apos;,</span><br><span class="line">  1e2: true,</span><br><span class="line">  1e-2: true,</span><br><span class="line">  .234: true,</span><br><span class="line">  0xFF: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line">// Object &#123;</span><br><span class="line">//   1: &quot;a&quot;,</span><br><span class="line">//   3.2: &quot;b&quot;,</span><br><span class="line">//   100: true,</span><br><span class="line">//   0.01: true,</span><br><span class="line">//   0.234: true,</span><br><span class="line">//   255: true</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">obj[&apos;100&apos;] // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p>
<p><strong>如果键名不符合标识名的条件</strong>（比如第一个字符为数字，或者含有空格或运算符），<strong>且也不是数字</strong>，<strong>则必须加上引号</strong>，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var obj = &#123;</span><br><span class="line">  1p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不报错</span><br><span class="line">var obj = &#123;</span><br><span class="line">  &apos;1p&apos;: &apos;Hello World&apos;,</span><br><span class="line">  &apos;h w&apos;: &apos;Hello World&apos;,</span><br><span class="line">  &apos;p+q&apos;: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。<strong>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: function (x) &#123;</span><br><span class="line">    return 2 * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(1) // 2</span><br></pre></td></tr></table></figure></p>
<p>如果属性的值还是一个对象，就形成了链式引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = &#123; bar: &apos;hello&apos; &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo = o2;</span><br><span class="line">o1.foo.bar // &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p>
<p><strong>对象的属性之间用逗号分隔</strong>，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p>
<p><strong>属性可以动态创建，不必在对象声明时就指定。</strong></p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。<strong>修改其中一个变量，会影响到其他所有变量。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;&quot;hello world&quot;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = 1;</span><br><span class="line">o2.a // 1</span><br><span class="line"></span><br><span class="line">o2.b = 2;</span><br><span class="line">o1.b // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = 1;</span><br><span class="line">o2 // &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p>
<p>但是，<strong>这种引用只局限于对象，如果两个变量指向同一个原始类型的值，那么，变量这时都是值的拷贝。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = x;</span><br><span class="line"></span><br><span class="line">x = 2;</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure>
<p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p>
<h3 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h3><p>对象采用大括号表示，这导致了一个问题：<strong>如果行首是一个大括号，它到底是表达式还是语句？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p>
<p>为了避免这种歧义，JavaScript 规定，<strong>如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; foo: 123 &#125; // 解释为语句</span><br><span class="line">(&#123; foo: 123&#125;) // 解释为对象</span><br></pre></td></tr></table></figure>
<p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;&#123;foo: 123&#125;&apos;) // 123</span><br><span class="line">eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><h3 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h3><p>读取对象的属性，有两种方法，一种是<strong>使用点运算符</strong>，还有一种是<strong>使用方括号运算符</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p // &quot;Hello World&quot;</span><br><span class="line">obj[&apos;p&apos;] // &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p>
<p>请注意，如果<strong>使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &apos;bar&apos;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  // 1</span><br><span class="line">obj[foo]  // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p>
<p>方括号运算符内部还可以使用表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[&apos;hello&apos; + &apos; world&apos;]</span><br><span class="line">obj[3 + 3]</span><br></pre></td></tr></table></figure></p>
<p><strong>数字键可以不加引号，因为会自动转成字符串。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  0.7: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[&apos;0.7&apos;] // &quot;Hello World&quot;</span><br><span class="line">obj[0.7] // &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p>
<p>注意，<strong>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  123: &apos;hello world&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.123 // 报错</span><br><span class="line">obj[123] // &quot;hello world&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p>
<p>JavaScript 允许属性的“后绑定”，也就是说，你<strong>可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.p = 1;</span><br></pre></td></tr></table></figure>
<h3 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h3><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  key1: 1,</span><br><span class="line">  key2: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj);</span><br><span class="line">// [&apos;key1&apos;, &apos;key2&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。如果再次访问被删除的属性，会返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">Object.keys(obj) // [&quot;p&quot;]</span><br><span class="line"></span><br><span class="line">delete obj.p // true</span><br><span class="line">obj.p // undefined</span><br><span class="line">Object.keys(obj) // []</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p>
<p>注意，<strong>删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">delete obj.p // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，<strong>不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</strong></p>
<p><strong>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p // 123</span><br><span class="line">delete obj.p // false</span><br></pre></td></tr></table></figure>
<p>上面代码之中，对象<code>obj</code>的p属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>（关于<code>Object.defineProperty</code>方法的介绍，请看《标准库》的Object对象一章）。</p>
<p>另外，需要注意的是，<strong><code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性</strong>（关于继承参见《面向对象编程》章节）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">delete obj.toString // true</span><br><span class="line">obj.toString // function toString() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，<strong>即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值</strong>。</p>
<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p><code>in</code>运算符<strong>用于检查对象是否包含某个属性</strong>（注意，<strong>检查的是键名，不是键值</strong>），如果包含就返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">&apos;p&apos; in obj // true，检查的是键名</span><br></pre></td></tr></table></figure>
<p><strong><code>in</code>运算符的一个问题是</strong>，它<strong>不能识别哪些属性是对象自身的，哪些属性是继承的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">&apos;toString&apos; in obj // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toString</code>方法不是对象<code>obj</code>自身的属性，而是继承的属性。但是，<code>in</code>运算符不能识别，对继承的属性也返回<code>true</code>。</p>
<h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><p><code>for...in</code>循环<strong>用来遍历一个对象的全部属性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">  console.log(obj[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p>下面是一个使用<code>for...in</code>循环，提取对象属性名的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  x: 1,</span><br><span class="line">  y: 2</span><br><span class="line">&#125;;</span><br><span class="line">var props = [];</span><br><span class="line">var i = 0;</span><br><span class="line"></span><br><span class="line">for (var p in obj) &#123;</span><br><span class="line">  props[i++] = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props // [&apos;x&apos;, &apos;y&apos;]</span><br></pre></td></tr></table></figure>
<p><code>for...in</code>循环有两个使用注意点。</p>
<blockquote>
<p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。<br>它不仅遍历对象自身的属性，还遍历继承的属性。</p>
</blockquote>
<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">// toString 属性是存在的</span><br><span class="line">obj.toString // toString() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line">for (var p in obj) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125; // 没有任何输出</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为<strong>它默认是“不可遍历”的</strong>。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。</p>
<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，<strong>一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; name: &apos;老张&apos; &#125;;</span><br><span class="line"></span><br><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// name</span><br></pre></td></tr></table></figure></p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p><code>with</code>语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">var obj = &#123;</span><br><span class="line">  p1: 1,</span><br><span class="line">  p2: 2,</span><br><span class="line">&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 = 4;</span><br><span class="line">  p2 = 5;</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">obj.p1 = 4;</span><br><span class="line">obj.p2 = 5;</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">with (document.links[0])&#123;</span><br><span class="line">  console.log(href);</span><br><span class="line">  console.log(title);</span><br><span class="line">  console.log(style);</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">console.log(document.links[0].href);</span><br><span class="line">console.log(document.links[0].title);</span><br><span class="line">console.log(document.links[0].style);</span><br></pre></td></tr></table></figure>
<p>注意，<strong>如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 = 4;</span><br><span class="line">  p2 = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 // undefined</span><br><span class="line">p1 // 4</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<strong><code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (obj) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，<strong>建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(obj1.obj2.obj3) &#123;</span><br><span class="line">  console.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以写成</span><br><span class="line">var temp = obj1.obj2.obj3;</span><br><span class="line">console.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p>
<p>数组的赋值除了在定义时赋值，也可以先定义后赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line">arr[0] = &apos;a&apos;;</span><br><span class="line">arr[1] = &apos;b&apos;;</span><br><span class="line">arr[2] = &apos;c&apos;;</span><br></pre></td></tr></table></figure>
<p>任何类型的数据，都可以放入数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123;a: 1&#125;,</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  function() &#123;return true;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[0] // Object &#123;a: 1&#125;</span><br><span class="line">arr[1] // [1, 2, 3]</span><br><span class="line">arr[2] // function ()&#123;return true;&#125;</span><br></pre></td></tr></table></figure>
<p>上面数组arr的3个成员依次是对象、数组、函数。而如果数组的元素还是数组，就形成了多维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1, 2], [3, 4]];</span><br><span class="line">a[0][1] // 2</span><br><span class="line">a[1][1] // 4</span><br></pre></td></tr></table></figure>
<h2 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h2><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。数组的特殊性体现在，它的键名是按次序排列的一组整数<code>（0，1，2…）</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">Object.keys(arr)</span><br><span class="line">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>Object.keys</code>方法返回数组的所有键名</strong>。可以看到数组的键名就是整数0、1、2。</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">arr[&apos;0&apos;] // &apos;a&apos;</span><br><span class="line">arr[0] // &apos;a&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p>
<p>注意，这点在赋值时也成立。例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">a[1.00] = 6;</span><br><span class="line">a[1] // 6</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p>
<p>我们知道，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.0 // SyntaxError</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p>
<h2 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h2><p>数组的<code>length</code>属性，返回数组的成员数量。</p>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。<br>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">arr.length // 2</span><br><span class="line"></span><br><span class="line">arr[2] = &apos;c&apos;;</span><br><span class="line">arr.length // 3</span><br><span class="line"></span><br><span class="line">arr[9] = &apos;d&apos;;</span><br><span class="line">arr.length // 10</span><br><span class="line"></span><br><span class="line">arr[1000] = &apos;e&apos;;</span><br><span class="line">arr.length // 1001</span><br></pre></td></tr></table></figure>
<p>上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到<code>length</code>设置的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];</span><br><span class="line">arr.length // 3</span><br><span class="line"></span><br><span class="line">arr.length = 2;</span><br><span class="line">arr // [&quot;a&quot;, &quot;b&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。</p>
<p>因此，<strong>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</strong></p>
<p>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">a.length = 3;</span><br><span class="line">a[1] // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p>
<p>但是，如果人为设置length为不合法的值，JavaScript 会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 设置负值</span><br><span class="line">[].length = -1</span><br><span class="line">// RangeError: Invalid array length</span><br><span class="line"></span><br><span class="line">// 数组元素个数大于等于2的32次方</span><br><span class="line">[].length = Math.pow(2, 32)</span><br><span class="line">// RangeError: Invalid array length</span><br><span class="line"></span><br><span class="line">// 设置字符串</span><br><span class="line">[].length = &apos;abc&apos;</span><br><span class="line">// RangeError: Invalid array length</span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值，例子如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"></span><br><span class="line">a[&apos;p&apos;] = &apos;abc&apos;;</span><br><span class="line">a.length // 0</span><br><span class="line"></span><br><span class="line">a[2.1] = &apos;abc&apos;;</span><br><span class="line">a.length // 0</span><br></pre></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的<strong>数字键</strong>加<code>1</code>，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p>
<p>如果<strong>数组的键名是添加超出范围的数值，该键名会自动转为字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr[-1] = &apos;a&apos;;</span><br><span class="line">arr[Math.pow(2, 32)] = &apos;b&apos;;</span><br><span class="line"></span><br><span class="line">arr.length // 0</span><br><span class="line">arr[-1] // &quot;a&quot;</span><br><span class="line">arr[4294967296] // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们为数组arr添加了两个不合法的数字键，结果<strong>length属性没有发生变化</strong>。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p>
<h2 id="in-运算符-1"><a href="#in-运算符-1" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>检查某个<strong>键名</strong>是否存在的运算符<code>in</code>，适用于对象，也适用于数组。一定要注意检查的是键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];</span><br><span class="line">2 in arr  // true</span><br><span class="line">&apos;2&apos; in arr // true</span><br><span class="line">4 in arr // false</span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。</p>
<p>注意，<strong>如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr[100] = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">100 in arr // true</span><br><span class="line">1 in arr // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>
<h2 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h2><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p>但是，<code>for…in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">a.foo = true;</span><br><span class="line"></span><br><span class="line">for (var key in a) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// foo</span><br></pre></td></tr></table></figure>
<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，<strong>不推荐使用<code>for…in</code>遍历数组。数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环</strong>。<strong>数组的<code>forEach</code>方法，也可以用来遍历数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class="line">colors.forEach(function (color) &#123;</span><br><span class="line">  console.log(color);</span><br><span class="line">&#125;);</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure>
<h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, , 1];</span><br><span class="line">a.length // 3</span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组的空位个数影响<code>length</code>属性。</p>
<p>需要注意的是，<strong>如果最后一个元素后面有逗号，并不会产生空位。</strong>也就是说，有没有这个逗号，结果都是一样的。</p>
<p>数组的空位是可以读取的，返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [, , ,];</span><br><span class="line">a[1] // undefined</span><br></pre></td></tr></table></figure>
<p><strong>使用delete命令删除一个数组成员，会形成空位</strong>，并且不会影响<code>length</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">delete a[1];</span><br><span class="line"></span><br><span class="line">a[1] // undefined</span><br><span class="line">a.length // 3</span><br></pre></td></tr></table></figure>
<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，<strong>使用<code>length</code>属性进行数组遍历，一定要非常小心。</strong></p>
<p><strong>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.forEach(function (x, i) &#123;</span><br><span class="line">  console.log(i + &apos;. &apos; + x);</span><br><span class="line">&#125;)</span><br><span class="line">// 不产生任何输出</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 不产生任何输出</span><br><span class="line"></span><br><span class="line">Object.keys(a)</span><br><span class="line">// []</span><br></pre></td></tr></table></figure>
<p>但如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = [undefined, undefined, undefined];</span><br><span class="line"></span><br><span class="line">a.forEach(function (x, i) &#123;</span><br><span class="line">  console.log(i + &apos;. &apos; + x);</span><br><span class="line">&#125;);</span><br><span class="line">// 0. undefined</span><br><span class="line">// 1. undefined</span><br><span class="line">// 2. undefined</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">Object.keys(a)</span><br><span class="line">// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]</span><br></pre></td></tr></table></figure>
<p>这就是说，<strong>空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是undefined，所以遍历不会跳过。</strong></p>
<h2 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h2><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  0: &apos;a&apos;,</span><br><span class="line">  1: &apos;b&apos;,</span><br><span class="line">  2: &apos;c&apos;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[0] // &apos;a&apos;</span><br><span class="line">obj[1] // &apos;b&apos;</span><br><span class="line">obj.length // 3</span><br><span class="line">obj.push(&apos;d&apos;) // TypeError: obj.push is not a function</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为<strong>它们不具备数组特有的方法</strong>。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，<strong>这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  length: 0</span><br><span class="line">&#125;;</span><br><span class="line">obj[3] = &apos;d&apos;;</span><br><span class="line">obj.length // 0</span><br></pre></td></tr></table></figure>
<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// arguments对象</span><br><span class="line">function args() &#123; return arguments &#125;</span><br><span class="line">var arrayLike = args(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">arrayLike[0] // &apos;a&apos;</span><br><span class="line">arrayLike.length // 2</span><br><span class="line">arrayLike instanceof Array // false</span><br><span class="line"></span><br><span class="line">// DOM元素集</span><br><span class="line">var elts = document.getElementsByTagName(&apos;h3&apos;);</span><br><span class="line">elts.length // 3</span><br><span class="line">elts instanceof Array // false</span><br><span class="line"></span><br><span class="line">// 字符串</span><br><span class="line">&apos;abc&apos;[1] // &apos;b&apos;</span><br><span class="line">&apos;abc&apos;.length // 3</span><br><span class="line">&apos;abc&apos; instanceof Array // false</span><br></pre></td></tr></table></figure>
<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>
<p>关于arguments作一个简短的概述：在函数代码中，使用特殊对象<code>arguments</code>，开发者无需明确指出参数名，就能访问它们。</p>
<p>例如，在函数 <code>sayHi()</code> 中，第一个参数是<code>message</code>。用 <code>arguments[0]</code>也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。<br>因此，无需明确命名参数，就可以重写函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  if (arguments[0] == &quot;bye&quot;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(arguments[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以用 <code>arguments</code> 对象检测函数的参数个数，引用属性 <code>arguments.length</code>即可。</p>
<p>用<code>arguments</code>对象判断传递给函数的参数个数，即可模拟函数重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doAdd() &#123;</span><br><span class="line">  if(arguments.length == 1) &#123;</span><br><span class="line">    alert(arguments[0] + 5);</span><br><span class="line">  &#125; else if(arguments.length == 2) &#123;</span><br><span class="line">    alert(arguments[0] + arguments[1]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(10);	//输出 &quot;15&quot;</span><br><span class="line">doAdd(40, 20);	//输出 &quot;60&quot;</span><br></pre></td></tr></table></figure>
<p>当只有一个参数时，<code>doAdd()</code>函数给参数加5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，<code>doAdd(10)</code>输出的是”15”，而 doAdd(40, 20) 输出的是”60”。<br>虽然不如重载那么好，不过已足以避开 ECMAScript 的这种限制。</p>
<p>回到正题，<strong>使用数组的slice方法可以将“类似数组的对象”变成真正的数组。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></p>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function print(value, index) &#123;</span><br><span class="line">  console.log(index + &apos; : &apos; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// forEach 方法</span><br><span class="line">function logArgs() &#123;</span><br><span class="line">  Array.prototype.forEach.call(arguments, function (elem, i) &#123;</span><br><span class="line">    console.log(i + &apos;. &apos; + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于 for 循环</span><br><span class="line">function logArgs() &#123;</span><br><span class="line">  for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    console.log(i + &apos;. &apos; + arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br></pre></td></tr></table></figure>
<p>注意，<strong>这种方法比直接使用数组原生的<code>forEach</code>要慢</strong>，所以<strong>最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.prototype.slice.call(&apos;abc&apos;);</span><br><span class="line">arr.forEach(function (chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>JavaScript 有三种声明函数的方法。</p>
<p><strong>（1）function 命令</strong></p>
<p><code>function</code>命令声明的代码区块，就是一个函数。<strong><code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</strong>。比如。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function print(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）函数表达式</strong></p>
<p>除了用function命令声明函数，还<strong>可以采用变量赋值的写法</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var print = function(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这种写法将一个匿名函数赋值给变量</strong>。这时，<strong>这个匿名函数又称函数表达式</strong>（Function Expression），因为赋值语句的等号右侧只能放表达式。</p>
<p><strong>采用函数表达式声明函数时，function命令后面不带有函数名</strong>。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var print = function x()&#123;</span><br><span class="line">  console.log(typeof x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">// ReferenceError: x is not defined</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">// function</span><br></pre></td></tr></table></figure>
<p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用。<strong>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）</strong>。因此，下面的形式声明函数也非常常见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = function f() &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<strong>函数的表达式需要在语句的结尾加上分号，表示语句结束</strong>。<strong>而函数的声明在结尾的大括号后面不用加分号</strong>。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p>
<p><strong>（3）Function 构造函数</strong></p>
<p>第三种声明函数的方式是<code>Function</code>构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add = new Function(</span><br><span class="line">  &apos;x&apos;,</span><br><span class="line">  &apos;y&apos;,</span><br><span class="line">  &apos;return x + y&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Function构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。<br>你<strong>可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo = new Function(</span><br><span class="line">  &apos;return &quot;hello world&quot;&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p>
<p>总的来说，<strong>这种声明函数的方式非常不直观，几乎无人使用</strong>。</p>
<h3 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h3><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">f() // 2</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">f() // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，后一次的函数声明覆盖了前面一次。而且，<strong><span style="color:red;">由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。</span></strong></p>
<h3 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 1) // 2</span><br></pre></td></tr></table></figure>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>。</p>
<p>函数可以调用自身，这就是递归（recursion）。下面就是<strong>通过递归，计算斐波那契数列</strong>的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fib(num) &#123;</span><br><span class="line">  if (num === 0) return 0;</span><br><span class="line">  if (num === 1) return 1;</span><br><span class="line">  return fib(num - 2) + fib(num - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(6) // 8</span><br></pre></td></tr></table></figure></p>
<h3 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h3><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>
<p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将函数赋值给一个变量</span><br><span class="line">var operator = add;</span><br><span class="line"></span><br><span class="line">// 将函数作为参数和返回值</span><br><span class="line">function a(op)&#123;</span><br><span class="line">  return op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(1, 1)</span><br></pre></td></tr></table></figure></p>
<h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p>JavaScript 引擎将函数名视同变量名，所以<strong>采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部</strong>。所以，下面的代码不会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line">function f() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数<code>f</code>。但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了。但是，<strong>如果采用赋值语句定义函数，JavaScript 就会报错。</strong></p>
<p>这也就是说，只有函数声明形式才能被提升，赋值形式是无法提升的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line">var f = function ()&#123;&#125;;</span><br><span class="line">// TypeError: undefined is not a function</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f;</span><br><span class="line">f();</span><br><span class="line">f = function () &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错。</p>
<p>因此，<strong>如果同时采用<code>function</code>命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义，因为function命令声明的函数被提升了，而后才执行到赋值语句的定义，此时函数已经被覆盖了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(&apos;1&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(&apos;2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<h3 id="不能在条件语句中声明函数"><a href="#不能在条件语句中声明函数" class="headerlink" title="不能在条件语句中声明函数"></a>不能在条件语句中声明函数</h3><p>根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (foo) &#123;</span><br><span class="line">  function x() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  function x() &#123;&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码分别在<code>if</code>代码块和<code>try</code>代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。</p>
<p>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  function f() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 不报错</span><br></pre></td></tr></table></figure>
<p>上面代码的原始意图是不声明函数<code>f</code>，但是由于<code>f</code>的提升，导致<code>if</code>语句无效，所以上面的代码不会报错。<strong>要达到在条件语句中定义函数的目的，只有使用函数表达式</strong>。如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  var f = function () &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // undefined</span><br></pre></td></tr></table></figure>
<h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>函数的<code>name</code>属性返回函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;&#125;</span><br><span class="line">f1.name // &quot;f1&quot;</span><br></pre></td></tr></table></figure>
<p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f2 = function () &#123;&#125;;</span><br><span class="line">f2.name // &quot;f2</span><br></pre></td></tr></table></figure>
<p>但是，上面这种情况，<strong>只有在变量的值是一个匿名函数时<code>name</code>属性才会返回变量名。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f3 = function myName() &#123;&#125;;</span><br><span class="line">f3.name // &apos;myName&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，<strong>真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用。</strong></p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myFunc = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function test(f) &#123;</span><br><span class="line">  console.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) // myFunc</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数。</p>
<h3 id="length-属性-2"><a href="#length-属性-2" class="headerlink" title="length 属性"></a>length 属性</h3><p><strong>函数的<code>length</code>属性返回函数预期传入的参数个数</strong>，即<strong>函数定义之中的参数个数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;&#125;</span><br><span class="line">f.length // 2</span><br></pre></td></tr></table></figure>
<p>上面代码定义了空函数<code>f</code>，它的<strong><code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终不变</strong>，等于<code>2</code>。</p>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>函数的<code>toString</code>方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line">// function f() &#123;</span><br><span class="line">//  a();</span><br><span class="line">//  b();</span><br><span class="line">//  c();</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>函数内部的注释也可以返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;/*</span><br><span class="line">  这是一个</span><br><span class="line">  多行注释</span><br><span class="line">*/&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line">// &quot;function f()&#123;/*</span><br><span class="line">//   这是一个</span><br><span class="line">//   多行注释</span><br><span class="line">// */&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>利用这一点，可以变相实现多行字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var multiline = function (fn) &#123;</span><br><span class="line">  var arr = fn.toString().split(&apos;\n&apos;);</span><br><span class="line">  return arr.slice(1, arr.length - 1).join(&apos;\n&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;/*</span><br><span class="line">  这是一个</span><br><span class="line">  多行注释</span><br><span class="line">*/&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line">// &quot; 这是一个</span><br><span class="line">//   多行注释&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>作用域（scope）指的是变量存在的范围</strong>。</p>
<p>在<font color="red"><strong>ES5</strong></font>的规范中，<font color="red"><strong>Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在</strong></font>。<font color="red"><strong>ES6 </strong></font>又新增了块级作用域，本教程不涉及。</p>
<p><strong>函数外部声明的变量就是全局变量</strong>（global variable），它<strong>可以在函数内部读取</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>。</p>
<p>在<strong>函数内部定义的变量，外部无法读取，称为“局部变量”</strong>（local variable）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  var v = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v // ReferenceError: v is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p><strong><font color="red">函数内部定义的变量，会在该作用域内覆盖同名全局变量</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var v = 2;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 2</span><br><span class="line">v // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>。</p>
<p>注意，<strong><font color="red">对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var x = 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);  // 5</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<h3 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h3><p>与全局作用域一样，<strong>函数作用域内部也会产生“变量提升”现象</strong>。<strong><code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    var tmp = x - 100;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function foo(x) &#123;</span><br><span class="line">  var tmp;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    tmp = x - 100;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h3><p><strong>函数</strong>本身也是一个值，也有自己的作用域。它<strong>的作用域</strong>与变量一样，<strong>就是其声明时所在的作用域，与其运行时所在的作用域无关</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var x = function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>总之，<strong>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域</strong>。</p>
<p>很容易犯错的一点是，<strong>如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x = function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function y(f) &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y(x)</span><br><span class="line">// ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，<strong>函数体内部声明的函数，作用域绑定函数体内部</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var x = 1;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 2;</span><br><span class="line">var f = foo();</span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(2) // 4</span><br><span class="line">square(3) // 9</span><br></pre></td></tr></table></figure>
<p>上式的<code>x</code>就是<code>square</code>函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<h3 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h3><p>函数参数不是必需的，Javascript 允许省略参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) // 1</span><br><span class="line">f(1) // 1</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">f.length // 2</span><br></pre></td></tr></table></figure>
<p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为<code>undefined</code>。需要注意的是，<strong><font color="red">函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数</font></strong>。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f( , 1) // SyntaxError: Unexpected token ,(…)</span><br><span class="line">f(undefined, 1) // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果省略第一个参数，就会报错。</p>
<h3 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h3><p><strong>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p = 2;</span><br><span class="line"></span><br><span class="line">function f(p) &#123;</span><br><span class="line">  p = 3;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，<strong>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line"></span><br><span class="line">function f(o) &#123;</span><br><span class="line">  o.p = 2;</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj.p // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">function f(o) &#123;</span><br><span class="line">  o = [2, 3, 4];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>上面代码中，在函数<code>f</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，<strong>形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响</strong>。</p>
<h3 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h3><p><strong>如果有同名的参数，则取最后出现的那个值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) // 2</span><br><span class="line">f(1) // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>有两个参数，且参数名都是<code>a</code>。取值的时候，以后面的<code>a</code>为准，<strong><font color="red">即使后面的<code>a</code>没有值或被省略，也是以其为准</font></strong>。</p>
<p>调用函数<code>f</code>的时候，如果没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1) // 1</span><br></pre></td></tr></table></figure></p>
<h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>由于JavaScript允许函数有不定数目的参数，所以<strong>需要一种机制，可以在函数体内部读取所有参数</strong>。这就是<code>arguments</code>对象的由来。</p>
<p><strong><code>arguments</code>对象包含了<font color="red">函数运行时</font>的所有参数</strong>，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。<strong>这个对象只有在函数体内部，才可以使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f = function (one) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">  console.log(arguments[1]);</span><br><span class="line">  console.log(arguments[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
<p><strong>正常模式下</strong>，<strong><code>arguments</code>对象可以在运行时修改</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f = function(a, b) &#123;</span><br><span class="line">  arguments[0] = 3;</span><br><span class="line">  arguments[1] = 2;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) // 5</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>调用时传入的参数，在函数内部被修改成3和2。</p>
<p><strong>严格模式下</strong>，<strong><code>arguments</code>对象是一个只读对象，修改它是无效的，但不会报错</strong>。<font color="red">使用<code>&#39;use strict&#39;;</code>开启严格模式</font>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f = function(a, b) &#123;</span><br><span class="line">  &apos;use strict&apos;; // 开启严格模式</span><br><span class="line">  arguments[0] = 3; // 无效</span><br><span class="line">  arguments[1] = 2; // 无效</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象就是无效的。</p>
<p><strong>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return arguments.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) // 3</span><br><span class="line">f(1) // 1</span><br><span class="line">f() // 0</span><br></pre></td></tr></table></figure>
<h4 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h4><p>需要注意的是，虽然<code>arguments</code>很像数组，但它<strong>是一个对象</strong>。<strong>数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用</strong>。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。<strong><font color="red">下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">var args = [];</span><br><span class="line">for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">  args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="callee-属性"><a href="#callee-属性" class="headerlink" title="callee 属性"></a>callee 属性</h4><p><strong><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(arguments.callee === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // true</span><br></pre></td></tr></table></figure>
<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此<strong>不建议使用</strong>。</p>
<h2 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><font color="red">闭包</font></h3><p>闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>理解闭包，首先必须理解变量作用域。前面提到，<strong>JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var n = 999;</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line">  console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() // 999</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p>
<p>但是，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n = 999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(n)</span><br><span class="line">// Uncaught ReferenceError: n is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n = 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">　　console.log(n); // 999</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 <strong><font color="red">JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量</font></strong>。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p>
<p><strong><font color="red">闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数</font></strong>。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此<strong>可以把闭包简单理解成“定义在一个函数内部的函数”</strong>。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。<strong>*在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</strong>。</p>
<p><strong>闭包的最大用处有两个，一个是<font color="red">可以读取函数内部的变量</font>，另一个就是<font color="red">让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在</font>。</strong></p>
<p>请看下面的例子，<strong>闭包使得内部变量记住上一次调用时的运算结果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createIncrementor(start) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inc = createIncrementor(5);</span><br><span class="line"></span><br><span class="line">inc() // 5</span><br><span class="line">inc() // 6</span><br><span class="line">inc() // 7</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么会这样呢？原因就在于<code>inc</code>始终在内存中，而<code>inc</code>的存在依赖于<code>createIncrementor</code>，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p>这也就是说，<code>start</code>作为<code>createIncreamentor</code>的内部变量，一直没有被回收，所以这个<code>start</code>一直占用内存，可以想象，从第一次声明<code>inc</code>时传入5，<code>start</code>的值为5，因为<code>inc</code>的作用就是返回<code>start</code>的值，然后再将<code>start</code>自增1，所以第一次调用时会返回5，而第二次调用时，<code>start</code>在上次调用时已经自增了1，并且没有被回收，所以第二次调用的结果为6，第二次返回6之后<code>start</code>的值又变为7了。依次类推。</p>
<p>闭包的另一个用处，是<strong><font color="red">封装对象的私有属性和私有方法</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  var _age;</span><br><span class="line">  function setAge(n) &#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  function getAge() &#123;</span><br><span class="line">    return _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge, // 注意这里返回的getAge是getAge函数</span><br><span class="line">    setAge: setAge // 注意这里返回的setAge是setAge函数</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Person(&apos;张三&apos;);</span><br><span class="line">p1.setAge(25);</span><br><span class="line">p1.getAge() // 25</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，<strong>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大</strong>。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><p>在 Javascript 中，<strong><font color="red">圆括号<code>()</code>是一种运算符，跟在函数名之后，表示调用该函数</font></strong>。比如，print<code>()</code>就表示调用print函数。</p>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function()&#123; /* code */ &#125;();</span><br><span class="line">// SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>
<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 语句</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 表达式</span><br><span class="line">var f = function f() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免解析上的歧义，JavaScript 引擎规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>解决方法就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* code */ &#125;());</span><br><span class="line">// 或者</span><br><span class="line">(function()&#123; /* code */ &#125;)();</span><br></pre></td></tr></table></figure>
<p>上面两种写法都是<strong>以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误</strong>。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">(function()&#123; /* code */ &#125;())</span><br><span class="line">(function()&#123; /* code */ &#125;())</span><br></pre></td></tr></table></figure></p>
<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var i = function()&#123; return 10; &#125;();</span><br><span class="line">true &amp;&amp; function()&#123; /* code */ &#125;();</span><br><span class="line">0, function()&#123; /* code */ &#125;();</span><br></pre></td></tr></table></figure></p>
<p>甚至像下面这样写，也是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!function () &#123; /* code */ &#125;();</span><br><span class="line">~function () &#123; /* code */ &#125;();</span><br><span class="line">-function () &#123; /* code */ &#125;();</span><br><span class="line">+function () &#123; /* code */ &#125;();</span><br></pre></td></tr></table></figure></p>
<p><strong>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是<font color="red">不必为函数命名，避免了污染全局变量</font>；二是<font color="red">IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">var tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>
<h2 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h2><p><code>eval</code>命令的作用是，将字符串当作语句执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;var a = 1;&apos;);</span><br><span class="line">a // 1</span><br></pre></td></tr></table></figure>
<p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p>
<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;return;&apos;);</span><br></pre></td></tr></table></figure>
<p><strong><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值</strong>，造成安全问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">eval(&apos;a = 2&apos;);</span><br><span class="line"></span><br><span class="line">a // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。<strong>由于这个原因，<code>eval</code>有安全风险</strong>。</p>
<p>为了防止这种风险，JavaScript 规定，<strong>如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function f() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  eval(&apos;var foo = 123&apos;);</span><br><span class="line">  console.log(foo);  // ReferenceError: foo is not defined</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部<font color="red">声明</font>的<code>foo</code>变量，就不会影响到外部。</p>
<p>不过，<strong>即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function f() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  var foo = 1;</span><br><span class="line">  eval(&apos;foo = 2&apos;);</span><br><span class="line">  console.log(foo);  // 2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在</strong>。</p>
<p>此外，<code>eval</code>的命令字符串不会得到 JavaScript 引擎的优化，<strong>运行速度较慢。这也是一个不应该使用它的理由</strong>。</p>
<p>通常情况下，<code>eval</code>最常见的场合是<strong>解析 JSON 数据字符串</strong>，不过<strong>正确的做法应该是使用浏览器提供的<code>JSON.parse</code>方法</strong>。</p>
<p>JavaScript 引擎内部，<code>eval</code>实际上是一个引用，默认调用一个内部方法。这使得<code>eval</code>的使用分成两种情况，<strong>一种是像上面这样的调用<code>eval(expression)</code>，这叫做“直接使用”，这种情况下<code>eval</code>的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时<code>eval</code>的作用域总是全局作用域</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  var e = eval;</span><br><span class="line">  e(&apos;console.log(a)&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。</p>
<p><code>eval</code>的间接调用的形式五花八门，<strong>只要不是直接调用，即只要不是<code>eval(expression)</code>的形式，都属于间接调用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval.call(null, &apos;...&apos;)</span><br><span class="line">window.eval(&apos;...&apos;)</span><br><span class="line">(1, eval)(&apos;...&apos;)</span><br><span class="line">(eval, eval)(&apos;...&apos;)</span><br></pre></td></tr></table></figure>
<p>上面这些形式都是<code>eval</code>的间接调用，因此它们的作用域都是全局作用域。</p>
<p>与<code>eval</code>作用类似的还有<code>Function</code>构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var jsonp = &apos;foo(&#123;&quot;id&quot;: 42&#125;)&apos;;</span><br><span class="line"></span><br><span class="line">var f = new Function( &apos;foo&apos;, jsonp );</span><br><span class="line">// 相当于定义了如下函数</span><br><span class="line">// function f(foo) &#123;</span><br><span class="line">//   foo(&#123;&quot;id&quot;:42&#125;);</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">f(function (json) &#123;</span><br><span class="line">  console.log( json.id ); // 42</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>jsonp</code>是一个字符串，<code>Function</code>构造函数将这个字符串，变成了函数体。调用该函数的时候，<code>jsonp</code>就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。</p>
<p>对于本例来说就是将<code>f</code>函数接收的参数，也就是作为参数的函数代码放在函数<code>f</code>的作用域里执行。函数<code>f</code>的作用就是接收一个函数，向这个函数传参，参数为<code>{&quot;id&quot;:42}</code>，并且调用。本例中对<code>f</code>传入了一个函数，传入的函数的作用是接收一个<code>json</code>值，并且打印这个<code>json</code>值的<code>id</code>属性的值。总的来说，就是在函数<code>f</code>的内部调用了打印<code>json</code>数据的函数。</p>
<p>不过，<code>new Function()</code>的写法也可以读写全局作用域，所以也是应该避免使用它。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>加法运算符（<code>+</code>）是最常见的运算符，<strong>用来求两个数值的和</strong>。</p>
<p>需要注意的是，<strong>JavaScript 允许非数值的相加</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true + true // 2</span><br><span class="line">1 + true // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，<strong>布尔值都会自动转成数值，然后再相加</strong>。</p>
<p>比较特殊的是，<strong>如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; + &apos;bc&apos; // &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果一个运算子是字符串，另一个运算子是非字符串，这时<font color="red">非字符串会转成字符串</font>，再连接在一起</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + &apos;a&apos; // &quot;1a&quot;</span><br><span class="line">false + &apos;a&apos; // &quot;falsea&quot;</span><br></pre></td></tr></table></figure>
<p><strong>加法运算符是在运行时决定，到底是执行相加，还是执行连接</strong>。也就是说，<strong><font color="red">运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）</font></strong>。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;3&apos; + 4 + 5 // &quot;345&quot;，先执行&apos;3&apos;+4的连接操作，再执行了‘34’+5的连接操作</span><br><span class="line">3 + 4 + &apos;5&apos; // &quot;75&quot;，先执行了3+4等于7，再执行了7+‘5’的连接操作</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>由于从左到右的运算次序，字符串的位置不同会导致不同的结果</strong>。</p>
<p><strong>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载</strong>。<strong>它们的规则是：<font color="red">所有运算子一律转为数值</font>，再进行相应的数学运算</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 - &apos;2&apos; // -1</span><br><span class="line">1 * &apos;2&apos; // 2</span><br><span class="line">1 / &apos;2&apos; // 0.5</span><br></pre></td></tr></table></figure>
<p>上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算。</p>
<h3 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h3><p><strong>如果运算子是对象，必须先转成原始类型的值，然后再相加</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>转成原始类型的值是<code>[object Object]</code>，再加<code>2</code>就得到了上面的结果。</p>
<p>对象转成原始类型的值，规则如下。</p>
<p>首先，自动调用对象的<code>valueOf</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj.valueOf() // &#123; p: 1 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>一般来说，对象的<code>valueOf</code>方法总是返回对象自身</strong>，这时再自动调用对象的<code>toString</code>方法，将其转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj.valueOf().toString() // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p><strong>对象的<code>toString</code>方法默认返回<code>[object Object]</code></strong>，所以就得到了最前面那个例子的结果。</p>
<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + 2 // 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们定义<code>obj</code>对象的<code>valueOf</code>方法返回<code>1</code>，于是<code>obj + 2</code>就得到了<code>3</code>。这个例子中，<strong>由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法</strong>。</p>
<p>下面是自定义<code>toString</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + 2 // &quot;hello2&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>toString</code>方法返回字符串<code>hello</code>。前面说过，<strong>只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串</strong>。</p>
<p>注意，toString方法不一定非要返回字符串类型的值，也可以返回一个数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj+2 // 3</span><br></pre></td></tr></table></figure></p>
<p>同理，valueOf方法也不一定非要返回数值类型的值，也可以返回字符串或其他类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj + 2 // &quot;hello2&quot;</span><br></pre></td></tr></table></figure></p>
<p>我们回到正题，这里有一个特例，<strong><font color="red">如果运算子是一个<code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Date();</span><br><span class="line">obj.valueOf = function () &#123; return 1 &#125;;</span><br><span class="line">obj.toString = function () &#123; return &apos;hello&apos; &#125;;</span><br><span class="line"></span><br><span class="line">obj + 2 // &quot;hello2&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>包括加法运算符在内，JavaScript 共提供10个算术运算符，用来完成基本的算术运算。</p>
<blockquote>
<p>加法运算符：<code>x + y</code><br>减法运算符： <code>x - y</code><br>乘法运算符：<code>x * y</code><br>除法运算符：<code>x / y</code><br>指数运算符：<code>x ** y</code><br>余数运算符：<code>x % y</code><br>自增运算符：<code>++x</code> 或者 <code>x++</code><br>自减运算符：<code>--x</code> 或者 <code>x--</code><br>数值运算符： <code>+x</code><br>负数值运算符：<code>-x</code></p>
</blockquote>
<p>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算。下面介绍其他几个算术运算符。</p>
<h3 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h3><p>余数运算符（<code>%</code>）<strong>返回前一个运算子被后一个运算子除，所得的余数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 % 5 // 2，即12除以5得到的余数</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong><font color="red">余数运算的运算结果的正负号由第一个运算子的正负号决定</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 % 2 // -1</span><br><span class="line">1 % -2 // 1</span><br></pre></td></tr></table></figure>
<p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6.5 % 2.1</span><br><span class="line">// 0.19999999999999973</span><br></pre></td></tr></table></figure>
<h3 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h3><p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是<strong>将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">++x // 2</span><br><span class="line">x // 2</span><br><span class="line"></span><br><span class="line">--x // 1</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure>
<p>上面代码的变量<code>x</code>自增后，返回<code>2</code>，再进行自减，返回<code>1</code>。这两种情况都会使得，原始变量<code>x</code>的值发生改变。</p>
<p><strong>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 1;</span><br><span class="line"></span><br><span class="line">x++ // 1</span><br><span class="line">++y // 2</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>x</code>是先返回当前值，然后自增，所以得到<code>1</code>；<code>y</code>是先自增，然后返回新的值，所以得到<code>2</code>。</p>
<h3 id="数值运算符，负数值运算符"><a href="#数值运算符，负数值运算符" class="headerlink" title="数值运算符，负数值运算符"></a>数值运算符，负数值运算符</h3><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p>
<p><strong>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+true // 1</span><br><span class="line">+[] // 0</span><br><span class="line">+&#123;&#125; // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）。具体的类型转换规则，参见《数据类型转换》一章。</p>
<p><strong>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符，但是连用的时候记得加括号，否则会变成自减运算符</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">-x // -1</span><br><span class="line">-(-x) // 1</span><br></pre></td></tr></table></figure>
<p>上面代码最后一行的圆括号不可少，否则会变成自减运算符。</p>
<p><strong>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值</strong>。</p>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p><strong>指数运算符（`</strong>`）完成指数运算，前一个运算子是底数，后一个运算子是指数**。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ** 3 // 1，即1的3次方</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符（Assignment Operators）<strong>用于给变量赋值</strong>。</p>
<p>最常见的赋值运算符，当然就是等号（<code>=</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将 1 赋值给变量 x</span><br><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">// 将变量 y 的值赋值给变量 x</span><br><span class="line">var x = y;</span><br></pre></td></tr></table></figure>
<p><strong>赋值运算符还可以与其他运算符结合，形成变体</strong>。下面是与算术运算符的结合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 x = x + y</span><br><span class="line">x += y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x - y</span><br><span class="line">x -= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x * y</span><br><span class="line">x *= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x / y</span><br><span class="line">x /= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x % y</span><br><span class="line">x %= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x ** y</span><br><span class="line">x **= y</span><br></pre></td></tr></table></figure>
<p>下面是与位运算符的结合（关于位运算符，请见后文的介绍）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 x = x &gt;&gt; y</span><br><span class="line">x &gt;&gt;= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x &lt;&lt; y</span><br><span class="line">x &lt;&lt;= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x &gt;&gt;&gt; y</span><br><span class="line">x &gt;&gt;&gt;= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x &amp; y</span><br><span class="line">x &amp;= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x | y</span><br><span class="line">x |= y</span><br><span class="line"></span><br><span class="line">// 等同于 x = x ^ y</span><br><span class="line">x ^= y</span><br></pre></td></tr></table></figure></p>
<p>这些<strong>复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量</strong>。</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符<strong>用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &gt; 1 // true</span><br></pre></td></tr></table></figure>
<p>注意，<strong>比较运算符可以比较各种类型的值，不仅仅是数值</strong>。</p>
<p>JavaScript 一共提供了8个比较运算符。</p>
<blockquote>
<p><code>&lt;</code> 小于运算符<br><code>&gt;</code> 大于运算符<br><code>&lt;=</code> 小于或等于运算符<br><code>&gt;=</code> 大于或等于运算符<br><code>==</code> 相等运算符<br><code>===</code> 严格相等运算符<br><code>!=</code> 不相等运算符<br><code>!==</code> 严格不相等运算符</p>
</blockquote>
<p>这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，<strong>对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小</strong>。</p>
<h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><p>字符串按照字典顺序进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat&apos; &gt; &apos;dog&apos; // false</span><br><span class="line">&apos;cat&apos; &gt; &apos;catalog&apos; // false</span><br><span class="line">&apos;cat&apos; &gt; &apos;apple&apos; // true</span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;cat&apos; &gt; &apos;Cat&apos; // true&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，小写的<code>c</code>的 Unicode 码点（99）大于大写的C的 <code>Unicode</code> 码点（67），所以返回<code>true</code>。</p>
<p>总体上来讲，小写字母都在大写字母的后边，都比大写字母大。</p>
<p>由于所有字符都有 Unicode 码点，因此汉字也可以比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;大&apos; &gt; &apos;小&apos; // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，“大”的 Unicode 码点是<code>22823</code>，“小”是<code>23567</code>，因此返回false。</p>
<h3 id="非字符串的比较"><a href="#非字符串的比较" class="headerlink" title="非字符串的比较"></a>非字符串的比较</h3><h4 id="原始类型的值"><a href="#原始类型的值" class="headerlink" title="原始类型的值"></a>原始类型的值</h4><p><strong>两个原始类型的值的比较，除了相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>），其他比较运算符都是先转成数值再比较。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 &gt; &apos;4&apos; // true</span><br><span class="line">// 等同于 5 &gt; Number(&apos;4&apos;)</span><br><span class="line">// 即 5 &gt; 4</span><br><span class="line"></span><br><span class="line">true &gt; false // true</span><br><span class="line">// 等同于 Number(true) &gt; Number(false)</span><br><span class="line">// 即 1 &gt; 0</span><br><span class="line"></span><br><span class="line">2 &gt; true // true</span><br><span class="line">// 等同于 2 &gt; Number(true)</span><br><span class="line">// 即 2 &gt; 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串和布尔值都会先转成数值，再进行比较。</p>
<p>这里有一个特殊情况，即任何值（包括<code>NaN</code>本身）与<code>NaN</code>比较，返回的都是<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &gt; NaN // false</span><br><span class="line">1 &lt;= NaN // false</span><br><span class="line">&apos;1&apos; &gt; NaN // false</span><br><span class="line">&apos;1&apos; &lt;= NaN // false</span><br><span class="line">NaN &gt; NaN // false</span><br><span class="line">NaN &lt;= NaN // false</span><br></pre></td></tr></table></figure>
<h4 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h4><p><strong>如果运算子是对象，会转为原始类型的值，再进行比较</strong>。</p>
<p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法，详细解释参见《数据类型的转换》一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = [2];</span><br><span class="line">x &gt; &apos;11&apos; // true</span><br><span class="line">// 等同于 [2].valueOf().toString() &gt; &apos;11&apos;</span><br><span class="line">// 即 &apos;2&apos; &gt; &apos;11&apos;</span><br><span class="line"></span><br><span class="line">x.valueOf = function () &#123; return &apos;1&apos; &#125;;</span><br><span class="line">x &gt; &apos;11&apos; // false</span><br><span class="line">// 等同于 [2].valueOf() &gt; &apos;11&apos;</span><br><span class="line">// 即 &apos;1&apos; &gt; &apos;11&apos;</span><br></pre></td></tr></table></figure>
<p>两个对象之间的比较也是如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[2] &gt; [1] // true</span><br><span class="line">// 等同于 [2].valueOf().toString() &gt; [1].valueOf().toString()</span><br><span class="line">// 即 &apos;2&apos; &gt; &apos;1&apos;</span><br><span class="line"></span><br><span class="line">[2] &gt; [11] // true</span><br><span class="line">// 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span><br><span class="line">// 即 &apos;2&apos; &gt; &apos;11&apos;</span><br><span class="line"></span><br><span class="line">&#123;x: 2&#125; &gt;= &#123;x: 1&#125; // true</span><br><span class="line">// 等同于 &#123;x: 2&#125;.valueOf().toString() &gt;= &#123;x: 1&#125;.valueOf().toString()</span><br><span class="line">// 即 &apos;[object Object]&apos; &gt;= &apos;[object Object]&apos;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>Date</code> 对象实例用于比较时，是先调用<code>toString</code>方法。如果返回的不是原始类型的值，再接着对返回值调用<code>valueOf</code>方法。</p>
<h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h3><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是<strong>相等运算符（<code>==</code>）比较两个值是否相等</strong>，<strong>严格相等运算符（<code>===</code>）比较它们是否为“同一个值”</strong>。<strong>如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 == &apos;2&apos; // true</span><br><span class="line">2 === &apos;2&apos; // false</span><br></pre></td></tr></table></figure>
<p>严格相等运算符的算法如下。</p>
<h4 id="不同类型的值"><a href="#不同类型的值" class="headerlink" title="不同类型的值"></a>不同类型的值</h4><p>如果两个值的类型不同，直接返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 === &quot;1&quot; // false</span><br><span class="line">true === &quot;true&quot; // false</span><br></pre></td></tr></table></figure>
<p>上面代码比较数值的<code>1</code>与字符串的<code>“1”</code>、布尔值的<code>true</code>与字符串<code>&quot;true&quot;</code>，因为类型不同，结果都是<code>false</code>。</p>
<h4 id="同一类的原始类型值"><a href="#同一类的原始类型值" class="headerlink" title="同一类的原始类型值"></a>同一类的原始类型值</h4><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 === 0x1 // true</span><br></pre></td></tr></table></figure>
<p>上面代码比较十进制的<code>1</code>与十六进制的<code>1</code>，因为类型和值都相同，返回<code>true</code>。</p>
<p>需要注意的是，<strong><code>NaN</code>与任何值都不相等（包括自身）</strong>。另外，<strong>正0等于负0</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN  // false</span><br><span class="line">+0 === -0 // true</span><br></pre></td></tr></table></figure>
<h4 id="复合类型值"><a href="#复合类型值" class="headerlink" title="复合类型值"></a>复合类型值</h4><p><strong>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125; // false</span><br><span class="line">[] === [] // false</span><br><span class="line">(function () &#123;&#125; === function () &#123;&#125;) // false</span><br></pre></td></tr></table></figure>
<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code>。</p>
<p>如果两个变量引用同一个对象，则它们相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v1 = &#123;&#125;;</span><br><span class="line">var v2 = v1;</span><br><span class="line">v1 === v2 // true</span><br></pre></td></tr></table></figure></p>
<p>注意，<strong>对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Date() &gt; new Date() // false</span><br><span class="line">new Date() &lt; new Date() // false</span><br><span class="line">new Date() === new Date() // false</span><br></pre></td></tr></table></figure>
<p>上面的三个表达式，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code>。</p>
<h4 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h4><p><strong><code>undefined</code>和<code>null</code>与自身严格相等。<code>NaN</code>与任何值都不相等（包括自身）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined === undefined // true</span><br><span class="line">null === null // true</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的。</font></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var v1;</span><br><span class="line">var v2;</span><br><span class="line">v1 === v2 // true</span><br></pre></td></tr></table></figure>
<h4 id="严格不相等运算符"><a href="#严格不相等运算符" class="headerlink" title="严格不相等运算符"></a>严格不相等运算符</h4><p><strong>严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 !== &apos;1&apos; // true</span><br></pre></td></tr></table></figure>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p><strong>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样</strong>。</p>
<p><strong>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较</strong>。类型转换规则如下。</p>
<h4 id="原始类型的值-1"><a href="#原始类型的值-1" class="headerlink" title="原始类型的值"></a>原始类型的值</h4><p><strong>原始类型的数据会转换成数值类型再进行比较</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 == true // true</span><br><span class="line">// 等同于 1 === Number(true)</span><br><span class="line"></span><br><span class="line">0 == false // true</span><br><span class="line">// 等同于 0 === Number(false)</span><br><span class="line"></span><br><span class="line">2 == true // false</span><br><span class="line">// 等同于 2 === Number(true)</span><br><span class="line"></span><br><span class="line">2 == false // false</span><br><span class="line">// 等同于 2 === Number(false)</span><br><span class="line"></span><br><span class="line">&apos;true&apos; == true // false</span><br><span class="line">// 等同于 Number(&apos;true&apos;) === Number(true)</span><br><span class="line">// 等同于 NaN === 1</span><br><span class="line"></span><br><span class="line">&apos;&apos; == 0 // true</span><br><span class="line">// 等同于 Number(&apos;&apos;) === 0</span><br><span class="line">// 等同于 0 === 0</span><br><span class="line"></span><br><span class="line">&apos;&apos; == false  // true</span><br><span class="line">// 等同于 Number(&apos;&apos;) === Number(false)</span><br><span class="line">// 等同于 0 === 0</span><br><span class="line"></span><br><span class="line">&apos;1&apos; == true  // true</span><br><span class="line">// 等同于 Number(&apos;1&apos;) === Number(true)</span><br><span class="line">// 等同于 1 === 1</span><br><span class="line"></span><br><span class="line">&apos;\n  123  \t&apos; == 123 // true</span><br><span class="line">// 因为字符串转为数字时，省略前置和后置的空格</span><br></pre></td></tr></table></figure>
<p>上面代码将字符串和布尔值都转为数值，然后再进行比较。具体的字符串与布尔值的类型转换规则，参见《数据类型转换》一章。</p>
<h4 id="对象与原始类型值比较"><a href="#对象与原始类型值比较" class="headerlink" title="对象与原始类型值比较"></a>对象与原始类型值比较</h4><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1] == 1 // true</span><br><span class="line">// 等同于 Number([1]) == 1</span><br><span class="line"></span><br><span class="line">[1] == &apos;1&apos; // true</span><br><span class="line">// 等同于 Number([1]) == Number(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">[1] == true // true</span><br><span class="line">// 等同于 Number([1]) == Number(true)</span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>[1]</code>与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成数值，然后再与字符串进行比较，这时字符串也会转成数值；与布尔值进行比较，两个运算子都会先转成数值，然后再进行比较。</p>
<h4 id="undefined-和-null-1"><a href="#undefined-和-null-1" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h4><p><code>undefined</code>和<code>null</code>与其他类型的值比较时，结果都为<code>false</code>，它们互相比较时结果为<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false == null // false</span><br><span class="line">false == undefined // false</span><br><span class="line"></span><br><span class="line">0 == null // false</span><br><span class="line">0 == undefined // false</span><br><span class="line"></span><br><span class="line">undefined == null // true</span><br></pre></td></tr></table></figure>
<p>绝大多数情况下，对象与<code>undefined</code>和<code>null</code>比较，都返回<code>false</code>。只有在对象转为原始值得到<code>undefined</code>时，才会返回<code>true</code>，这种情况是非常罕见的。</p>
<h4 id="相等运算符的缺点"><a href="#相等运算符的缺点" class="headerlink" title="相等运算符的缺点"></a>相等运算符的缺点</h4><p><strong>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0 == &apos;&apos;             // true</span><br><span class="line">0 == &apos;0&apos;            // true</span><br><span class="line"></span><br><span class="line">2 == true           // false</span><br><span class="line">2 == false          // false</span><br><span class="line"></span><br><span class="line">false == &apos;false&apos;    // false</span><br><span class="line">false == &apos;0&apos;        // true</span><br><span class="line"></span><br><span class="line">false == undefined  // false</span><br><span class="line">false == null       // false</span><br><span class="line">null == undefined   // true</span><br><span class="line"></span><br><span class="line">&apos; \t\r\n &apos; == 0     // true</span><br></pre></td></tr></table></figure>
<p>上面这些表达式都很容易出错，<strong>因此不要使用相等运算符（==），最好只使用严格相等运算符（===）</strong>。</p>
<h4 id="不相等运算符"><a href="#不相等运算符" class="headerlink" title="不相等运算符"></a>不相等运算符</h4><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），两者的运算结果正好相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 != &apos;1&apos; // false</span><br></pre></td></tr></table></figure>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p><strong>布尔运算符用于将表达式转为布尔值</strong>，一共包含四个运算符。</p>
<blockquote>
<p>取反运算符：<code>!</code><br>且运算符：<code>&amp;&amp;</code><br>或运算符：<code>||</code><br>三元运算符：<code>?:</code></p>
</blockquote>
<h3 id="取反运算符（-）"><a href="#取反运算符（-）" class="headerlink" title="取反运算符（!）"></a>取反运算符（!）</h3><p><strong>取反运算符是一个感叹号，用于将布尔值变为相反值</strong>，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!true // false</span><br><span class="line">!false // true</span><br></pre></td></tr></table></figure>
<p><strong>对于非布尔值，取反运算符会将其转为布尔值</strong>。可以这样记忆，<strong>以下六个值取反后为<code>true</code>，其他值都为<code>false</code>。</strong></p>
<blockquote>
<p>undefined<br>null<br>false<br>0<br>NaN<br>空字符串（’’）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!undefined // true</span><br><span class="line">!null // true</span><br><span class="line">!0 // true</span><br><span class="line">!NaN // true</span><br><span class="line">!&quot;&quot; // true</span><br><span class="line"></span><br><span class="line">!54 // false</span><br><span class="line">!&apos;hello&apos; // false</span><br><span class="line">![] // false</span><br><span class="line">!&#123;&#125; // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值。</p>
<p><strong>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。这是一种常用的类型转换的写法</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!!x</span><br><span class="line">// 等同于</span><br><span class="line">Boolean(x)</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值。所以，<strong><font color="red">两次取反就是将一个值转为布尔值的简便写法</font></strong>。</p>
<h3 id="且运算符（-amp-amp-）"><a href="#且运算符（-amp-amp-）" class="headerlink" title="且运算符（&amp;&amp;）"></a>且运算符（&amp;&amp;）</h3><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值。</p>
<p>它的运算规则是：<strong>如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的<font color="red">值（注意是值，不是布尔值）</font>；如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的<font color="red">值</font>，且不再对第二个运算子求值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;t&apos; &amp;&amp; &apos;&apos; // &quot;&quot;</span><br><span class="line">&apos;t&apos; &amp;&amp; &apos;f&apos; // &quot;f&quot;</span><br><span class="line">&apos;t&apos; &amp;&amp; (1 + 2) // 3</span><br><span class="line">&apos;&apos; &amp;&amp; &apos;f&apos; // &quot;&quot;</span><br><span class="line">&apos;&apos; &amp;&amp; &apos;&apos; // &quot;&quot;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">(1 - 1) &amp;&amp; ( x += 1) // 0</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure>
<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量<code>x</code>的值没变。</p>
<p><strong>这种跳过第二个运算子的机制，被称为<font color="red">“短路”</font></strong>。有些程序员喜欢用它取代<code>if</code>结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (i) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"></span><br><span class="line">i &amp;&amp; doSomething();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法是等价的，但是<strong>后一种不容易看出目的，也不容易除错，建议谨慎使用</strong>。</p>
<p><strong>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的<font color="red">值</font>，如果没有布尔值为<code>false</code>的表达式，则返回最后一个表达式的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true &amp;&amp; &apos;foo&apos; &amp;&amp; &apos;&apos; &amp;&amp; 4 &amp;&amp; &apos;foo&apos; &amp;&amp; true</span><br><span class="line">// &apos;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串。</p>
<p>注意，使用且运算符的表达式如果放在if语句的括号内时，if语句会求出整个表达式的最终返回值的布尔值，并依此来决定下一步的操作。</p>
<h3 id="或运算符（-）"><a href="#或运算符（-）" class="headerlink" title="或运算符（||）"></a>或运算符（||）</h3><p>或运算符（<code>||</code>）也<strong>用于多个表达式的求值</strong>。它的运算规则是：<strong>如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;t&apos; || &apos;&apos; // &quot;t&quot;</span><br><span class="line">&apos;t&apos; || &apos;f&apos; // &quot;t&quot;</span><br><span class="line">&apos;&apos; || &apos;f&apos; // &quot;f&quot;</span><br><span class="line">&apos;&apos; || &apos;&apos; // &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>短路规则对这个运算符也适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">true || (x = 2) // true</span><br><span class="line">x // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，且运算符的第一个运算子为<code>true</code>，所以直接返回<code>true</code>，不再运行第二个运算子。所以，<code>x</code>的值没有改变。<strong>这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”</strong>（short-cut）。</p>
<p><strong>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值，如果没有布尔值为<code>true</code>的表达式，则返回最后一个表达式的值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false || 0 || &apos;&apos; || 4 || &apos;foo&apos; || true</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>
<p>上面代码中第一个布尔值为<code>true</code>的表达式是第四个表达式，所以得到数值<code>4</code>。</p>
<p>或运算符常用于为一个变量设置默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function saveText(text) &#123;</span><br><span class="line">  text = text || &apos;&apos;;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者写成</span><br><span class="line">saveText(this.text || &apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。</p>
<h3 id="三元条件运算符（-）"><a href="#三元条件运算符（-）" class="headerlink" title="三元条件运算符（?:）"></a>三元条件运算符（?:）</h3><p>三元条件运算符由问号（<code>?</code>）和冒号（<code>:</code>）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。<strong>如果第一个表达式的布尔值为<code>true</code>，则返回第二个表达式的值，否则返回第三个表达式的值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;t&apos; ? &apos;hello&apos; : &apos;world&apos; // &quot;hello&quot;</span><br><span class="line">0 ? &apos;hello&apos; : &apos;world&apos; // &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>t</code>和<code>0</code>的布尔值分别为<code>true</code>和<code>false</code>，所以分别返回第二个和第三个表达式的值。</p>
<p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<strong>&lt;font color=<br>red”&gt;<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值</strong>。所以，<strong>在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(true ? &apos;T&apos; : &apos;F&apos;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code>if...else</code>语句，就必须改变整个代码写法了。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>位运算符用于直接对二进制位进行计算，一共有7个。</p>
<blockquote>
<p>二进制或运算符（or）：符号为<code>|</code>，表示若两个二进制位都为0，则结果为0，否则为1。<br>二进制与运算符（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。<br>二进制否运算符（not）：符号为<code>~</code>，表示对一个二进制位取反。<br>异或运算符（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。<br>左移运算符（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。<br>右移运算符（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。<br>带符号位的右移运算符（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</p>
</blockquote>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，<strong>好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错</strong>。</p>
<p>有一点需要特别注意，<strong><font color="red">位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行</font></strong>。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是<strong>做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i | 0;</span><br></pre></td></tr></table></figure>
<p>上面这行代码的意思，就是将<code>i</code>（不管是整数或小数）转为32位整数。</p>
<p><strong>利用这个特性，可以写出一个函数，将任意数值转为32位整数</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function toInt32(x) &#123;</span><br><span class="line">  return x | 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个函数将任意值与<code>0</code>进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toInt32(1.001) // 1</span><br><span class="line">toInt32(1.999) // 1</span><br><span class="line">toInt32(1) // 1</span><br><span class="line">toInt32(-1) // -1</span><br><span class="line">toInt32(Math.pow(2, 32) + 1) // 1</span><br><span class="line">toInt32(Math.pow(2, 32) - 1) // -1</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于2的32次方的整数，大于32位的数位都会被舍去。</p>
<p><strong>技巧：<font color="red">可以使用<code>a|0</code>将a（是一个数字，不管是整数或小数）转为32位整数</font></strong>。</p>
<h3 id="二进制或运算符"><a href="#二进制或运算符" class="headerlink" title="二进制或运算符"></a>二进制或运算符</h3><p>二进制或运算符（<code>|</code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 | 3 // 3</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>和<code>3</code>的二进制形式分别是<code>00</code>和<code>11</code>，所以进行二进制或运算会得到11（即3）。</p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。与0进行二进制或运算，则二进制位保持不变，原本为1的二进制位仍然为1，原本为0的二进制位仍然为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.9 | 0 // 2</span><br><span class="line">-2.9 | 0 // -2</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>这种取整方法不适用超过32位整数最大值<code>2147483647</code>的数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2147483649.4 | 0;</span><br><span class="line">// -2147483647</span><br></pre></td></tr></table></figure>
<h3 id="二进制与运算符"><a href="#二进制与运算符" class="headerlink" title="二进制与运算符"></a>二进制与运算符</h3><p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 3 // 0</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>（二进制<code>00</code>）和<code>3</code>（二进制<code>11</code>）进行二进制与运算会得到<code>00</code>（即<code>0</code>）。</p>
<h3 id="二进制否运算符"><a href="#二进制否运算符" class="headerlink" title="二进制否运算符"></a>二进制否运算符</h3><p>二进制否运算符（<code>~</code>）<strong>将每个二进制位都变为相反值（0变为1，1变为0）</strong>。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ 3 // -4</span><br></pre></td></tr></table></figure>
<p>上面表达式对<code>3</code>进行二进制否运算，得到<code>-4</code>。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。</p>
<p>3的32位整数形式是<code>00000000000000000000000000000011</code>，二进制否运算以后得到<code>11111111111111111111111111111100</code>。<strong>由于第一位（符号位）是<code>1</code>，所以这个数是一个负数</strong>。<strong>JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值</strong>。这个数减去1等于<code>11111111111111111111111111111011</code>，再取一次反得到<code>00000000000000000000000000000100</code>，再加上负号就是<code>-4</code>。</p>
<p>考虑到这样的过程比较麻烦，可以简单记忆成，<strong><font color="red">一个数与自身的取反值相加，等于<code>-1</code>。则取反后的结果等于<code>-1</code>减去这个数本身。</font></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ -3 // 2</span><br></pre></td></tr></table></figure>
<p>上面表达式可以这样算，<code>-3</code>的取反值等于<code>-1</code>减去<code>-3</code>，结果为<code>2</code>。</p>
<p>对一个整数连续两次二进制否运算，得到它自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~3 // 3</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">所有的位运算都只对整数有效</font></strong>。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，<strong>对一个小数连续进行两次二进制否运算，能达到取整效果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~~2.9 // 2</span><br><span class="line">~~47.11 // 47</span><br><span class="line">~~1.9999 // 1</span><br><span class="line">~~3 // 3</span><br></pre></td></tr></table></figure>
<p><strong>使用二进制否运算取整，是所有取整方法中<font color="red">最快</font>的一种</strong>。</p>
<p><strong>对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 相当于~Number(&apos;011&apos;)</span><br><span class="line">~&apos;011&apos;  // -12</span><br><span class="line"></span><br><span class="line">// 相当于~Number(&apos;42 cats&apos;)</span><br><span class="line">~&apos;42 cats&apos; // -1</span><br><span class="line"></span><br><span class="line">// 相当于~Number(&apos;0xcafebabe&apos;)</span><br><span class="line">~&apos;0xcafebabe&apos; // 889275713</span><br><span class="line"></span><br><span class="line">// 相当于~Number(&apos;deadbeef&apos;)</span><br><span class="line">~&apos;deadbeef&apos; // -1</span><br></pre></td></tr></table></figure>
<p><code>Number</code>函数将字符串转为数值的规则，参见《数据的类型转换》一章。</p>
<p><strong>对于其他类型的值，二进制否运算也是先用<code>Number</code>转为数值，然后再进行处理</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 ~Number([])</span><br><span class="line">~[] // -1</span><br><span class="line"></span><br><span class="line">// 相当于 ~Number(NaN)</span><br><span class="line">~NaN // -1</span><br><span class="line"></span><br><span class="line">// 相当于 ~Number(null)</span><br><span class="line">~null // -1</span><br></pre></td></tr></table></figure>
<h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>异或运算（<code>^</code>）在<strong>两个二进制位不同时返回<code>1</code>，相同时返回<code>0</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ^ 3 // 3</span><br></pre></td></tr></table></figure>
<p>上面表达式中，<code>0</code>（二进制<code>00</code>）与<code>3</code>（二进制<code>11</code>）进行异或运算，它们每一个二进制位都不同，所以得到<code>11</code>（即<code>3</code>）。</p>
<p>“异或运算”有一个特殊运用，<strong><font color="red">连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值</font></strong>。这意味着，<strong><font color="red">使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值，这是互换两个变量的值的最快方法</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 99;</span><br><span class="line"></span><br><span class="line">a ^= b, b ^= a, a ^= b;</span><br><span class="line"></span><br><span class="line">a // 99</span><br><span class="line">b // 10</span><br><span class="line"></span><br><span class="line">// 或者写为</span><br><span class="line"></span><br><span class="line">a = a^b; // 105</span><br><span class="line">b = a^b; // 10</span><br><span class="line">a = a^b; // 99</span><br><span class="line"></span><br><span class="line">a // 99</span><br><span class="line">b // 10</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">异或运算也可以用来取整</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.9 ^ 0 // 12</span><br></pre></td></tr></table></figure>
<h3 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h3><p><strong>左移运算符（<code>&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（<font color="red">最高位即符号位不参与移动</font>）</strong>。</p>
<p><strong><font color="red">即一个数字a，左移n位，相当于a乘以2的n次方</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 4 的二进制形式为100，</span><br><span class="line">// 左移一位为1000（即十进制的8）</span><br><span class="line">// 相当于乘以2的1次方</span><br><span class="line">4 &lt;&lt; 1</span><br><span class="line">// 8</span><br><span class="line"></span><br><span class="line">-4 &lt;&lt; 1</span><br><span class="line">// -8</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-4</code>左移一位得到<code>-8</code>，是因为<code>-4</code>的二进制形式是<code>11111111111111111111111111111100</code>，左移一位后得到<code>11111111111111111111111111111000</code>，该数转为十进制（减去<code>1</code>后取反，再加上负号）即为<code>-8</code>。</p>
<p><strong><font color="red">如果左移0位</font>，就相当于将该数值转为32位整数，<font color="red">等同于取整</font>，对于正数和负数都有效</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13.5 &lt;&lt; 0</span><br><span class="line">// 13</span><br><span class="line"></span><br><span class="line">-13.5 &lt;&lt; 0</span><br><span class="line">// -13</span><br></pre></td></tr></table></figure>
<p>左移运算符用于二进制数值非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var color = &#123;r: 186, g: 218, b: 85&#125;;</span><br><span class="line"></span><br><span class="line">// RGB to HEX</span><br><span class="line">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span><br><span class="line">var rgb2hex = function(r, g, b) &#123;</span><br><span class="line">  return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b)</span><br><span class="line">    .toString(16) // 先转成十六进制，然后返回字符串</span><br><span class="line">    .substr(1);   // 去除字符串的最高位，返回后面六个字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rgb2hex(color.r, color.g, color.b)</span><br><span class="line">// &quot;#bada55&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码使用左移运算符，<strong>将颜色的 RGB 值转为 HEX 值</strong>。</p>
<h3 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h3><p><strong>右移运算符（<code>&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数，头部补0，即<font color="red">除以2的指定次方</font>（<font color="red">最高位即符号位不参与移动</font>）。</strong></p>
<p><strong><font color="red">即一个数字a，右移n位，相当于a除以2的n次方</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">4 &gt;&gt; 1</span><br><span class="line">// 2</span><br><span class="line">/*</span><br><span class="line">// 因为4的二进制形式为 00000000000000000000000000000100，</span><br><span class="line">// 右移一位得到 00000000000000000000000000000010，</span><br><span class="line">// 即为十进制的2</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-4 &gt;&gt; 1</span><br><span class="line">// -2</span><br><span class="line">/*</span><br><span class="line">// 因为-4的二进制形式为 11111111111111111111111111111100，</span><br><span class="line">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span><br><span class="line">// 即为十进制的-2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>右移运算可以模拟 2 的整除运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">5 &gt;&gt; 1</span><br><span class="line">// 2</span><br><span class="line">// 相当于 5 / 2 = 2</span><br><span class="line"></span><br><span class="line">21 &gt;&gt; 2</span><br><span class="line">// 5</span><br><span class="line">// 相当于 21 / 4 = 5</span><br><span class="line"></span><br><span class="line">21 &gt;&gt; 3</span><br><span class="line">// 2</span><br><span class="line">// 相当于 21 / 8 = 2</span><br><span class="line"></span><br><span class="line">21 &gt;&gt; 4</span><br><span class="line">// 1</span><br><span class="line">// 相当于 21 / 16 = 1</span><br></pre></td></tr></table></figure>
<h3 id="带符号位的右移运算符"><a href="#带符号位的右移运算符" class="headerlink" title="带符号位的右移运算符"></a>带符号位的右移运算符</h3><p><strong>带符号位的右移运算符（<code>&gt;&gt;&gt;</code>）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0</strong>。所以，<strong>该运算总是得到正值</strong>。<strong>对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 &gt;&gt;&gt; 1</span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">-4 &gt;&gt;&gt; 1</span><br><span class="line">// 2147483646</span><br><span class="line">/*</span><br><span class="line">// 因为-4的二进制形式为11111111111111111111111111111100，</span><br><span class="line">// 带符号位的右移一位，得到01111111111111111111111111111110，</span><br><span class="line">// 即为十进制的2147483646。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>这个运算<strong>实际上将一个值转为32位无符号整数</strong>。</p>
<p><strong>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符，进行右移<code>0</code>的运算</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 &gt;&gt;&gt; 0 // 4294967295</span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 <code>4294967295</code>（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）。</p>
<h3 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h3><p><strong>位运算符可以用作设置对象属性的开关</strong>。</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var FLAG_A = 1; // 0001</span><br><span class="line">var FLAG_B = 2; // 0010</span><br><span class="line">var FLAG_C = 4; // 0100</span><br><span class="line">var FLAG_D = 8; // 1000</span><br></pre></td></tr></table></figure>
<p>上面代码设置 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 四个开关，每个开关分别占有一个二进制位。</p>
<p>然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var flags = 5; // 二进制的0101</span><br><span class="line"></span><br><span class="line">if (flags &amp; FLAG_C) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span><br></pre></td></tr></table></figure>
<p>上面代码检验是否打开了开关<code>C</code>。如果打开，会返回<code>true</code>，否则返回<code>false</code>。</p>
<p>现在假设需要打开<code>A</code>、<code>B</code>、<code>D</code>三个开关，我们可以构造一个掩码变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mask = FLAG_A | FLAG_B | FLAG_D;</span><br><span class="line">// 0001 | 0010 | 1000 =&gt; 1011</span><br></pre></td></tr></table></figure>
<p>上面代码对<code>A</code>、<code>B</code>、<code>D</code>三个变量进行二进制或运算，得到掩码值为二进制的<code>1011</code>。</p>
<p>有了掩码，二进制或运算可以确保打开指定的开关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags | mask;</span><br></pre></td></tr></table></figure>
<p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; mask;</span><br></pre></td></tr></table></figure>
<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags ^ mask;</span><br></pre></td></tr></table></figure>
<p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = ~flags;</span><br></pre></td></tr></table></figure>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h3><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void 0 // undefined</span><br><span class="line">void(0) // undefined</span><br></pre></td></tr></table></figure>
<p>上面是<code>void</code>运算符的两种写法，都正确。<strong>建议采用后一种形式，即总是使用圆括号。因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果</strong>。比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code>。</p>
<p>下面是void运算符的一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = 3;</span><br><span class="line">void (x = 5) //undefined</span><br><span class="line">x // 5</span><br></pre></td></tr></table></figure></p>
<p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>
<p>请看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(&apos;Hello World&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com&quot; onclick=&quot;f(); return false;&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 <code>example.com</code>。</p>
<p>void运算符可以取代上面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: void(f())&quot;&gt;文字&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: void(document.form.submit())&quot;&gt;</span><br><span class="line">  提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p><strong>逗号运算符用于对两个表达式求值，并<font color="red">返回后一个表达式的值</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos;, &apos;b&apos; // &quot;b&quot;</span><br><span class="line"></span><br><span class="line">var x = 0;</span><br><span class="line">var y = (x++, 10);</span><br><span class="line">x // 1</span><br><span class="line">y // 10</span><br></pre></td></tr></table></figure>
<h2 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>JavaScript 各种运算符的优先级别（Operator Precedence）是不一样的。<strong>优先级高的运算符先执行，优先级低的运算符后执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 + 5 * 6 // 34</span><br></pre></td></tr></table></figure>
<p>上面的代码中，乘法运算符（<code>*</code>）的优先性高于加法运算符（<code>+</code>），所以先执行乘法，再执行加法，相当于下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 + (5 * 6) // 34</span><br></pre></td></tr></table></figure></p>
<p>如果多个运算符混写在一起，常常会导致令人困惑的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line">var y = arr.length &lt;= 0 || arr[0] === undefined ? x : arr[0];</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>y</code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住。</p>
<p>根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）。因此上面的表达式，实际的运算顺序如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var y = ((arr.length &lt;= 0) || (arr[0] === undefined)) ? x : arr[0];</span><br></pre></td></tr></table></figure></p>
<p><strong>记住所有运算符的优先级，是非常难的，也是没有必要的。</strong></p>
<h3 id="圆括号的作用"><a href="#圆括号的作用" class="headerlink" title="圆括号的作用"></a>圆括号的作用</h3><p><strong>圆括号（<code>()</code>）可以用来提高运算的优先级，因为它的优先级是最高的</strong>，即圆括号中的表达式会第一个运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4 + 5) * 6 // 54</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于使用了圆括号，加法会先于乘法执行。</p>
<p>运算符的优先级别十分繁杂，且都是硬性规定，因此<strong>建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要</strong>。</p>
<p>顺便说一下，<strong>圆括号不是运算符，而是一种语法结构</strong>。它一共有两种用法：<strong>一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数</strong>。</p>
<p>注意，<strong>因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">(x) = 2;</span><br></pre></td></tr></table></figure>
<p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。</p>
<p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(exprssion)</span><br><span class="line">// 等同于</span><br><span class="line">expression</span><br></pre></td></tr></table></figure>
<p><strong>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(f) // function f()&#123;return 1;&#125;</span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。</p>
<p><strong><font color="red">圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错</font></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(var a = 1)</span><br><span class="line">// SyntaxError: Unexpected token var</span><br></pre></td></tr></table></figure>
<h3 id="左结合与右结合"><a href="#左结合与右结合" class="headerlink" title="左结合与右结合"></a>左结合与右结合</h3><p><strong>对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x + y + z</span><br></pre></td></tr></table></figure>
<p>上面代码先计算最左边的<code>x</code>与<code>y</code>的和，然后再计算与<code>z</code>的和。</p>
<p>但是<strong>少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”</strong>（right-to-left associativity）。其中，<strong>最主要的是赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = x = y = z;</span><br><span class="line">q = a ? b : c ? d : e ? f : g;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的运算结果，相当于下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = (x = (y = z));</span><br><span class="line">q = a ? b : (c ? d : (e ? f : g));</span><br></pre></td></tr></table></figure></p>
<p>上面的两行代码，各有三个等号运算符和三个三元运算符，都是先计算最右边的那个运算符。</p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>JavaScript 是一种<strong>动态类型语言</strong>，变量没有类型限制，可以随时赋予任意值。</p>
<p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>使用Number函数，可以将任意类型的值转化成数值。</p>
<p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。</p>
<h4 id="原始类型值"><a href="#原始类型值" class="headerlink" title="原始类型值"></a>原始类型值</h4><p>原始类型值的转换规则如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 数值：转换后还是原来的值</span><br><span class="line">Number(324) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="line">Number(&apos;324&apos;) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="line">Number(&apos;324abc&apos;) // NaN</span><br><span class="line"></span><br><span class="line">// 空字符串转为0</span><br><span class="line">Number(&apos;&apos;) // 0</span><br><span class="line"></span><br><span class="line">// 布尔值：true 转成 1，false 转成 0</span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(false) // 0</span><br><span class="line"></span><br><span class="line">// undefined：转成 NaN</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line"></span><br><span class="line">// null：转成0</span><br><span class="line">Number(null) // 0</span><br><span class="line"></span><br><span class="line">Number(NaN) // NaN</span><br></pre></td></tr></table></figure>
<p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;42 cats&apos;) // 42</span><br><span class="line">Number(&apos;42 cats&apos;) // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。</p>
<p>另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;\t\v\r12.34\n&apos;) // 12</span><br><span class="line">Number(&apos;\t\v\r12.34\n&apos;) // 12.34</span><br></pre></td></tr></table></figure>
<h4 id="对象-2"><a href="#对象-2" class="headerlink" title="对象"></a>对象</h4><p>简单的规则是，Number方法的参数是对象时，将返回NaN，除非是包含<strong>单个数值</strong>的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(&#123;a: 1&#125;) // NaN</span><br><span class="line">Number([1, 2, 3]) // NaN</span><br><span class="line">Number([5]) // 5</span><br><span class="line">Number([]) // 0，因为toString方法转化为&quot;&quot;，即空字符串</span><br></pre></td></tr></table></figure>
<p>之所以会这样，是因为Number背后的转换规则比较复杂。</p>
<ol>
<li><p>调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</p>
</li>
<li><p>如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p>
</li>
<li><p>如果toString方法返回的是对象，就报错。</p>
</li>
</ol>
<p>请看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;x: 1&#125;;</span><br><span class="line">Number(obj) // NaN</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">if (typeof obj.valueOf() === &apos;object&apos;) &#123;</span><br><span class="line">  Number(obj.toString());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Number(obj.valueOf());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用Number函数，得到NaN。</p>
<p>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(&#123;&#125;) // NaN</span><br></pre></td></tr></table></figure>
<p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number(obj)</span><br><span class="line">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错。</p>
<p>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Number(&#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 2</span><br><span class="line"></span><br><span class="line">Number(&#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">Number(&#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p><code>String</code>函数可以将<strong>任意类型</strong>的值转化成字符串，转换规则如下。</p>
<h4 id="原始类型值-1"><a href="#原始类型值-1" class="headerlink" title="原始类型值"></a>原始类型值</h4><blockquote>
<p>数值：转为相应的字符串。<br>字符串：转换后还是原来的值。<br>布尔值：true转为字符串”true”，false转为字符串”false”。<br>undefined：转为字符串”undefined”。<br>null：转为字符串”null”。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(123) // &quot;123&quot;</span><br><span class="line">String(&apos;abc&apos;) // &quot;abc&quot;</span><br><span class="line">String(true) // &quot;true&quot;</span><br><span class="line">String(undefined) // &quot;undefined&quot;</span><br><span class="line">String(null) // &quot;null&quot;</span><br></pre></td></tr></table></figure>
<h4 id="对象-3"><a href="#对象-3" class="headerlink" title="对象"></a>对象</h4><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;a: 1&#125;) // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2, 3]) // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure>
<p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。</p>
<ol>
<li><p>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</p>
</li>
<li><p>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</p>
</li>
<li><p>如果<code>valueOf</code>方法返回的是对象，就报错。</p>
</li>
</ol>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;a: 1&#125;)</span><br><span class="line">// &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">String(&#123;a: 1&#125;.toString())</span><br><span class="line">// &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了。</p>
<p>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String(obj)</span><br><span class="line">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>
<p>下面是通过自定义toString方法，改变返回值的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String(&#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// &quot;3&quot;</span><br><span class="line"></span><br><span class="line">String(&#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">String(&#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// &quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值3），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p>Boolean函数可以将任意类型的值转为布尔值。</p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<blockquote>
<p>undefined<br>null<br>-0或+0<br>NaN<br>‘’（空字符串）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line">Boolean(&apos;&apos;) // false</span><br></pre></td></tr></table></figure>
<p>注意，所有对象（包括空对象）的转换结果都是true，甚至连<strong><code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code></strong>（详见《原始类型值的包装对象》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(new Boolean(false)) // true</span><br></pre></td></tr></table></figure>
<p>所有对象的布尔值都是<code>true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为<code>true</code>。</p>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>下面介绍自动转换，它是以强制转换为基础的。</p>
<p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p>
<p>第一种情况，<strong>不同类型的数据互相运算。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;abc&apos; // &quot;123abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>第二种情况，<strong>对非布尔值类型的数据求布尔值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;abc&apos;) &#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;  // &quot;hello&quot;</span><br></pre></td></tr></table></figure></p>
<p>第三种情况，<strong>对非数值类型的值使用一元运算符（即+和-）。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ &#123;foo: &apos;bar&apos;&#125; // NaN</span><br><span class="line">- [1, 2, 3] // NaN</span><br></pre></td></tr></table></figure></p>
<p>自动转换的规则是这样的：<strong>预期什么类型的值，就调用该类型的转换函数</strong>。比如，某个位置预期为字符串，就调用String函数进行转换。<strong>如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</strong></p>
<p>由于自动转换具有不确定性，而且不易除错，<strong>建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</strong></p>
<h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p>JavaScript 遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean</code>函数。</p>
<p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是Boolean函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">expression ? true : false</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">!! expression</span><br></pre></td></tr></table></figure>
<h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</p>
<p>字符串的自动转换，主要发生在字符串的加法运算时。<strong>当一个值为字符串，另一个值为非字符串，则后者转为字符串。 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;5&apos; + 1 // &apos;51&apos;</span><br><span class="line">&apos;5&apos; + true // &quot;5true&quot;</span><br><span class="line">&apos;5&apos; + false // &quot;5false&quot;</span><br><span class="line">&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot;</span><br><span class="line">&apos;5&apos; + [] // &quot;5&quot;</span><br><span class="line">&apos;5&apos; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;</span><br><span class="line">&apos;5&apos; + undefined // &quot;5undefined&quot;</span><br><span class="line">&apos;5&apos; + null // &quot;5null&quot;</span><br></pre></td></tr></table></figure>
<p>这种自动转换很容易出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  width: &apos;100&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.width + 20 // &quot;10020&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，开发者可能期望返回120，但是由于自动转换，实际上返回了一个字符10020。</p>
<h3 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h3><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number</code>函数。</p>
<p><strong>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</strong></p>
<p>下面是几个特殊例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true - 1  // 0</span><br><span class="line">false - 1 // -1</span><br><span class="line">&apos;abc&apos; - 1   // NaN</span><br><span class="line">&apos;5&apos; * []    // 0</span><br><span class="line">false / &apos;5&apos; // 0，可以计算0除以几，只不过都等于0</span><br><span class="line">null + 1 // 1</span><br><span class="line">undefined + 1 // NaN</span><br></pre></td></tr></table></figure>
<p>上面代码中，运算符两侧的运算子，都被转成了数值。</p>
<p>注意：<strong><code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。</strong></p>
<p>一元运算符也会把运算子转成数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+&apos;abc&apos; // NaN</span><br><span class="line">-&apos;abc&apos; // NaN</span><br><span class="line">+true // 1</span><br><span class="line">-false // 0</span><br></pre></td></tr></table></figure>
<h1 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h1><h2 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var err = new Error(&apos;出错了&apos;);</span><br><span class="line">err.message // &quot;出错了&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>
<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>
<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (error.name) &#123;</span><br><span class="line">  console.log(error.name + &apos;: &apos; + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack属性用来查看错误发生时的堆栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function throwit() &#123;</span><br><span class="line">  throw new Error(&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function catchit() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throwit();</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(e.stack); // print stack trace</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catchit()</span><br><span class="line">// Error</span><br><span class="line">//    at throwit (~/examples/throwcatch.js:9:11)</span><br><span class="line">//    at catchit (~/examples/throwcatch.js:3:9)</span><br><span class="line">//    at repl:1:5</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>
<h2 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。</p>
<h3 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是<strong>解析代码时发生的语法错误</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 变量名错误</span><br><span class="line">var 1a;</span><br><span class="line">// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line"></span><br><span class="line">// 缺少括号</span><br><span class="line">console.log &apos;hello&apos;);</span><br><span class="line">// Uncaught SyntaxError: Unexpected string</span><br></pre></td></tr></table></figure>
<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>
<h3 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是<strong>引用一个不存在的变量</strong>时发生的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用一个不存在的变量</span><br><span class="line">unknownVariable</span><br><span class="line">// Uncaught ReferenceError: unknownVariable is not defined</span><br></pre></td></tr></table></figure>
<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 等号左侧不是变量</span><br><span class="line">console.log() = 1</span><br><span class="line">// Uncaught ReferenceError: Invalid left-hand side in assignment</span><br><span class="line"></span><br><span class="line">// this 对象不能手动赋值</span><br><span class="line">this = 1</span><br><span class="line">// ReferenceError: Invalid left-hand side in assignment</span><br></pre></td></tr></table></figure>
<h3 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个<strong>值超出有效范围</strong>时发生的错误。</p>
<p>主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 数组长度不得为负数</span><br><span class="line">new Array(-1)</span><br><span class="line">// Uncaught RangeError: Invalid array length</span><br></pre></td></tr></table></figure></p>
<h3 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h3><p><code>TypeError</code>对象是<strong>变量或参数不是预期类型</strong>，或者<strong>调用了不存在的方法</strong>时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new 123</span><br><span class="line">// Uncaught TypeError: number is not a func</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></pre></td></tr></table></figure>
<h3 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h3><p><code>URIError</code>对象是URI相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decodeURI(&apos;%2&apos;)</span><br><span class="line">// URIError: URI malformed</span><br></pre></td></tr></table></figure>
<h3 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。<br><code>eval</code>是求值函数，实际上用的并不多。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var err1 = new Error(&apos;出错了！&apos;);</span><br><span class="line">var err2 = new RangeError(&apos;出错了，变量超出有效范围！&apos;);</span><br><span class="line">var err3 = new TypeError(&apos;出错了，变量类型无效！&apos;);</span><br><span class="line"></span><br><span class="line">err1.message // &quot;出错了！&quot;</span><br><span class="line">err2.message // &quot;出错了，变量超出有效范围！&quot;</span><br><span class="line">err3.message // &quot;出错了，变量类型无效！&quot;</span><br></pre></td></tr></table></figure>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function UserError(message) &#123;</span><br><span class="line">  this.message = message || &apos;默认信息&apos;;</span><br><span class="line">  this.name = &apos;UserError&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = new Error();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>
<p>上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new UserError(&apos;这是自定义的错误！&apos;);</span><br></pre></td></tr></table></figure>
<p>对上例中的prototype进行简短的解释，<strong>prototype 属性使用户有能力向对象添加属性和方法</strong>，语法为<code>object.prototype.name=value</code>。<br>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function employee(name,job,born)</span><br><span class="line">&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.job=job;</span><br><span class="line">  this.born=born;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);</span><br><span class="line"></span><br><span class="line">employee.prototype.salary=null;</span><br><span class="line">bill.salary=20000;</span><br><span class="line">document.write(bill.salary);</span><br><span class="line"></span><br><span class="line">// 20000</span><br></pre></td></tr></table></figure>
<p>对于上例中的constructor，<strong>constructor 属性返回对创建此对象的数组函数的引用</strong>，语法<code>object.constructor</code>。<br>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var test=new Array();</span><br><span class="line"></span><br><span class="line">if (test.constructor==Array)</span><br><span class="line">&#123;</span><br><span class="line">  document.write(&quot;This is an Array&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (test.constructor==Boolean)</span><br><span class="line">&#123;</span><br><span class="line">  document.write(&quot;This is a Boolean&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (test.constructor==Date)</span><br><span class="line">&#123;</span><br><span class="line">  document.write(&quot;This is a Date&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (test.constructor==String)</span><br><span class="line">&#123;</span><br><span class="line">  document.write(&quot;This is a String&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用constructor属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function employee(name,job,born)</span><br><span class="line">&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.job=job;</span><br><span class="line">  this.born=born;</span><br><span class="line">&#125;</span><br><span class="line">var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);</span><br><span class="line">document.write(bill.constructor);</span><br><span class="line"></span><br><span class="line">// function employee(name, job, born)</span><br><span class="line">// &#123;this.name = name; this.job = job; this.born = born;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt; 0) &#123;</span><br><span class="line">  throw new Error(&apos;x 必须为正数&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果变量<code>x</code>小于0，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>
<p>throw也可以抛出自定义错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function UserError(message) &#123;</span><br><span class="line">  this.message = message || &apos;默认信息&apos;;</span><br><span class="line">  this.name = &apos;UserError&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw new UserError(&apos;出错了！&apos;);</span><br><span class="line">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p>实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 抛出一个字符串</span><br><span class="line">throw &apos;Error！&apos;;</span><br><span class="line">// Uncaught Error！</span><br><span class="line"></span><br><span class="line">// 抛出一个数值</span><br><span class="line">throw 42;</span><br><span class="line">// Uncaught 42</span><br><span class="line"></span><br><span class="line">// 抛出一个布尔值</span><br><span class="line">throw true;</span><br><span class="line">// Uncaught true</span><br><span class="line"></span><br><span class="line">// 抛出一个对象</span><br><span class="line">throw &#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &apos;Error!&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Uncaught &#123;toString: ƒ&#125;</span><br></pre></td></tr></table></figure>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<h2 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了。JavaScript提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw new Error(&apos;出错了!&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e.name + &quot;: &quot; + e.message);</span><br><span class="line">  console.log(e.stack);</span><br><span class="line">&#125;</span><br><span class="line">// Error: 出错了!</span><br><span class="line">//   at &lt;anonymous&gt;:3:9</span><br><span class="line">//   ...</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try…catch</code>代码块之中，便于进一步对错误进行处理。</p>
<p><code>catch</code>代码块捕获错误之后，<strong>程序不会中断，会按照正常流程继续执行下去</strong>，可以避免程序崩溃。</p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var n = 100;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  throw n;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  if (e &lt;= 50) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Uncaught 100</span><br></pre></td></tr></table></figure>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  if (e instanceof EvalError) &#123;</span><br><span class="line">    console.log(e.name + &quot;: &quot; + e.message);</span><br><span class="line">  &#125; else if (e instanceof RangeError) &#123;</span><br><span class="line">    console.log(e.name + &quot;: &quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function cleansUp() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&apos;出错了……&apos;);</span><br><span class="line">    console.log(&apos;此行不会执行&apos;);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(&apos;完成清理工作&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleansUp()</span><br><span class="line">// 完成清理工作</span><br><span class="line">// Error: 出错了……</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于没有catch语句块，所以错误没有捕获。执行finally代码块以后，程序就中断在错误抛出的地方，注意是<strong>执行完finally代码块以后</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function idle(x) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">    return &apos;result&apos;;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(&quot;FINALLY&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idle(&apos;hello&apos;)</span><br><span class="line">// hello</span><br><span class="line">// FINALLY</span><br><span class="line">// &quot;result&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。注意，只有<strong>在<code>finally</code>块执行完毕后，才会显示<code>return</code>语句的值</strong>。</p>
<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">function countUp() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return count;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countUp()</span><br><span class="line">// 0</span><br><span class="line">count</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>return</code>语句的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>
<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(0);</span><br><span class="line">    throw &apos;bug&apos;;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return true; // 这句原本会延迟到 finally 代码块结束再执行</span><br><span class="line">    console.log(2); // 不会运行</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    return false; // 这句会覆盖掉前面那句 return</span><br><span class="line">    console.log(4); // 不会运行</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(5); // 不会运行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = f();</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>
<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码快的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>
<h1 id="JavaScript-编程风格"><a href="#JavaScript-编程风格" class="headerlink" title="JavaScript 编程风格"></a>JavaScript 编程风格</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><p>“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。</p>
<p>有人说，编译器的规范叫做”语法规则“（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫”编程风格“（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。</p>
<p>所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。</p>
<p>必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</p>
<p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。</p>
<p>无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。</p>
<h2 id="区块-1"><a href="#区块-1" class="headerlink" title="区块"></a>区块</h2><p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a)</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure>
<p>上面代码的原意可能是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (a) &#123;</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，实际效果却是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (a) &#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure>
<p>因此，<strong>建议总是使用大括号表示区块</strong>。</p>
<p>另外，区块起首的大括号的位置，有许多不同的写法。<strong>最流行的有两种，一种是起首的大括号另起一行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种是起首的大括号跟在关键字的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，这两种写法都可以接受。但是，<strong>JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">&#123;</span><br><span class="line">  key: value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">return;</span><br><span class="line">&#123;</span><br><span class="line">  key: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">  key : value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，<strong><font color="red">表示区块起首的大括号，不要另起一行</font></strong>。</p>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）用于提高表达式的优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 圆括号表示函数的调用</span><br><span class="line">console.log(&apos;abc&apos;);</span><br><span class="line"></span><br><span class="line">// 圆括号表示表达式的组合</span><br><span class="line">(1 + 2) * 3</span><br></pre></td></tr></table></figure>
<p>建议<strong>可以用空格，区分这两种不同的括号</strong>。</p>
<blockquote>
<p>表示函数调用时，函数名与左括号之间没有空格。</p>
</blockquote>
<blockquote>
<p>表示函数定义时，函数名与左括号之间没有空格。</p>
</blockquote>
<blockquote>
<p>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</p>
</blockquote>
<p>但是要注意创建一个匿名函数的时候，<code>function</code>和<code>()</code>之间应该有一个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (x) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。</p>
<h2 id="行尾的分号"><a href="#行尾的分号" class="headerlink" title="行尾的分号"></a>行尾的分号</h2><p>分号表示一条语句的结束。<strong>JavaScript 允许省略行尾的分号</strong>。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，<strong>建议还是不要省略这个分号</strong>。</p>
<h3 id="不使用分号的情况"><a href="#不使用分号的情况" class="headerlink" title="不使用分号的情况"></a>不使用分号的情况</h3><p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号。</p>
<h4 id="for-和-while-循环"><a href="#for-和-while-循环" class="headerlink" title="for 和 while 循环"></a>for 和 while 循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; ) &#123;</span><br><span class="line">&#125; // 没有分号</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">&#125; // 没有分号</span><br></pre></td></tr></table></figure>
<p>注意，<strong><code>do...while</code>循环是有分号的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  a--;</span><br><span class="line">&#125; while(a &gt; 0); // 分号不能省略</span><br></pre></td></tr></table></figure>
<h4 id="分支语句：if，switch，try"><a href="#分支语句：if，switch，try" class="headerlink" title="分支语句：if，switch，try"></a>分支语句：if，switch，try</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">&#125; // 没有分号</span><br><span class="line"></span><br><span class="line">switch () &#123;</span><br><span class="line">&#125; // 没有分号</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">&#125; // 没有分号</span><br></pre></td></tr></table></figure>
<h4 id="函数的声明语句"><a href="#函数的声明语句" class="headerlink" title="函数的声明语句"></a>函数的声明语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">&#125; // 没有分号</span><br></pre></td></tr></table></figure>
<p>注意，<strong>函数表达式仍然要使用分号。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = function f() &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上三种情况，<strong>如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句</strong>。</p>
<h3 id="分号的自动添加"><a href="#分号的自动添加" class="headerlink" title="分号的自动添加"></a>分号的自动添加</h3><p>除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">// 等同于</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>
<p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。</p>
<p>因此，有人提倡省略句尾的分号。麻烦的是，<strong>如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 var a = 3</span><br><span class="line">var</span><br><span class="line">a</span><br><span class="line">=</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">// 等同于 &apos;abc&apos;.length</span><br><span class="line">&apos;abc&apos;</span><br><span class="line">.length</span><br><span class="line"></span><br><span class="line">// 等同于 return a + b;</span><br><span class="line">return a +</span><br><span class="line">b;</span><br><span class="line"></span><br><span class="line">// 等同于 obj.foo(arg1, arg2);</span><br><span class="line">obj.foo(arg1,</span><br><span class="line">arg2);</span><br><span class="line"></span><br><span class="line">// 等同于 3 * 2 + 10 * (27 / 6)</span><br><span class="line">3 * 2</span><br><span class="line">+</span><br><span class="line">10 * (27 / 6)</span><br></pre></td></tr></table></figure>
<p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">(function () &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">x = y(function () &#123;...&#125;)();</span><br></pre></td></tr></table></figure>
<p>下面是更多不会自动添加分号的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 引擎解释为 c(d+e)</span><br><span class="line">var a = b + c</span><br><span class="line">(d+e).toString();</span><br><span class="line"></span><br><span class="line">// 引擎解释为 a = b/hi/g.exec(c).map(d)</span><br><span class="line">// 正则表达式的斜杠，会当作除法运算符</span><br><span class="line">a = b</span><br><span class="line">/hi/g.exec(c).map(d);</span><br><span class="line"></span><br><span class="line">// 解释为&apos;b&apos;[&apos;red&apos;, &apos;green&apos;]，</span><br><span class="line">// 即把字符串当作一个数组，按索引取值</span><br><span class="line">var a = &apos;b&apos;</span><br><span class="line">[&apos;red&apos;, &apos;green&apos;].forEach(function (c) &#123;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 解释为 function (x) &#123; return x &#125;(a++)</span><br><span class="line">// 即调用匿名函数，结果f等于0</span><br><span class="line">var a = 0;</span><br><span class="line">var f = function (x) &#123; return x &#125;</span><br><span class="line">(a++)</span><br></pre></td></tr></table></figure></p>
<p>只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (a &lt; 0) a = 0</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line">// 等同于下面的代码，</span><br><span class="line">// 因为 0console 没有意义</span><br><span class="line">if (a &lt; 0) a = 0;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
<p>另外，<strong>如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = 1</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br><span class="line">--</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">console.log(a, b, c)</span><br><span class="line">// 1 2 0</span><br></pre></td></tr></table></figure>
<p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = 1;</span><br><span class="line">a;</span><br><span class="line">++b;</span><br><span class="line">--c;</span><br></pre></td></tr></table></figure>
<p><strong>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号</strong>。这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">&#123; first: &apos;Jane&apos; &#125;;</span><br><span class="line"></span><br><span class="line">// 解释成</span><br><span class="line">return;</span><br><span class="line">&#123; first: &apos;Jane&apos; &#125;;</span><br></pre></td></tr></table></figure>
<p>由于解释引擎自动添加分号的行为难以预测，因此<strong>编写代码的时候不应该省略行尾的分号</strong>。</p>
<p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p>
<p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;var a = 1;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>
<p>因此，<strong>建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量</strong>，比如UPPER_CASE。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>JavaScript 会自动将变量声明”提升“（hoist）到代码块（block）的头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!x) &#123;</span><br><span class="line">  var x = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var x;</span><br><span class="line">if (!x) &#123;</span><br><span class="line">  x = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，变量<code>x</code>是<code>if</code>代码块之前就存在了。为了避免可能出现的问题，<strong>最好把变量声明都放在代码块的头部。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写成</span><br><span class="line">var i;</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这样的写法，就容易看出存在一个全局的循环变量<code>i</code>。</p>
<p>另外，<strong>所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部</strong>。</p>
<h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p><code>with</code>可以减少代码的书写，但是会造成混淆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (o) &#123;</span><br><span class="line">　foo = bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，可以有四种运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o.foo = bar;</span><br><span class="line">o.foo = o.bar;</span><br><span class="line">foo = bar;</span><br><span class="line">foo = o.bar;</span><br></pre></td></tr></table></figure>
<p>这四种结果都可能发生，取决于不同的变量是否有定义。因此，<strong>不要使用<code>with</code>语句</strong>。</p>
<h2 id="相等和严格相等"><a href="#相等和严格相等" class="headerlink" title="相等和严格相等"></a>相等和严格相等</h2><p>JavaScript 有两个表示相等的运算符：”相等“（<code>==</code>）和”严格相等“（<code>===</code>）。</p>
<p>相等运算符会自动转换变量类型，造成很多意想不到的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 == &apos;&apos;// true</span><br><span class="line">1 == true // true</span><br><span class="line">2 == true // false</span><br><span class="line">0 == &apos;0&apos; // true</span><br><span class="line">false == &apos;false&apos; // false</span><br><span class="line">false == &apos;0&apos; // true</span><br><span class="line">&apos; \t\r\n &apos; == 0 // true</span><br></pre></td></tr></table></figure>
<p>因此，<strong>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）</strong>。</p>
<h2 id="语句的合并"><a href="#语句的合并" class="headerlink" title="语句的合并"></a>语句的合并</h2><p>有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br><span class="line">if (a) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他喜欢写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a = b) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码是将<code>a = b</code>这个赋值语句放在了<code>if</code>这个判断语句中。</p>
<p>虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if （a === b）&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议不要将不同目的的语句，合并成一行。</p>
<h2 id="自增和自减运算符-1"><a href="#自增和自减运算符-1" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>自增（<code>++</code>）和自减（<code>--</code>）运算符，<strong>放在变量的前面或后面，返回的值不一样</strong>，很容易发生错误。事实上，所有的<code>++</code>运算符都可以用<code>+= 1</code>代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++x</span><br><span class="line">// 等同于</span><br><span class="line">x += 1;</span><br></pre></td></tr></table></figure>
<p>改用<code>+= 1</code>，代码变得更清晰了。</p>
<p><strong>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替</strong>。</p>
<h2 id="switch…case-结构"><a href="#switch…case-结构" class="headerlink" title="switch…case 结构"></a>switch…case 结构</h2><p><code>switch...case</code>结构要求，在每一个<code>case</code>的最后一行必须是<code>break</code>语句，否则会接着运行下一个<code>case</code>。这样不仅容易忘记，还会造成代码的冗长。</p>
<p>而且，<code>switch...case</code>不使用大括号，不利于代码形式的统一。此外，这种结构类似于<code>goto</code>语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function doAction(action) &#123;</span><br><span class="line">  switch (action) &#123;</span><br><span class="line">    case &apos;hack&apos;:</span><br><span class="line">      return &apos;hack&apos;;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;slash&apos;:</span><br><span class="line">      return &apos;slash&apos;;</span><br><span class="line">      break;</span><br><span class="line">    case &apos;run&apos;:</span><br><span class="line">      return &apos;run&apos;;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(&apos;Invalid action.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码建议改写成对象结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function doAction(action) &#123;</span><br><span class="line">  var actions = &#123;</span><br><span class="line">    &apos;hack&apos;: function () &#123;</span><br><span class="line">      return &apos;hack&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;slash&apos;: function () &#123;</span><br><span class="line">      return &apos;slash&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;run&apos;: function () &#123;</span><br><span class="line">      return &apos;run&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (typeof actions[action] !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;Invalid action.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中最后返回的<code>actions[action]</code>如果不加<code>()</code>则是一个函数，加了<code>()</code>代表调用返回的函数。</p>
<p>因此，<strong>建议<code>switch...case</code>结构可以用对象结构代替</strong>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/20/Sublime使用技巧/" rel="next" title="Sublime使用技巧">
                <i class="fa fa-chevron-left"></i> Sublime使用技巧
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/09/前端小知识点整理/" rel="prev" title="前端小知识点整理">
                前端小知识点整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="hypercomments_widget"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Fnine59" />
            
              <p class="site-author-name" itemprop="name">Fnine59</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Fnine59" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5746592281?refer_flag=1005055010_" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fnine59@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本语法"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语句"><span class="nav-number">1.1.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量提升"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量提升</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符"><span class="nav-number">1.3.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释"><span class="nav-number">1.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区块"><span class="nav-number">1.5.</span> <span class="nav-text">区块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件语句"><span class="nav-number">1.6.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if结构"><span class="nav-number">1.6.1.</span> <span class="nav-text">if结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if…else-结构"><span class="nav-number">1.6.2.</span> <span class="nav-text">if…else 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch结构"><span class="nav-number">1.6.3.</span> <span class="nav-text">switch结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元运算符"><span class="nav-number">1.6.4.</span> <span class="nav-text">三元运算符 ?:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环语句"><span class="nav-number">1.7.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while-循环"><span class="nav-number">1.7.1.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-循环"><span class="nav-number">1.7.2.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do…while-循环"><span class="nav-number">1.7.3.</span> <span class="nav-text">do…while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-语句和-continue-语句"><span class="nav-number">1.7.4.</span> <span class="nav-text">break 语句和 continue 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标签（label）"><span class="nav-number">1.7.5.</span> <span class="nav-text">标签（label）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-运算符"><span class="nav-number">2.2.</span> <span class="nav-text">typeof 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-和-undefined"><span class="nav-number">2.3.</span> <span class="nav-text">null 和 undefined</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法和含义"><span class="nav-number">2.3.2.</span> <span class="nav-text">用法和含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔值"><span class="nav-number">2.4.</span> <span class="nav-text">布尔值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数值"><span class="nav-number">3.</span> <span class="nav-text">数值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整数和浮点数"><span class="nav-number">3.1.1.</span> <span class="nav-text">整数和浮点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值精度"><span class="nav-number">3.1.2.</span> <span class="nav-text">数值精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值范围"><span class="nav-number">3.1.3.</span> <span class="nav-text">数值范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值的表示法"><span class="nav-number">3.2.</span> <span class="nav-text">数值的表示法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值的进制"><span class="nav-number">3.3.</span> <span class="nav-text">数值的进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊数值"><span class="nav-number">3.4.</span> <span class="nav-text">特殊数值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正零和负零"><span class="nav-number">3.4.1.</span> <span class="nav-text">正零和负零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NaN"><span class="nav-number">3.4.2.</span> <span class="nav-text">NaN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#含义"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算规则"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">运算规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Infinity"><span class="nav-number">3.4.3.</span> <span class="nav-text">Infinity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#含义-1"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算规则-1"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">运算规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与数值相关的全局方法"><span class="nav-number">3.5.</span> <span class="nav-text">与数值相关的全局方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parseInt"><span class="nav-number">3.5.1.</span> <span class="nav-text">parseInt()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进制转换"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">进制转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parseFloat"><span class="nav-number">3.5.2.</span> <span class="nav-text">parseFloat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isNaN"><span class="nav-number">3.5.3.</span> <span class="nav-text">isNaN()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isFinite"><span class="nav-number">3.5.4.</span> <span class="nav-text">isFinite()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">4.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转义"><span class="nav-number">4.1.2.</span> <span class="nav-text">转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串与数组"><span class="nav-number">4.1.3.</span> <span class="nav-text">字符串与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length-属性"><span class="nav-number">4.1.4.</span> <span class="nav-text">length 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符集"><span class="nav-number">4.2.</span> <span class="nav-text">字符集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Base64-转码"><span class="nav-number">4.3.</span> <span class="nav-text">Base64 转码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象"><span class="nav-number">5.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-4"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成方法"><span class="nav-number">5.1.1.</span> <span class="nav-text">生成方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键名"><span class="nav-number">5.1.2.</span> <span class="nav-text">键名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的引用"><span class="nav-number">5.1.3.</span> <span class="nav-text">对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式还是语句？"><span class="nav-number">5.1.4.</span> <span class="nav-text">表达式还是语句？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性的操作"><span class="nav-number">5.2.</span> <span class="nav-text">属性的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读取属性"><span class="nav-number">5.2.1.</span> <span class="nav-text">读取属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的赋值"><span class="nav-number">5.2.2.</span> <span class="nav-text">属性的赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看所有属性"><span class="nav-number">5.2.3.</span> <span class="nav-text">查看所有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-命令"><span class="nav-number">5.2.4.</span> <span class="nav-text">delete 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-运算符"><span class="nav-number">5.2.5.</span> <span class="nav-text">in 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…in-循环"><span class="nav-number">5.2.6.</span> <span class="nav-text">for…in 循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#with-语句"><span class="nav-number">5.3.</span> <span class="nav-text">with 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">6.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义-1"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的本质"><span class="nav-number">6.2.</span> <span class="nav-text">数组的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#length-属性-1"><span class="nav-number">6.3.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-运算符-1"><span class="nav-number">6.4.</span> <span class="nav-text">in 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for…in-循环和数组的遍历"><span class="nav-number">6.5.</span> <span class="nav-text">for…in 循环和数组的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的空位"><span class="nav-number">6.6.</span> <span class="nav-text">数组的空位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类似数组的对象"><span class="nav-number">6.7.</span> <span class="nav-text">类似数组的对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-5"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的声明"><span class="nav-number">7.1.1.</span> <span class="nav-text">函数的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的重复声明"><span class="nav-number">7.1.2.</span> <span class="nav-text">函数的重复声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆括号运算符，return-语句和递归"><span class="nav-number">7.1.3.</span> <span class="nav-text">圆括号运算符，return 语句和递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一等公民"><span class="nav-number">7.1.4.</span> <span class="nav-text">第一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数名的提升"><span class="nav-number">7.1.5.</span> <span class="nav-text">函数名的提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不能在条件语句中声明函数"><span class="nav-number">7.1.6.</span> <span class="nav-text">不能在条件语句中声明函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的属性和方法"><span class="nav-number">7.2.</span> <span class="nav-text">函数的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#name-属性"><span class="nav-number">7.2.1.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length-属性-2"><span class="nav-number">7.2.2.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-NaN"><span class="nav-number">7.2.3.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数作用域"><span class="nav-number">7.3.</span> <span class="nav-text">函数作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">7.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部的变量提升"><span class="nav-number">7.3.2.</span> <span class="nav-text">函数内部的变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数本身的作用域"><span class="nav-number">7.3.3.</span> <span class="nav-text">函数本身的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数"><span class="nav-number">7.4.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-6"><span class="nav-number">7.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数的省略"><span class="nav-number">7.4.2.</span> <span class="nav-text">参数的省略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递方式"><span class="nav-number">7.4.3.</span> <span class="nav-text">传递方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同名参数"><span class="nav-number">7.4.4.</span> <span class="nav-text">同名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arguments-对象"><span class="nav-number">7.4.5.</span> <span class="nav-text">arguments 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-3"><span class="nav-number">7.4.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与数组的关系"><span class="nav-number">7.4.5.2.</span> <span class="nav-text">与数组的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#callee-属性"><span class="nav-number">7.4.5.3.</span> <span class="nav-text">callee 属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的其他知识点"><span class="nav-number">7.5.</span> <span class="nav-text">函数的其他知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">7.5.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即调用的函数表达式（IIFE）"><span class="nav-number">7.5.2.</span> <span class="nav-text">立即调用的函数表达式（IIFE）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eval-命令"><span class="nav-number">7.6.</span> <span class="nav-text">eval 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-number">8.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加法运算符"><span class="nav-number">8.1.</span> <span class="nav-text">加法运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本规则"><span class="nav-number">8.1.1.</span> <span class="nav-text">基本规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的相加"><span class="nav-number">8.1.2.</span> <span class="nav-text">对象的相加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算符"><span class="nav-number">8.2.</span> <span class="nav-text">算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#余数运算符"><span class="nav-number">8.2.1.</span> <span class="nav-text">余数运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自增和自减运算符"><span class="nav-number">8.2.2.</span> <span class="nav-text">自增和自减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值运算符，负数值运算符"><span class="nav-number">8.2.3.</span> <span class="nav-text">数值运算符，负数值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指数运算符"><span class="nav-number">8.2.4.</span> <span class="nav-text">指数运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算符"><span class="nav-number">8.3.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较运算符"><span class="nav-number">8.4.</span> <span class="nav-text">比较运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的比较"><span class="nav-number">8.4.1.</span> <span class="nav-text">字符串的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非字符串的比较"><span class="nav-number">8.4.2.</span> <span class="nav-text">非字符串的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型的值"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">原始类型的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象-1"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格相等运算符"><span class="nav-number">8.4.3.</span> <span class="nav-text">严格相等运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不同类型的值"><span class="nav-number">8.4.3.1.</span> <span class="nav-text">不同类型的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同一类的原始类型值"><span class="nav-number">8.4.3.2.</span> <span class="nav-text">同一类的原始类型值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复合类型值"><span class="nav-number">8.4.3.3.</span> <span class="nav-text">复合类型值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined-和-null"><span class="nav-number">8.4.3.4.</span> <span class="nav-text">undefined 和 null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格不相等运算符"><span class="nav-number">8.4.3.5.</span> <span class="nav-text">严格不相等运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相等运算符"><span class="nav-number">8.4.4.</span> <span class="nav-text">相等运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型的值-1"><span class="nav-number">8.4.4.1.</span> <span class="nav-text">原始类型的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象与原始类型值比较"><span class="nav-number">8.4.4.2.</span> <span class="nav-text">对象与原始类型值比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined-和-null-1"><span class="nav-number">8.4.4.3.</span> <span class="nav-text">undefined 和 null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相等运算符的缺点"><span class="nav-number">8.4.4.4.</span> <span class="nav-text">相等运算符的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不相等运算符"><span class="nav-number">8.4.4.5.</span> <span class="nav-text">不相等运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔运算符"><span class="nav-number">8.5.</span> <span class="nav-text">布尔运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#取反运算符（-）"><span class="nav-number">8.5.1.</span> <span class="nav-text">取反运算符（!）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#且运算符（-amp-amp-）"><span class="nav-number">8.5.2.</span> <span class="nav-text">且运算符（&amp;&amp;）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#或运算符（-）"><span class="nav-number">8.5.3.</span> <span class="nav-text">或运算符（||）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元条件运算符（-）"><span class="nav-number">8.5.4.</span> <span class="nav-text">三元条件运算符（?:）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算符"><span class="nav-number">8.6.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-7"><span class="nav-number">8.6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制或运算符"><span class="nav-number">8.6.2.</span> <span class="nav-text">二进制或运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制与运算符"><span class="nav-number">8.6.3.</span> <span class="nav-text">二进制与运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制否运算符"><span class="nav-number">8.6.4.</span> <span class="nav-text">二进制否运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异或运算"><span class="nav-number">8.6.5.</span> <span class="nav-text">异或运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左移运算符"><span class="nav-number">8.6.6.</span> <span class="nav-text">左移运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右移运算符"><span class="nav-number">8.6.7.</span> <span class="nav-text">右移运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带符号位的右移运算符"><span class="nav-number">8.6.8.</span> <span class="nav-text">带符号位的右移运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开关作用"><span class="nav-number">8.6.9.</span> <span class="nav-text">开关作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他运算符"><span class="nav-number">8.7.</span> <span class="nav-text">其他运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#void-运算符"><span class="nav-number">8.7.1.</span> <span class="nav-text">void 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逗号运算符"><span class="nav-number">8.7.2.</span> <span class="nav-text">逗号运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算顺序"><span class="nav-number">8.8.</span> <span class="nav-text">运算顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级"><span class="nav-number">8.8.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆括号的作用"><span class="nav-number">8.8.2.</span> <span class="nav-text">圆括号的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左结合与右结合"><span class="nav-number">8.8.3.</span> <span class="nav-text">左结合与右结合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型转换"><span class="nav-number">9.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#强制转换"><span class="nav-number">9.1.</span> <span class="nav-text">强制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Number"><span class="nav-number">9.1.1.</span> <span class="nav-text">Number()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型值"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">原始类型值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象-2"><span class="nav-number">9.1.1.2.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">9.1.2.</span> <span class="nav-text">String()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型值-1"><span class="nav-number">9.1.2.1.</span> <span class="nav-text">原始类型值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象-3"><span class="nav-number">9.1.2.2.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean"><span class="nav-number">9.1.3.</span> <span class="nav-text">Boolean()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动转换"><span class="nav-number">9.2.</span> <span class="nav-text">自动转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为布尔值"><span class="nav-number">9.2.1.</span> <span class="nav-text">自动转换为布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为字符串"><span class="nav-number">9.2.2.</span> <span class="nav-text">自动转换为字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为数值"><span class="nav-number">9.2.3.</span> <span class="nav-text">自动转换为数值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理机制"><span class="nav-number">10.</span> <span class="nav-text">错误处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-实例对象"><span class="nav-number">10.1.</span> <span class="nav-text">Error 实例对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原生错误类型"><span class="nav-number">10.2.</span> <span class="nav-text">原生错误类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SyntaxError-对象"><span class="nav-number">10.2.1.</span> <span class="nav-text">SyntaxError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReferenceError-对象"><span class="nav-number">10.2.2.</span> <span class="nav-text">ReferenceError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RangeError-对象"><span class="nav-number">10.2.3.</span> <span class="nav-text">RangeError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeError-对象"><span class="nav-number">10.2.4.</span> <span class="nav-text">TypeError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URIError-对象"><span class="nav-number">10.2.5.</span> <span class="nav-text">URIError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EvalError-对象"><span class="nav-number">10.2.6.</span> <span class="nav-text">EvalError 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">10.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义错误"><span class="nav-number">10.3.</span> <span class="nav-text">自定义错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw语句"><span class="nav-number">10.4.</span> <span class="nav-text">throw语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try…catch-结构"><span class="nav-number">10.5.</span> <span class="nav-text">try…catch 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally-代码块"><span class="nav-number">10.6.</span> <span class="nav-text">finally 代码块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-编程风格"><span class="nav-number">11.</span> <span class="nav-text">JavaScript 编程风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-8"><span class="nav-number">11.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缩进"><span class="nav-number">11.2.</span> <span class="nav-text">缩进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区块-1"><span class="nav-number">11.3.</span> <span class="nav-text">区块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#圆括号"><span class="nav-number">11.4.</span> <span class="nav-text">圆括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#行尾的分号"><span class="nav-number">11.5.</span> <span class="nav-text">行尾的分号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不使用分号的情况"><span class="nav-number">11.5.1.</span> <span class="nav-text">不使用分号的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for-和-while-循环"><span class="nav-number">11.5.1.1.</span> <span class="nav-text">for 和 while 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分支语句：if，switch，try"><span class="nav-number">11.5.1.2.</span> <span class="nav-text">分支语句：if，switch，try</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的声明语句"><span class="nav-number">11.5.1.3.</span> <span class="nav-text">函数的声明语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分号的自动添加"><span class="nav-number">11.5.2.</span> <span class="nav-text">分号的自动添加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量"><span class="nav-number">11.6.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量声明"><span class="nav-number">11.7.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#with语句"><span class="nav-number">11.8.</span> <span class="nav-text">with语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相等和严格相等"><span class="nav-number">11.9.</span> <span class="nav-text">相等和严格相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句的合并"><span class="nav-number">11.10.</span> <span class="nav-text">语句的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自增和自减运算符-1"><span class="nav-number">11.11.</span> <span class="nav-text">自增和自减运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch…case-结构"><span class="nav-number">11.12.</span> <span class="nav-text">switch…case 结构</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fnine59</span>
  
</div>

  <div class="powered-by">Powerd by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 102854, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 102854, xid: "2018/05/06/《JavaScript标准参考教程》阅读笔记之《语法》/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/102854/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("QTeKY0jLRTzpECO9LofVA2eq-gzGzoHsz", "ls92zfSW8iXNYPQ5b2COG6L4");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>

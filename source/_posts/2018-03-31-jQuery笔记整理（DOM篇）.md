---
title: jQuery笔记整理（DOM篇）
date: 2018-03-31 16:40:52
tags: jQuery
categories: 技术
---
### 创建节点与属性处理
* `$("html结构")`可以创建出来，例如`$("<div></div>")`，如果要指定属性，则`$("<div id='test' class='aaron'>我是文本节点</div>")`即可。

### DOM内部插入append()与appendTo()
* `.append(content)`向每个匹配id元素内部追加内容
* `.appendTo(content)`把所有匹配的元素追加到另一个指定的元素集合中
* 这个方法可以使得创建的新节点显示在文档中，将新创建的元素当作页面某一个元素的子元素放到其内部即可。
* append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。
* appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。
* 区别：append()前面是被插入的对象，后面是要在对象内插入的元素内容；appendTo()前面是要插入的元素内容，而后面是被插入的对象

### DOM内部插入prepend()与prependTo()
* `.prepend()`方法将指定元素插入到匹配元素里面作为它的第一个子元素。
* `.prependTo()`方法把所有匹配的元素前置到另一个指定的元素集合中。

### DOM外部插入after()与before()
* 内部插入着重于节点之间的父子、祖辈关系；而外部插入着眼于节点之间的兄弟关系。
* `.after(content)`方法在匹配元素集合中的每个元素后插入参数指定的内容，作为其兄弟节点。
* `.before(content)`方法按参数设定，在匹配元素的前面插入内容。

### DOM外部插入insertAfter()与insertBefore()
* `.insertBefore()`方法在目标元素前面插入集合中每个匹配的元素
* `.insertAfter()`方法在目标元素后面插入集合中每个匹配的元素

* **注意：**after和before方法都是将要插入的内容作为参数，而insertBefore和insertAfter方法则相反，要插入的内容在方法前面。

### 删除节点
* empty()
	* empty方法用于清除指定元素中的所有子节点
* remove()
	* remove方法与empty方法一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。
	* remove方法可以传参，比如`$("p").remove(":contains('3')")`，意思是找到所有p元素中，包含了3的元素，这个也是一个过滤器的处理。可以通过类似于`$("p").filter(":contains('3')").remove()`的方式进行处理。
* detach()
	* 如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理。
	* 可以使用一个变量接收detach方法的返回值，当执行完detach方法后会移除对象，但仅仅是显示效果没有了，在内存中还是存在的，可以使用`append(刚才接收返回值的变量)`将元素重新放回文档流中。这时可以发现该元素绑定的事件仍然生效。
	
### DOM拷贝clone()
* clone方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。
* 注意：如果节点有事件或者数据之类的其他处理，我们需要通过`clone(true)`传递一个布尔值true用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了。
* clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css('color','red') 增加了一个颜色。

### DOM替换replaceWith()和replaceAll()
* `.replaceWith(newContent)`用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。
* `.replaceAll(target)`用集合的匹配元素替换每个目标元素。
* 注意：这两个方法都会删除与节点相关联的所有数据和事件处理程序。

### DOM包裹
* wrap()方法
	* `.wrap(wrappingElement)`在集合中匹配的每个元素周围包裹一个HTML结构
	* `.wrap( function )` ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。使用后的效果与直接传递参数是一样的，只不过可以把代码写在函数体内部，写法不同而已。
* unwrap()方法
	* 这个方法与wrap的方法是相反的，将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在的话）在原来的位置。
* wrapALl()方法
	* `.wrapAll(wrappingElement)`：给集合中匹配的元素增加一个外面包裹的HTML结构。
	* 这个方法同样有`.wrapALl(function)`的写法，通过回调的方式可以单独处理每一个元素，等同于wrap的处理。
* wrapInner()方法
	* `.wrapInner(wrappingElement)`：给集合中匹配的元素的内部增加包裹的HTML结构。
	* 例子：
		```
		<div>p元素</div>
		<div>p元素</div>
		```
		给所有元素增加一个p包裹
		```
		$('div').wrapInner('<p></p>')
		```
		最后的结构
		```
		<div>
			<p>p元素</p>
		</div>
		<div>
			<p>p元素</p>
		</div>
		```
	* 此方法也有`.wrapInner( function ) `的写法，允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行并返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容。效果等同于第一种处理。
	
### jQuery的遍历
* children()方法
	* 用于快速查找元素合集里面的第一级子元素。由于jQuery是一个合集对象，所以通过children是匹配合集中每一个元素的第一级子元素。同时也因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，因此允许传一个选择器的表达式。比如`$('.div').children(':last')`。
* find()方法
	* find是遍历当前元素集合中每个元素的后代，不仅是儿子，祖孙辈也可以。
	* 与其他的树遍历方法不同，选择器表达式对于 .find() 是**必需**的参数。**如果我们需要实现对所有后代元素的取回，可以传递通配选择器 `*`**。
	* find只在后代中遍历，不包括自己。
* parent()方法
	* 用于快速查找合集里面每一个元素的父元素。
	* jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素。同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。
* parents()方法
	* 用于快速查找合集里面每一个元素的所有祖辈元素。
	* 也有无参或带参两种使用方法。
* closest()方法
	* 该方法从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。closest()方法接受一个匹配元素的选择器字符串。
	* 与parents方法类似，但还是有些区别：
		1. 起始位置不同：.closest开始于当前元素 .parents开始于父元素
		2. 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合
		3. 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象
* next()方法
	* 用于快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合。
	* next()无参数：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素。
	* next()方法选择性地接受同一类型选择器表达式： 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式。
* prev()方法
	* 用于快速查找合集里面每一个元素紧邻的前面同辈元素的元素集合。
	* prev方法也有无参和有参两种用法。
* siblings()方法
	* 用于快速查找指定元素集合中每一个元素的同辈元素
	* 此方法也有也有无参和有参两种用法。
* add()方法
	* 用来创建一个新的jQuery对象，元素添加到匹配的元素集合中。
* each()方法
	* .each()方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始计数）。
	* 例子：
	```
	<ul>
		<li>慕课网</li>
		<li>Aaron</li>
	</ul>
	```
	以上是结构，现在开始迭代li，循环2次
	···
	$("li").each(function(index, element) {
		 //index 索引 0,1
		 //element是对应的li节点 li,li
		 //this 指向的是li
		 //如果需要提前退出，可以以通过返回 false以便在回调函数内中止循
	})
	```
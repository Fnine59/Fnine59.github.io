---
title: Vue学习笔记之Vue2.0
date: 2018-06-08 16:11:18
tags: Vue
categories: 技术
---

# Vue2.0的使用

首先去官网中下载2.0版本的`vue.js`文件。下载知乎可以通过`bower info`查看vue的版本。

# Vue2.0中的变化

## 组件模板代码写法的变化

在每个组件模板中，不再支持片段代码。

在Vue1.0版本中，组件的定义可以使用下面的写法：
```
<script>
	var Aaa = Vue.extend('aaa',{
		template: '<h4>这是组件</h4>'
	});
	
	Vue.component('my-aaa',Aaa);

	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			}
		});
	}
</script>


<body>
	<div id="box">
		{{msg}}
	</div>
</body>
```
上面的这种写法，其实就算能用也不经常被使用。通常会用下面的这种写法：
```
<script>
	Vue.component('my-aaa',{
		template: '<h4>这是组件</h4><strong>这是加粗标签</strong>'
	});

	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			}
		});
	}
</script>


<body>
	<div id="box">
		<my-aaa></my-aaa>
		{{msg}}
	</div>
</body>

//或者另一种将模板提取出来的写法
<script>
	Vue.component('my-aaa',{
		template: '#aaa'
	});

	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			}
		});
	}
</script>


<body>
	<template id="aaa">
		<h4>这是组件</h4><strong>这是加粗标签</strong>
	</template>
	<div id="box">
		<my-aaa></my-aaa>
		{{msg}}
	</div>
</body>
```
上面的代码如果是vue1.0版本是不会出现问题的，但如果是2.0版本，template中只写一个标签也是没有问题的，但**写了两个并列的标签就会报错**。

关于组件中的模板，<font color="red">**Vue2.0中必须有一个根元素包裹住所有的代码**</font>。

代码如下：
```
<script>
	Vue.component('my-aaa',{
		template: '#aaa'
	});

	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			}
		});
	}
</script>


<body>
	<template id="aaa">
		<div>
			<h4>这是组件</h4>
			<strong>这是加粗标签</strong>
		</div>
	</template>
	<div id="box">
		<my-aaa></my-aaa>
		{{msg}}
	</div>
</body>
```

## 关于组件的定义

`Vue.extend`这种方式在2.0中有，但是有一些改动，但是这里不做赘述，因为这种写法即使能用也不推荐使用。

无论1.0还是2.0，推荐组件定义的方法如下：
```
Vue.component(组件名称,{
	data(){},
	methods:{},
	template:{}
})
```

除此之外，2.0还提供了一种更为简洁的<font color="red">全局组件定义</font>的方式：

```
<script>
	var Home = { // 这是2.0组件
		template: '#aaa'
	} // 类似之前的Vue.extend()
	
	Vue.component('my-aaa', Home);

	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			}
		});
	}
</script>


<body>
	<template id="aaa">
		<div>
			<h4>这是组件</h4>
			<strong>这是加粗标签</strong>
		</div>
	</template>
	<div id="box">
		<my-aaa></my-aaa>
		{{msg}}
	</div>
</body>
```

2.0中<font color="red">局部组件</font>的定义：
```
<script>
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			},
			components: {
				'aaa': Home
			}
		});
	}
</script>


<body>
	<template id="aaa">
		<div>
			<h4>这是组件</h4>
			<strong>这是加粗标签</strong>
		</div>
	</template>
	<div id="box">
		<aaa></aaa>
		{{msg}}
	</div>
</body>
```

## 生命周期的变化

vue中的生命周期又被叫做钩子函数。

1.0中的生命周期：

	init
	created
	beforeCompile
	cmpiled
	ready
	beforeDestroy
	destroyed
	
2.0中的生命周期：
```
<script>
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 'welcome vue2.0'
			},
			methods:{
				update(){
					this.msg = 'change the msg'
				},
				destroy(){
					this.$destroy();
				}
			},
			beforeCreate(){
				// 组件实例刚刚被创建，属性等都没有。相当于1.0中的init
			},
			created(){
				// 实例已经创建完成，属性已经绑定，和1.0中的created相同
			},
			beforeMount(){
				// 模板编译之前，相当于1.0中的beforeCompiled
			},
			mounted(){
				// 模板已经编译完成，相当于1.0中的cmpiled和ready
				// 之前ready用对的较多，现在mounted用的比较多
			},
			
			//下面是2.0中新增的生命周期，是与更新组件相关的两个方法
			//本案例中点击按钮更新msg数据的时候就会调用这两个方法
			//这两个新增的方法会很有用处
			beforeUpdate(){
				// 组件更新之前
			},
			updated(){
				// 组件更新完毕
			},
			
			//然后是和1.0中相同的组件销毁的两个生命周期
			beforeDestroy(){
				// 组件销毁之前
			},
			destroyed(){
				// 组件销毁之后
			}
		});
	}
</script>

<body>
	<div id="box">
		<input type="button" value="更新数据" @click="update">
		<input type="button" value="销毁组件" @click="destroy">
		{{msg}}
	</div>
</body>
```

2.0钩子函数总结：

	beforeCreate		 组件实例刚刚被创建，属性等都没有，相当于之前的init
	created			  实例已经创建完成，属性已经绑定，相当于之前的created
	beforeMount		  模板编译之前，相当于之前的beforeCompile
	mounted			  模板编译之后，相当于之前的cmpiled和ready
	beforeUpdate		 组件更新之前，2.0新增
	updated			  组件更新完毕之后，2.0新增
	beforeDestroy		组件销毁之前，相当于之前的beforeDestroy
	destroyed			组件销毁之后，相当于之前的destroyed
	
其中**<font color="red">`mounted`和`updated`两个钩子函数会经常使用</font>**。

## 2.0中的循环

### 关于循环中的重复值

首先来看1.0中的循环。
```
<script>
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				list:['width','height','border']
			},
			methods:{
				add(){
					this.list.push('background');
				}
			}
		});
	}
</script>

<body>
	<div id="box">
		<input type="button" value="添加" @click="add">
		<ul>
			<li v-for="val in list" track-by="$index">
				{{val}}
			</li>
		</ul>
	</div>
</body>
```
上面的代码中，如果点击按钮，会一直添加相同的值。如果循环的地方不加`track-by="$index"`语句，则无法添加多个相同的值，也就是说，1.0中的`v-for`不可以添加重复值，需要添加重复值则要添加`track-by="$index"`语句。

而在2.0中，**<font color="red">`v-for`循环默认就可以添加重复的数据</font>**了，不需要`track-by`。

### 关于隐式变量

另外还有一点比较重要的是，vue 2.0中<font color="red">去掉了一些隐式变量</font>，比如用于获取数组元素索引值的`$index`和用于获取键值的`$key`。

那么vue 2.0中如何获取当前元素的索引值呢？代码如下：

```
<script>
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				list:['width','height','border']
			},
			methods:{
				add(){
					this.list.push('background');
				}
			}
		});
	}
</script>

<body>
	<div id="box">
		<input type="button" value="添加" @click="add">
		<ul>
			<li v-for="(val,index) in list">
				{{val}} {{index}}
			</li>
		</ul>
	</div>
</body>
```
上面的这种写法其实vue 1.0中也有，但是需要注意的是：**<font color="red">vue 1.0中值和索引的顺序是`(index,val)`，而vue2.0中值和索引的顺序是`(val,index)`</font>**。这样做会更贴近原生js的语法，原生js中`arr.forEach(function(item,index)){}`就是这样的顺序。

索引值的问题解决了，那么vue 2.0中如何获取当前元素的键值呢？代码如下：

```
<script>
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				list:{
					a: 'apple',
					b: 'banana',
					c: 'cell'
				}
			}
		});
	}
</script>

<body>
	<div id="box">
		<ul>
			<li v-for="(val,key) in list">
				{{val}} {{key}}
			</li>
		</ul>
	</div>
</body>
```

这里补充一点关于`track-by`的小知识。`track-by`的作用其实是提高循环性能，传入的值是元素的索引值。<font color="red">vue 2.0去掉了`track-by`之后，提高循环性能使用`:key="index"`</font>，`index`是元素的索引值，在`v-for="(val,index) in list"`语句中声明。

## 自定义键盘指令的变化

vue 1.0中自定义键盘指令使用`Vue.directive('on'),keyCodes.ctrl = 17;`。
```
<script>
	Vue.directive('on'),keyCodes.ctrl = 17;
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
			},
			methods:{
				change(){
					alert('changed!');
				}
			}
		});
	}
</script>

<body>
	<div id="box">
		<input type="text" @keyup.ctrl="change">
	</div>
</body>
```

vue 2.0中的写法是`Vue.config.keyCodes.ctrl=17;`

```
<script>
	Vue.config.keyCodes.ctrl=17;
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
			},
			methods:{
				change(){
					alert('changed!');
				}
			}
		});
	}
</script>

<body>
	<div id="box">
		<input type="text" @keyup.ctrl="change">
	</div>
</body>
```

## 过滤器的变化

vue 1.0中自带了很多使用的过滤器，比如json、currency等等。而vue 2.0中，作者把所有内置过滤器全部删除了，使用过滤器需要自己通过js实现。也是因为这样vue 2.0是目前性能最高的一个框架。

作者推荐使用lodash这个工具库。

需要注意一点的是，<font color="red">vue 1.0中输出json数据会显示`[Object Object]`，因此需要使用json过滤器。但是**vue 2.0中输出json数据会直接显示**，和1.0中使用json过滤器的效果相同，因此2.0不需要json过滤器</font>。

vue2.0中要自定义普通过滤器，和1.0中没有什么不同。

```
<script>
	Vue.filter('toDou',function(input){
		return input<10?'0'+input:''+input;
	});
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 9
			}
		});
	}
</script>

<body>
	<div id="box">
		{{msg | toDou}}
	</div>
</body>
```

但如果在vue 2.0 中要给自定义的过滤器传参，就有些小小的变化了。

<font color="red">vue1.0中自定义过滤器传参的时候使用空格隔开</font>，代码如下。
```
<script>
	Vue.filter('toDou',function(input, a, b){
		alert(a + ',' + b);
		return input<10?'0'+input:''+input;
	});
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 9
			}
		});
	}
</script>

<body>
	<div id="box">
		{{msg | toDou '18' '6'}}
	</div>
</body>
```

而<font color="red">vue2.0中自定义过滤器传参的时候使用函数的写法，也就是使用括号</font>，代码如下。
```
<script>
	Vue.filter('toDou',function(input, a, b){
		alert(a + ',' + b);
		return input<10?'0'+input:''+input;
	});
	window.onload = function(){
		new Vue({
			el: '#box',
			data: {
				msg: 9
			}
		});
	}
</script>

<body>
	<div id="box">
		{{msg | toDou('18','6')}}
	</div>
</body>
```





